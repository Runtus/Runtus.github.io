<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Posts | Runtus</title>
<meta name=keywords content>
<meta name=description content="Posts - Runtus">
<meta name=author content="Runtus">
<link rel=canonical href=https://runtus.top/posts/>
<link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style>
<link rel=icon href=https://runtus.top/avatar.png>
<link rel=icon type=image/png sizes=16x16 href=https://runtus.top/avatar.png>
<link rel=icon type=image/png sizes=32x32 href=https://runtus.top/avatar.png>
<link rel=apple-touch-icon href=https://runtus.top/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://runtus.top/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<link href=https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css rel=stylesheet>
<script src=https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js></script>
<script>const ap=new Aplayer({container:document.getElementById("aplayer"),audio:[{name:"踊り子",artist:"Vaundy",url:"https://lao-lan-go.oss-accelerate.aliyuncs.com/hugo-server/audios/Vaundy%20-%20%E8%B8%8A%E3%82%8A%E5%AD%90.mp3",cover:"https://lao-lan-go.oss-accelerate.aliyuncs.com/hugo-server/audios/Vaundy.jpg"}]})</script>
<link rel=alternate type=application/rss+xml href=https://runtus.top/posts/index.xml>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Posts">
<meta property="og:description" content="blog from Runtus">
<meta property="og:type" content="website">
<meta property="og:url" content="https://runtus.top/posts/"><meta property="og:image" content="https://lao-lan-go.oss-cn-beijing.aliyuncs.com/highQua/pixiv34.JPG"><meta property="og:site_name" content="Runtus">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://lao-lan-go.oss-cn-beijing.aliyuncs.com/highQua/pixiv34.JPG">
<meta name=twitter:title content="Posts">
<meta name=twitter:description content="blog from Runtus">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://runtus.top/posts/"}]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://runtus.top/ accesskey=h title="Home (Alt + H)">
<img src=https://runtus.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://runtus.top/archives/ title=archives>
<span>archives</span>
</a>
</li>
<li>
<a href=https://runtus.top/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://runtus.top/friends title=friends>
<span>friends</span>
</a>
</li>
<li>
<a href=https://runtus.top/search title="search (Alt + /)" accesskey=/>
<span>search</span>
</a>
</li>
<li>
<a href=https://runtus.top/ncm title=网易云转换>
<span>网易云转换</span>
</a>
</li>
<li>
<a href=https://github.com/Runtus title=github>
<span>github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<header class=page-header><div class=breadcrumbs><a href=https://runtus.top/>Home</a></div>
<h1>
Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg>
</a>
</h1>
</header>
<article class=post-entry>
<header class=entry-header>
<h2>Node Packages
</h2>
</header>
<div class=entry-content>
<p>之前一直被nodejs的模块执行规则所困扰，这种困扰来自于目前Commonjs和ESModule在Node端能够并存的情况，什么时候能够执行ESModule，什么时候不能执行；在引用第三方包node_modules，具体的包是根据什么来区分是ESModule还是Commonjs。
通过阅读了Nodejs的原文档，这些问题也随之迎刃而解，所以特此在本篇做一做记录。
注：以下内容都是基于Nodejs V20.5.0 进行编写。
Nodejs中的模块系统 在Node环境下，如今共存着两种模块规范：ESModule和Commonjs，前者是ES6中提出模块化规范，所以为了统一整个Javascript的模块化规范，Nodejs也逐渐的由之前主流的Commonjs规范转变为ESModule，只不过为了兼容Nodejs老版本的代码，所以现在这两种模块在Node中是并存的关系，但是前者(ESModule)是趋势。 关于Commonjs和ESMoudle的模块技术细节，例如语法区别，加载规则等在本篇不会提到，接下来将会它们在nodejs中的设置以及引用规则。 模块的执行与加载 Node在执行代码前会先去判断代码是ES模块还是commonjs模块，Node会从三个角度依次判断代码的模块归属。 ES模块 对于ES模块，当出现以下情况时，Nodejs会将文件视为ES模块。 扩展名为.mjs的文件。 项目所归属的package.json的type字段的值为module，此时文件扩展名为.js的文件都视为ES模块。 字符串作为参数传入 --eval，或通过 STDIN 管道传输到 node，带有标志 --input-type=module。 .mjs扩展名的文件被视为ES模块的优先级是最高的，无论它身处何方，只要Node发现其是.mjs的文件，就会将其视作ES模块来执行。 commonjs模块 对于commonjs模块，当出现以下情况时，Nodejs会将文件视为commonjs模块。 扩展名为.cjs的文件。 项目所属的package.json的type字段的值为commonjs时，此时文件扩展名为.js的文件都视为commonjs模块。 字符串作为参数传入 --eval 或 --print，或通过 STDIN 管道传输到 node，带有标志 --input-type=commonjs。 和ES模块类似，如果文件扩展名为.cjs，那么Nodejs都会将其视作commonjs模块。 如果不设置type字段，那么该项目将会默认为commonjs语法的项目。 模块加载器 Nodejs有两种加载器用于分别解析说明符和加载ES模块和commonjs模块。
commonjs模块加载器:
🌟 处理require()调用，并且是同步加载模块的， 🌟 支持以文件夹作为模块。 🌟 不能用于加载`ECMAScript模块（ESModule）。 🌟 解析路径时，如果未找到完全匹配项，那么将尝试添加扩展名**.js,.json,.node，然后最后再尝试解析文件夹作为模块**。 将.json文件视为JSON文本文件，可以直接使用require加载。 特别注意上述的四个带🌟的规则，在平时日常开发中应该是能够经常遇见的。从第4点也能知道为什么使用require引用包时，可以不带文件的扩展名，因为node在解析路径时会自动添加。 ECMAScript模块加载器:...</p>
</div>
<footer class=entry-footer><span title="2023-09-09 10:34:09 +0800 CST">September 9, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;249 words&nbsp;·&nbsp;Runtus</footer>
<a class=entry-link aria-label="post link to Node Packages" href=https://runtus.top/posts/node-packages/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>迭代器and生成器
</h2>
</header>
<div class=entry-content>
<p>很多的数据结构都具备迭代的性质，但是不同的数据结构的迭代方法有所不同，往往需要知道具体的数据结构来选择对应的迭代方法，例如数组的迭代可以通过索引来进行迭代。
为了统一迭代接口，使得我们可以不了解具体的数据结构的前提下也能进行迭代，所以有了迭代器这么一个概念，而生成器则是基于迭代器的一种能够控制函数流程的方法，生成器基于迭代器的原理运行，反过来生成器也能够快速构建迭代器。
迭代器 当需要对某个迭代对象进行迭代处理时，由于迭代之前需要事先知道如何使用数据结构，以及遍历顺序并不是数据结构固有的，所以想寻求某种机制去统一迭代过程，对每一种可迭代类型，都用同一种迭代方法，从而增加开发体验。（即无需事先知道如何迭代去实现迭代操作） 于是基于以上原因，诞生了迭代器概念，意在统一化所有迭代对象的处理方式。 可迭代协议 一个对象是可迭代对象，则需要暴露一个属性作为默认迭代器，并且该属性的key为Symbol.iterator，它的value是一个工厂函数，用于返回一个新迭代器。 js提供了一系列可以对可迭代对象进行操作的原生结构，如下图所示。 for-of 数组解构 扩展操作符号（即...) Array.from 创建集合 创建映射 Promise.all()接受由Promise组成的可迭代对象。 Promise.rice()接受由期约组成的可迭代对象。 yield*操作符，在生成器中使用。 上述谈到的原生结构在对可迭代对象进行操作时，会默认调用工厂函数生成一个迭代器，然后对迭代器进行操作。 迭代器协议 1. next和IteratorResult 可迭代协议描述了一个对象具有可迭代性质的要求和前提，而迭代器协议则是用于规范迭代器具有的性质和方法。 迭代器对象具有一个方法next，通过迭代器APInext()能够在可迭代对象中遍历数据，每次调用next都能获取到一个IteratorResult对象，其中包含迭代器返回的下一个值，如下所示。 const array = [1, 2, 4]; // 迭代器对象 const iter = array[Symbol.iterator](); console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) // output // { value: 1, done: false } // { value: 2, done: false } // { value: 4, done: false } // { value: undefined, done: true } // { value: undefined, done: true } 如上的输出结果所示，IteratorResult包含两个属性value和done，value表示本次迭代获取的值，而done则表示迭代是否结束，这从另一个角度也说明迭代器只能通过next方法来获取迭代器的当前位置。 2....</p>
</div>
<footer class=entry-footer><span title="2023-08-23 10:12:13 +0800 CST">August 23, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;543 words&nbsp;·&nbsp;Runtus</footer>
<a class=entry-link aria-label="post link to 迭代器and生成器" href=https://runtus.top/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8and%E7%94%9F%E6%88%90%E5%99%A8/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Web components
</h2>
</header>
<div class=entry-content>
<p>Web-Components Web-Components是一项标准，规范，目前它包含了三项主要技术：
Custom Elements自定义元素：（标签）它是一组JavaScript API，能够自定义Element以及其行为。 Shadow DOM影子DOM。 HTML templatesHTML模板：通过&lt;template>和&lt;slot>元素编写不在呈现页面中显示的标记模板。 通过这三个特性的共同作用能够创建封装功能的定制元素，在说明Web-Component的用法之前，先简单说明上述三项特性。
Custom Elements 自定义元素是Web Components中的一个重要特性，它能够让开发者将HTML页面（或者页面中的某个功能）封装为custom elements，从而达到复用的目的。目前支持custom elements的浏览器有FireFox，Chrome，Opera。
Custom Elements的管理是通过CustomElementRegistry接口进行操作的，其用于处理Web文档中的custom elements，同时它还提供注册自定义元素和查询已注册元素的方法，它的实例通过window.customElements属性来获得。
CustomElementRegistry接口有四个方法：
CustomElementRegistry.define()：定义一个新的自定义元素。 CustomElementRegistry.get()：返回指定自定义元素的构造函数，如果未自定义元素，则返回undefined。 CustomElementRegistry.upgrade(): 更新一个自定义元素。 CustomElementRegistry.whenDefined()：执行并返回一个已经定义的自定义元素的promise，即如果定义了这么一个元素，那么返回对应的promise。 CustomElementRegistry.define() 该方法是四个方法中最重要的方法，用于创建自定义元素，它接受三个参数： 自定义元素的名称，且其必须符合元素名称的DOMString标准字符串。 用于定义元素行为的类。 一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。 // 自定义Div class SelfDiv extends HTMLElement { constructor(){ // super方法的调用是必须得 super() // 元素的相关业务代码 } } // 使用customElements实例(CustomElementRegistry接口)来完成注册功能 customElements....</p>
</div>
<footer class=entry-footer><span title="2023-08-03 10:12:13 +0800 CST">August 3, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;339 words&nbsp;·&nbsp;Runtus</footer>
<a class=entry-link aria-label="post link to Web components" href=https://runtus.top/posts/webcomponents/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Rust Trait
</h2>
</header>
<div class=entry-content>
<p>Rust中的特征Trait类似于其他语言中的接口，它定义了一组可以被共享的行为，只要实现了特征，就能使用这组行为。
特征 Trait 特征的定义 通过trait关键字对特征进行定义。 pubtraitStudent{fn GoClass(&self);fn LeaveClass(&self);fn getClassRoom(&self)-> String;} 上述声明了**身为学生应该有的几个特征行为：**即上课，下课和获取教室房间号，那么其他具有学生性质的结构体（或者说为类）需要遵循该特征。 需要注意：特征只是坐函数签名，并不是真正的实现函数，函数的实现在绑定了该特征的类里实现，下面一节会提到。 类型实现特征 使用for关键字来为类实现特征。 pubstruct Bob{pubyear: String,pubsex: String }implStudentforBob{// 实现特征 fn GoClass(&self){// .... }fn LeaveClass(&self){// ... }fn getClassRoom(&self){// ... }} 在Bob类型中实现了Student特征声明的三个函数，这是必须的，除非在特征中有默认的实现。 如果特征中有默认的函数实现，那么绑定的类型可以不用再次实现函数，若实现了对应的函数，那么会覆盖默认的特征函数实现。如下所示。 pubtraitStudent{fn GoClass(&self){println!("this is student!");}fn LeaveClass(&self);fn getClassRoom(&self)-> String;}implStudentforBob{fn GoClass(&self){println!("this is Bob!");}fn LeaveClass(&self){// ... }fn getClassRoom(&self){// ... }} 调用Bob.GoClass时，会打印this is Bob!而不是this is student!，因为Bob类型中已经覆盖了GoClass之前的函数定义。 使用特征来作为函数参数 用特征来作为函数参数是非常重要的一点，相对类型的参数限制，特征的参数限制则显得更加细粒度，只要让传递的参数满足对应的特征即可，而不需要把所有类型都列举出来。 pubfn enterClassRoom(people: &implStudent){// TODO } 上述代码中展示了使用如何使用特征作为函数的参数，impl Student便是实现语法，它本身是语法糖，正式的书写方式如下所示。 pubfn enterClassRoom&lt;T: Student>(people: &T){} 其实不难理解，把特征作为函数参数，其实就是用特征来约束范型，这也叫做特征约束。 多重特征约束 上述展示的代码是单个特征约束，除了单特征约束，还可以实现多特征约束，例如上述例子中，除了使参数满足Student约束外，还可以使其实现Monitor约束，如下所示。 // 语法糖 pubfn enterAdminRoom(people: &(implStudent+Monitor)){}// 特征约束式 pubfn enterAdminRoom&lt;T: Student+Monitor>(prople: &T){}where关键字 当特征比较多时，用上述的表达方式会显得代码冗杂不易读，此时便可以使用where关键字来实现形式上的改进，如下所示。 pubfn someFunction&lt;T,U>(t: &T,u: &U)-> i32 whereT: Display+Clone,U: Clone +Debug{} 上述代码使得参数t必须满足Display和Clone特征，参数U必须满足Clone和Debug特征。 使用特征限制返回值 特征除了能够限制参数外，还可以限制返回值，其关键字用法也是impl Trait，和特征传参的语法糖形式相同。 fn returns_summarizable()-> implSummary{Weibo{username: String::from("sunface"),content: String::from("m1 max太厉害了，电脑再也不会卡",)}} 实现了Summary特征的类型才能返回，这样做的好处是：如果返回的真实类型非常复杂时，我们需要把所有类型都要进行声明，这样也会增加代码复杂度，那么便可以使用impl Trait的方式要求返回值，只要让待返回数据的类型满足指定的特征就能返回。 例如使用impl Iterator来告诉调用者，该函数将会返回一个迭代器。 但是这种形式的返回有个限制：只能返回一个具体的类型。假如函数内部可能会返回两个及以上的类型，那么编译器会报错，如下所示。 fn returns_summarizable(switch: bool)-> implSummary{ifswitch{Post{title: String::from("Penguins win the Stanley Cup Championship!...</p>
</div>
<footer class=entry-footer><span title="2023-07-17 20:09:43 +0800 CST">July 17, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;140 words&nbsp;·&nbsp;Runtus</footer>
<a class=entry-link aria-label="post link to Rust Trait" href=https://runtus.top/posts/rust-trait/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>Rust包管理
</h2>
</header>
<div class=entry-content>
<p>本文参考了Rust语言圣经中有关Rust包的介绍，攥写本章的目的是为了更好的掌握rust中包和模块的关系以及它们的代码组织方式，方便于未来的项目开发。
Rust中代码组织相关概念 在Rust中，代码的组织大致可以分为四个层次： 项目（Package） 工作空间（Workspace） 包（Crate） 模块（Module） Package 项目 Package其实就是通过命令cargo new创建的项目文件，其显著特征便是包含了cargo.toml文件，该文件标注了该Package的一些基本信息：例如名称，版本号，依赖等等。 一个Package由一个或多个包（Crate）组成，但是它最多只能包含一个库类型的包（即名为lib.rs的文件）。 Package还可以分为二进制Package和库Package。 二进制Package 直接使用命令cargo new package-name的Package-项目即为二进制项目，虽然在cargo.toml中没有显示指出Package的入口文件，但Cargo的惯例是：src/main.rs即为二进制包的根文件，即入口文件，所有的代码的执行都是从src/main.rs中的fn main()中开始执行的。 输入cargo run可以直接编译运行。 库Package 库Package在创建时需要增加--lib命令行参数选项，即cargo new package-lib-name --lib在，这样获得的Package是一个库Package，它只能作为一个第三方库被其他项目引用，而不能单独编译运行。 与 src/main.rs 一样，Cargo 知道，如果一个 Package 包含有 src/lib.rs，意味它包含有一个库类型的同名包 my-lib，该包的根文件是 src/lib.rs。 Package文件结构 需要注意的是，main.rs和lib.rs不是互斥关系，二者是可以共存的。当二者共存时，那就意味着它包含两个包：库包和二进制包，这两个包名也都是 package-name —— 都与 Package 同名。 下面是一个Package的文件结构。 . ├── Cargo.toml ├── Cargo.lock ├── src │ ├── main.rs │ ├── lib.rs │ └── bin │ └── main1....</p>
</div>
<footer class=entry-footer><span title="2023-07-05 17:33:19 +0800 CST">July 5, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;201 words&nbsp;·&nbsp;Runtus</footer>
<a class=entry-link aria-label="post link to Rust包管理" href=https://runtus.top/posts/rust%E5%8C%85%E7%AE%A1%E7%90%86/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=next href=https://runtus.top/posts/page/2/>Next&nbsp;&nbsp;»
</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=https://runtus.top/>Runtus</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> &
        <a href=https://beian.miit.gov.cn/ target=_blank>蜀ICP备2021023118号-1</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>