[{"content":" 之前一直被nodejs的模块执行规则所困扰，这种困扰来自于目前Commonjs和ESModule在Node端能够并存的情况，什么时候能够执行ESModule，什么时候不能执行；在引用第三方包node_modules，具体的包是根据什么来区分是ESModule还是Commonjs。\n通过阅读了Nodejs的原文档，这些问题也随之迎刃而解，所以特此在本篇做一做记录。\n注：以下内容都是基于Nodejs V20.5.0 进行编写。\nNodejs中的模块系统 在Node环境下，如今共存着两种模块规范：ESModule和Commonjs，前者是ES6中提出模块化规范，所以为了统一整个Javascript的模块化规范，Nodejs也逐渐的由之前主流的Commonjs规范转变为ESModule，只不过为了兼容Nodejs老版本的代码，所以现在这两种模块在Node中是并存的关系，但是前者(ESModule)是趋势。 关于Commonjs和ESMoudle的模块技术细节，例如语法区别，加载规则等在本篇不会提到，接下来将会它们在nodejs中的设置以及引用规则。 模块的执行与加载 Node在执行代码前会先去判断代码是ES模块还是commonjs模块，Node会从三个角度依次判断代码的模块归属。 ES模块 对于ES模块，当出现以下情况时，Nodejs会将文件视为ES模块。 扩展名为.mjs的文件。 项目所归属的package.json的type字段的值为module，此时文件扩展名为.js的文件都视为ES模块。 字符串作为参数传入 --eval，或通过 STDIN 管道传输到 node，带有标志 --input-type=module。 .mjs扩展名的文件被视为ES模块的优先级是最高的，无论它身处何方，只要Node发现其是.mjs的文件，就会将其视作ES模块来执行。 commonjs模块 对于commonjs模块，当出现以下情况时，Nodejs会将文件视为commonjs模块。 扩展名为.cjs的文件。 项目所属的package.json的type字段的值为commonjs时，此时文件扩展名为.js的文件都视为commonjs模块。 字符串作为参数传入 --eval 或 --print，或通过 STDIN 管道传输到 node，带有标志 --input-type=commonjs。 和ES模块类似，如果文件扩展名为.cjs，那么Nodejs都会将其视作commonjs模块。 如果不设置type字段，那么该项目将会默认为commonjs语法的项目。 模块加载器 Nodejs有两种加载器用于分别解析说明符和加载ES模块和commonjs模块。\ncommonjs模块加载器:\n🌟 处理require()调用，并且是同步加载模块的， 🌟 支持以文件夹作为模块。 🌟 不能用于加载`ECMAScript模块（ESModule）。 🌟 解析路径时，如果未找到完全匹配项，那么将尝试添加扩展名**.js,.json,.node，然后最后再尝试解析文件夹作为模块**。 将.json文件视为JSON文本文件，可以直接使用require加载。 特别注意上述的四个带🌟的规则，在平时日常开发中应该是能够经常遇见的。从第4点也能知道为什么使用require引用包时，可以不带文件的扩展名，因为node在解析路径时会自动添加。 ECMAScript模块加载器:\n🌟 处理import()和import表达式，并且是异步加载模块的。 🌟 只接收Javascript文本文件的.js,.mjs和.cjs扩展名。 🌟 可以加载JSON模块，但需要导入断言。 🌟 不支持文件夹作为模块，必须完全指定目录索引。(例如./dir/index.js)。 🌟 可以加载Javascript Commonjs模块，导入的cjs模块会通过cjs-module-lexer来尝试识别命名的导出，同时导入的CommonJS模块会将其URL转化为绝对路径，然后通过CommonJS模块加载器加载。 需要注意的是第五点：ESModule可以加载CommonJS模块的文件，这和Commonjs语法是不同的。 以.mjs结尾的文件总是加载为ESModule，不会管最近的package.json。\n以.cjs结尾的文件总是加载为commonjs，不会管最近的package.json。\n包入口点 package.json中定义了该node项目的包信息，那么如果该package想被另一个package所引用，正如我们开发时引用第三方包那样import xxx from \u0026quot;xxx\u0026quot;，那么需要在package中定义包的入口点，及入口文件。 main字段 main字段可以定义包的入口点，它适用于ES模块和CommonJS模块入口点，并且支持所有Nodejs版本。 但是它的缺点也显而易见，只能定义一个入口点，及包的主要入口点。 例如我们package的文件结构如下所示。 ├── package.json ├── src │ ├── index.js │ └── pack.js ├── test.json └── yarn.lock 设置main: \u0026quot;src/index.js\u0026quot;，那么当外部在引用该package时，将会直接引用src/index.js。 exports字段 exports是main的现代替代方案，它不仅仅有着和main一样的功能，它还具有以下新特性: 可以定义多个入口，不同环境的入口解析支持。 🌟 可以防止除exports字段指定的入口点外的其他入口点被引用。（安全） 支持条件导出（分别指定ES环境和commonjs环境所引用的文件） 需要注意的是，exports字段并不支持所有的Node版本，只支持Nodejs 10以上版本的package，当有exports和main共存的package中，exports的优先级会大于main（exports支持的前提下）。 除此之外，上述的exports的第二个新特性非常值得关注，这可能是一个突破性的变化，消费者只能使用exports定义的文件入口，下面将展示一个例子。 我选择使用got库来作为第二个特性的展示demo，got库的文件结构如下所示。 # got filetree . ├── dist │ └── source │ ├── as-promise │ │ ├── index.d.ts │ │ ├── index.js │ │ ├── types.d.ts │ │ └── types.js │ ├── core │ │ ├── calculate-retry-delay.d.ts │ │ ├── ....(还有很多文件) │ │ └── utils │ │ ├── get-body-size.d.ts │ │ ├── ....(还有很多文件) │ ├── create.js │ ├── index.d.ts │ ├── index.js │ ├── types.d.ts │ └── types.js ├── license ├── package.json └── readme.md package.json的exports字段如下所示。 { // 一个语法糖写法 \u0026#34;exports\u0026#34;: \u0026#34;./dist/source/index.js\u0026#34;, // 等同于下面写法 \u0026#34;exports\u0026#34;: { \u0026#34;.\u0026#34;: \u0026#34;./dist/source/index.js\u0026#34; } } 这意味着外部引用got包时，会直接引用包中的/dist/source/index.js文件。 如果此时在外界引用got中的其他包，node运行时会出现报错，如下所示。 // 外部包 import got from \u0026#39;got\u0026#39;; import create from \u0026#39;got/dist/source/create.js\u0026#39; 运行报错如下所示。 Error [ERR_PACKAGE_PATH_NOT_EXPORTED]: Package subpath \u0026#39;./dist/source/create.js\u0026#39; is not defined by \u0026#34;exports\u0026#34; in /User/xxxxx .... 可以看到，node会报[ERR_PACKAGE_PATH_NOT_EXPORTED]的错误，这正对应了之前所说的exports的第二个新特性，不允许引用除了exports指定文件的其他文件。 此时给got库中exports字段增加一个create.js的引用，那么我们在外界也能直接引用create.js。 { \u0026#34;exports\u0026#34;: { \u0026#34;.\u0026#34;: \u0026#34;./dist/source/index.js\u0026#34;, \u0026#34;./create.js\u0026#34;: \u0026#34;./dist/source/create.js\u0026#34; } } 然后在外部进行引用。 import got from \u0026#39;got\u0026#39;; import create from \u0026#39;got/create.js\u0026#39; 此时执行文件，便能成功执行。 exports中为不同模块设置不同入口 从刚才的demo可以看到，exports能定义多个入口，自然便可以利用这一点，为不同的模块语法定义不同的入口文件，这样能够大大提高包的兼容性。 如果包想要为require() - commonjs和import() - ESmodule提供不同的模块导出，则可以写成如下的形式。 { \u0026#34;exports\u0026#34;: { \u0026#34;import\u0026#34;: \u0026#34;./dist/index.mjs\u0026#34;, \u0026#34;require\u0026#34;: \u0026#34;./dist/index.cjs\u0026#34; } } 如此设置后，外部使用不同语法引用该包时，会根据语法的不同来引用不同的文件。 以上便是在平时开发中接触的关于node-package比较多的知识点了，这一块儿知识很重要，它不仅解决了我之前关于ESModule和Commonjs在node中的执行理解混淆，还进一步解决了我在打包时对于packagejson配置的疑惑，关于更多的node-package知识点请移步node官方文档。\n","permalink":"https://runtus.top/posts/node-packages/","summary":"之前一直被nodejs的模块执行规则所困扰，这种困扰来自于目前Commonjs和ESModule在Node端能够并存的情况，什么时候能够执行ESModule，什么时候不能执行；在引用第三方包node_modules，具体的包是根据什么来区分是ESModule还是Commonjs。\n通过阅读了Nodejs的原文档，这些问题也随之迎刃而解，所以特此在本篇做一做记录。\n注：以下内容都是基于Nodejs V20.5.0 进行编写。\nNodejs中的模块系统 在Node环境下，如今共存着两种模块规范：ESModule和Commonjs，前者是ES6中提出模块化规范，所以为了统一整个Javascript的模块化规范，Nodejs也逐渐的由之前主流的Commonjs规范转变为ESModule，只不过为了兼容Nodejs老版本的代码，所以现在这两种模块在Node中是并存的关系，但是前者(ESModule)是趋势。 关于Commonjs和ESMoudle的模块技术细节，例如语法区别，加载规则等在本篇不会提到，接下来将会它们在nodejs中的设置以及引用规则。 模块的执行与加载 Node在执行代码前会先去判断代码是ES模块还是commonjs模块，Node会从三个角度依次判断代码的模块归属。 ES模块 对于ES模块，当出现以下情况时，Nodejs会将文件视为ES模块。 扩展名为.mjs的文件。 项目所归属的package.json的type字段的值为module，此时文件扩展名为.js的文件都视为ES模块。 字符串作为参数传入 --eval，或通过 STDIN 管道传输到 node，带有标志 --input-type=module。 .mjs扩展名的文件被视为ES模块的优先级是最高的，无论它身处何方，只要Node发现其是.mjs的文件，就会将其视作ES模块来执行。 commonjs模块 对于commonjs模块，当出现以下情况时，Nodejs会将文件视为commonjs模块。 扩展名为.cjs的文件。 项目所属的package.json的type字段的值为commonjs时，此时文件扩展名为.js的文件都视为commonjs模块。 字符串作为参数传入 --eval 或 --print，或通过 STDIN 管道传输到 node，带有标志 --input-type=commonjs。 和ES模块类似，如果文件扩展名为.cjs，那么Nodejs都会将其视作commonjs模块。 如果不设置type字段，那么该项目将会默认为commonjs语法的项目。 模块加载器 Nodejs有两种加载器用于分别解析说明符和加载ES模块和commonjs模块。\ncommonjs模块加载器:\n🌟 处理require()调用，并且是同步加载模块的， 🌟 支持以文件夹作为模块。 🌟 不能用于加载`ECMAScript模块（ESModule）。 🌟 解析路径时，如果未找到完全匹配项，那么将尝试添加扩展名**.js,.json,.node，然后最后再尝试解析文件夹作为模块**。 将.json文件视为JSON文本文件，可以直接使用require加载。 特别注意上述的四个带🌟的规则，在平时日常开发中应该是能够经常遇见的。从第4点也能知道为什么使用require引用包时，可以不带文件的扩展名，因为node在解析路径时会自动添加。 ECMAScript模块加载器:\n🌟 处理import()和import表达式，并且是异步加载模块的。 🌟 只接收Javascript文本文件的.js,.mjs和.cjs扩展名。 🌟 可以加载JSON模块，但需要导入断言。 🌟 不支持文件夹作为模块，必须完全指定目录索引。(例如./dir/index.js)。 🌟 可以加载Javascript Commonjs模块，导入的cjs模块会通过cjs-module-lexer来尝试识别命名的导出，同时导入的CommonJS模块会将其URL转化为绝对路径，然后通过CommonJS模块加载器加载。 需要注意的是第五点：ESModule可以加载CommonJS模块的文件，这和Commonjs语法是不同的。 以.mjs结尾的文件总是加载为ESModule，不会管最近的package.json。\n以.cjs结尾的文件总是加载为commonjs，不会管最近的package.json。\n包入口点 package.json中定义了该node项目的包信息，那么如果该package想被另一个package所引用，正如我们开发时引用第三方包那样import xxx from \u0026quot;xxx\u0026quot;，那么需要在package中定义包的入口点，及入口文件。 main字段 main字段可以定义包的入口点，它适用于ES模块和CommonJS模块入口点，并且支持所有Nodejs版本。 但是它的缺点也显而易见，只能定义一个入口点，及包的主要入口点。 例如我们package的文件结构如下所示。 ├── package.","title":"Node Packages"},{"content":" 很多的数据结构都具备迭代的性质，但是不同的数据结构的迭代方法有所不同，往往需要知道具体的数据结构来选择对应的迭代方法，例如数组的迭代可以通过索引来进行迭代。\n为了统一迭代接口，使得我们可以不了解具体的数据结构的前提下也能进行迭代，所以有了迭代器这么一个概念，而生成器则是基于迭代器的一种能够控制函数流程的方法，生成器基于迭代器的原理运行，反过来生成器也能够快速构建迭代器。\n迭代器 当需要对某个迭代对象进行迭代处理时，由于迭代之前需要事先知道如何使用数据结构，以及遍历顺序并不是数据结构固有的，所以想寻求某种机制去统一迭代过程，对每一种可迭代类型，都用同一种迭代方法，从而增加开发体验。（即无需事先知道如何迭代去实现迭代操作） 于是基于以上原因，诞生了迭代器概念，意在统一化所有迭代对象的处理方式。 可迭代协议 一个对象是可迭代对象，则需要暴露一个属性作为默认迭代器，并且该属性的key为Symbol.iterator，它的value是一个工厂函数，用于返回一个新迭代器。 js提供了一系列可以对可迭代对象进行操作的原生结构，如下图所示。 for-of 数组解构 扩展操作符号（即...) Array.from 创建集合 创建映射 Promise.all()接受由Promise组成的可迭代对象。 Promise.rice()接受由期约组成的可迭代对象。 yield*操作符，在生成器中使用。 上述谈到的原生结构在对可迭代对象进行操作时，会默认调用工厂函数生成一个迭代器，然后对迭代器进行操作。 迭代器协议 1. next和IteratorResult 可迭代协议描述了一个对象具有可迭代性质的要求和前提，而迭代器协议则是用于规范迭代器具有的性质和方法。 迭代器对象具有一个方法next，通过迭代器APInext()能够在可迭代对象中遍历数据，每次调用next都能获取到一个IteratorResult对象，其中包含迭代器返回的下一个值，如下所示。 const array = [1, 2, 4]; // 迭代器对象 const iter = array[Symbol.iterator](); console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) // output // { value: 1, done: false } // { value: 2, done: false } // { value: 4, done: false } // { value: undefined, done: true } // { value: undefined, done: true } 如上的输出结果所示，IteratorResult包含两个属性value和done，value表示本次迭代获取的值，而done则表示迭代是否结束，这从另一个角度也说明迭代器只能通过next方法来获取迭代器的当前位置。 2. 迭代器的一次性和相互独立性 同时需要注意的是，每个迭代器对象是一次性的，并且每个迭代器对象之间没有联系，一次性体现为调用`next()方法是单向不可逆的，即遍历过的元素是不能再次遍历的。而每个通过工厂函数生成的迭代器是彼此独立的，在遍历时不会互相干扰。 const array = [1, 2, 4]; // 迭代器对象 const iter1 = array[Symbol.iterator](); const iter2 = array[Symbol.iterator](); console.log(iter1.next()) console.log(iter2.next()) console.log(iter1.next()) console.log(iter2.next()) // output iter1和iter2遍历不会互相干扰，是彼此独立的 // { value: 1, done: false } // { value: 1, done: false } // { value: 2, done: false } // { value: 2, done: false } 3. 迭代器对象是引用 迭代器是通过直接引用原可迭代对象来获取其中的值，这意味着在迭代器迭代过陈宝国周哥你，当原迭代对象更改内部的值时，迭代器迭代的值也会改变，如下所示。 const array = [1, 2, 4]; // 迭代器对象 const iter = array[Symbol.iterator](); console.log(iter.next()) array[1] = 5 console.log(iter.next()) console.log(iter.next()) array.push(6) console.log(iter.next()) array.push(7) console.log(iter.next()) // output // { value: 1, done: false } // { value: 5, done: false } // { value: 4, done: false } // { value: 6, done: false } // { value: 7, done: false } 上述结果可以看到，无论更改了array内部的值，还是array新增的值，迭代器都能获取到迭代对象最新的内部值。 在上述的例子中，都是通过next()方法来手动控制迭代器的位置，而在实际开发中对可迭代对象处理的常见方式是通过上述的js提供的原生结构来对可迭代对象进行处理，通过原生结构来处理可迭代对象时，本质就是不停调用next方法来获取每一个迭代值，只到迭代结束，例如下所示。 const array = [1, 2, 4]; for (let o of array) { console.log(o) } // 等效于以下代码 const iter = array[Symbol.iterator](); for (let o of iter) { console.log(o) } /* 输出 1 2 4 1 2 4 */ 通过上述代码也可以知道，迭代器本身也是可迭代的，并且具有自引用性。 const iter = array[Symbol.iterator](); iter === iter[Symbol.iterator](); // true 自定义迭代器 除了上述的默认迭代器，也可以自定义迭代器，通过覆盖[Symbol.iterator]的工厂函数来进行迭代器自定义。 class Counter { constructor(limit) { this.limit = limit; } // 自定义迭代器 [Symbol.iterator]() { let count = 1, limit = this.limit; return { next() { if (count \u0026lt;= limit) { return { done: false, value: count++ }; } else { return { done: true, value: undefined }; } }, }; } } let counter = new Counter(3); for (let i of counter) { console.log(i); } // 1 // 2 // 3 for (let i of counter) { console.log(i); } // 1 // 2 // 3 上述的Counter类实现了自定义迭代器方法后，它便是一个可迭代对象，能够使用for ... of ...等一系列处理迭代的原生对象。 提前终止迭代器 除了next函数，迭代器还包括一个可选的return函数，它会在迭代中止时执行，而迭代中止可能的情况如下： for-of的break，continue，return，throw提前退出。 解构操作并未消费所有值。 所以如果需要hook到迭代中止的情景，那可以自定义return方法。 class Counter { constructor(limit) { this.limit = limit; } [Symbol.iterator]() { let count = 1, limit = this.limit; return { next() { if (count \u0026lt;= limit) { return { done: false, value: count++ }; } else { return { done: true }; } }, return() { // 在这里面操作 console.log(\u0026#39;Exiting early\u0026#39;); return { done: true }; } }; } } 接上，如果某次中止后，迭代器并没有关闭，则还可以接续从上次离开的地方继续迭代，比如数组的迭代器就是不可关闭的。 let a = [1, 2, 3, 4, 5]; let iter = a[Symbol.iterator](); for (let i of iter) { console.log(i); // 在i = 3时会终止迭代器，并且自动调用return方法。 if (i \u0026gt; 2) { break } } // 1 // 2 // 3 for (let i of iter) { console.log(i); } // 4 // 5 生成器 生成器是一个非常灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。它的形式是一个函数，函数名称前面加一个*号就表示它是一个生成器函数。 function *generartorFn() {} // 注： 箭头函数不支持生成器声明 需要注意的是，直接调用生成器函数生成的是一个生成器对象，并且不会直接开始执行函数内部的代码。生成器对象本身就具有迭代器的性质，它实现Iterator接口，是可迭代的对象，也具有next方法，next方法就是控制生成器执行的方法。 function* generator(){ yield 1; yield 2; yield 3; return 4; } const genObj = generator(); console.log(genObj.next()) console.log(genObj.next()) console.log(genObj.next()) console.log(genObj.next()) // { value: 1, done: false } // { value: 2, done: false } // { value: 3, done: false } // { value: 4, done: true } // or for (let o of genObj){ // genObj是可迭代对象，所以可以使用for-of循环 console.log(o) } // 1 // 2 // 3 可以看到上述代码出现了yield关键字，它就是生成器函数中的暂停节点（中断执行），调用一次next方法后，代码会运行到下一个yield之处。 同时yield还提供了输入输出功能，比如上述代码中，yield后的值就是本次调用next方法的返回值，若向本次的next方法中传入值，yield将作为临时变量存储对应的值。 function* generator(){ console.log(yield) console.log(yield) console.log(yield) } const genObj = generator(); genObj.next(1) genObj.next(2) genObj.next(3) genObj.next(4) // 2 // 3 // 4 可以看到，1没有打印出来，是因为第一次调用next只是启动函数，并没有实际运行到console.log处。 ","permalink":"https://runtus.top/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8and%E7%94%9F%E6%88%90%E5%99%A8/","summary":"很多的数据结构都具备迭代的性质，但是不同的数据结构的迭代方法有所不同，往往需要知道具体的数据结构来选择对应的迭代方法，例如数组的迭代可以通过索引来进行迭代。\n为了统一迭代接口，使得我们可以不了解具体的数据结构的前提下也能进行迭代，所以有了迭代器这么一个概念，而生成器则是基于迭代器的一种能够控制函数流程的方法，生成器基于迭代器的原理运行，反过来生成器也能够快速构建迭代器。\n迭代器 当需要对某个迭代对象进行迭代处理时，由于迭代之前需要事先知道如何使用数据结构，以及遍历顺序并不是数据结构固有的，所以想寻求某种机制去统一迭代过程，对每一种可迭代类型，都用同一种迭代方法，从而增加开发体验。（即无需事先知道如何迭代去实现迭代操作） 于是基于以上原因，诞生了迭代器概念，意在统一化所有迭代对象的处理方式。 可迭代协议 一个对象是可迭代对象，则需要暴露一个属性作为默认迭代器，并且该属性的key为Symbol.iterator，它的value是一个工厂函数，用于返回一个新迭代器。 js提供了一系列可以对可迭代对象进行操作的原生结构，如下图所示。 for-of 数组解构 扩展操作符号（即...) Array.from 创建集合 创建映射 Promise.all()接受由Promise组成的可迭代对象。 Promise.rice()接受由期约组成的可迭代对象。 yield*操作符，在生成器中使用。 上述谈到的原生结构在对可迭代对象进行操作时，会默认调用工厂函数生成一个迭代器，然后对迭代器进行操作。 迭代器协议 1. next和IteratorResult 可迭代协议描述了一个对象具有可迭代性质的要求和前提，而迭代器协议则是用于规范迭代器具有的性质和方法。 迭代器对象具有一个方法next，通过迭代器APInext()能够在可迭代对象中遍历数据，每次调用next都能获取到一个IteratorResult对象，其中包含迭代器返回的下一个值，如下所示。 const array = [1, 2, 4]; // 迭代器对象 const iter = array[Symbol.iterator](); console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) // output // { value: 1, done: false } // { value: 2, done: false } // { value: 4, done: false } // { value: undefined, done: true } // { value: undefined, done: true } 如上的输出结果所示，IteratorResult包含两个属性value和done，value表示本次迭代获取的值，而done则表示迭代是否结束，这从另一个角度也说明迭代器只能通过next方法来获取迭代器的当前位置。 2.","title":"迭代器and生成器"},{"content":"Web-Components Web-Components是一项标准，规范，目前它包含了三项主要技术：\nCustom Elements自定义元素：（标签）它是一组JavaScript API，能够自定义Element以及其行为。 Shadow DOM影子DOM。 HTML templatesHTML模板：通过\u0026lt;template\u0026gt;和\u0026lt;slot\u0026gt;元素编写不在呈现页面中显示的标记模板。 通过这三个特性的共同作用能够创建封装功能的定制元素，在说明Web-Component的用法之前，先简单说明上述三项特性。\nCustom Elements 自定义元素是Web Components中的一个重要特性，它能够让开发者将HTML页面（或者页面中的某个功能）封装为custom elements，从而达到复用的目的。目前支持custom elements的浏览器有FireFox，Chrome，Opera。\nCustom Elements的管理是通过CustomElementRegistry接口进行操作的，其用于处理Web文档中的custom elements，同时它还提供注册自定义元素和查询已注册元素的方法，它的实例通过window.customElements属性来获得。\nCustomElementRegistry接口有四个方法：\nCustomElementRegistry.define()：定义一个新的自定义元素。 CustomElementRegistry.get()：返回指定自定义元素的构造函数，如果未自定义元素，则返回undefined。 CustomElementRegistry.upgrade(): 更新一个自定义元素。 CustomElementRegistry.whenDefined()：执行并返回一个已经定义的自定义元素的promise，即如果定义了这么一个元素，那么返回对应的promise。 CustomElementRegistry.define() 该方法是四个方法中最重要的方法，用于创建自定义元素，它接受三个参数： 自定义元素的名称，且其必须符合元素名称的DOMString标准字符串。 用于定义元素行为的类。 一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。 // 自定义Div class SelfDiv extends HTMLElement { constructor(){ // super方法的调用是必须得 super() // 元素的相关业务代码 } } // 使用customElements实例(CustomElementRegistry接口)来完成注册功能 customElements.define(\u0026#34;word-count\u0026#34;, SelfDiv, { extends: \u0026#34;div\u0026#34; }); 上述代码便是自定义元素注册的简单演示。 shadow DOM shadown DOM也叫影子DOM，它最主要的功能是做封装，将元素的标记结构，样式以及行为隐藏起来，与外界隔离，这样能够保证封装的代码既不会被外界影响，同时也能保证内部的代码不会影响到外部的元素，这样便实现了Web Component的解耦合。 Shadow DOM接口可以将一个隐藏的，独立的DOM附加到一个元素上，目前为止FireFox,Chrome,Opera,Safari默认支持Shadow DOM，Chromium内核的Edge也支持。 Shadow DOM允许将隐藏的DOM树附加到常规的DOM树中 =\u0026gt; 以shadow root节点为起始根节点（Shadow Root的创建后续会说明），在这根节点的下方可以添加任何DOM元素，和普通的DOM元素没有任何区别。 下面有个示意图可以帮助理解。 上图的一些概念下面做一些解释： Shadow host：常规的DOM节点，Shadow DOM将会挂载到此处。 Shadow Tree：Shadow DOM内部的DOM树。 Shadow root: Shadow tree 的根节点。 注：Shadow DOM的操作方式和普通DOM操作方式没有任何区别，包括添加元素，设置属性等等，只不过Shadow DOM内部的任何改变都影响不了外部的DOM元素。 Shadow DOM的创建和挂载通过方法ElementShadow()来实现。 Element.attachShadow() Element.attachShadow()将shadow root附加到指定的元素上，它接受一个ShadowRootInit对象作为参数，其中包含一个mode: 'open' | 'closed'属性。 Element.attachShadow()返回一个ShadowRoot对象，通过ShadowRoot能够操作Shadow DOM中的元素 // open表示可以通过页面内的javascript方法来获取Shadow DOM let shadow = elementRef.attachShadow({ mode: \u0026#34;open\u0026#34; });、 // close表示主动无法从外部通过javascript方法来获取shadow DOM let shadow = elementRef.attachShadow({ mode: \u0026#34;closed\u0026#34; }); // 通过 Element.shadowRoot属性来获取 let myShadowDom = myCustomElem.shadowRoot; // 如果mode = \u0026#39;open\u0026#39;，则返回对应的Shadow DOM // 如果mode = \u0026#39;close\u0026#39;，则返回null 到这里，可以发现Shadow DOM能够隔离环境，而Custom Element能够封装基本的HTML元素和相关业务代码形成具有实际语义的自定义标签，那么便可以将二者结合，结合二者的特性，从而构建具有单独环境的自定义标签，这和我们预想的component已经非常接近了。同时，这也是目前Shadow DOM最实用的用法，代码如下所示。 class SelfDiv extends HTMLElement { constructor(){ super() // 将ShadowRoot挂载到自定义标签上。 let shadow = this.attachShadow({ mode: \u0026#34;open\u0026#34; }); // 基于ShadowDOM进行处理，就像处理常规的DOM一样 shadow.appendChild(tpl.content.cloneNode(true)) } } 上述的例子很简单，在MDN上还有更详细的例子Using Shadow DOM HTML templates and slots 虽然Shadow DOM + Custom Elements已经无限接近于理想中的Components，但它目前还有一些问题：Custom Elements和Shadow DOM都是通过Javascript API来进行控制的，它们并没有直接去创建和定义HTML DOM的内容，从上述的描述中都可以看到，它们只是去获取已有的DOM元素或者是通过Javascript来定义简单的DOM元素。 所以还需要一个方法去定义具有Component性质的DOM元素集合（DOM子树），HTML templates便可以用于解决Web Components中的DOM元素定义。 在\u0026lt;template\u0026gt; \u0026lt;/template\u0026gt;中定义的元素不会渲染到DOM树中，但是可以通过JavaScript来获取它的引用，通过Javascript API的方式来手动控制template的渲染。 // index.html \u0026lt;template id=\u0026#34;my-paragraph\u0026#34;\u0026gt; \u0026lt;p\u0026gt;My paragraph\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; // script.js let template = document.getElementById(\u0026#34;my-paragraph\u0026#34;); let templateContent = template.content; document.body.appendChild(templateContent); Web Component中使用 template 将template和web component做结合能够发挥出很好的效果，大致的步骤如下所示 首先定义一个Web组件，并在js中获取到它的引用。 将组件作为Shadow DOM的内容。 将ShadowRoot挂载到自定义标签上。 \u0026lt;template id=\u0026#34;my-paragraph\u0026#34;\u0026gt; \u0026lt;style\u0026gt; p { color: white; background-color: #666; padding: 5px; } \u0026lt;/style\u0026gt; \u0026lt;p\u0026gt;My paragraph\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 直接引用注册的Custom element即可 --\u0026gt; \u0026lt;my-paragraph\u0026gt;\u0026lt;/my-paragraph\u0026gt; // ShadowRoot 挂载到自定义标签上（注册） customElements.define( \u0026#34;my-paragraph\u0026#34;, class extends HTMLElement { constructor() { super(); // 获取template的引用 let template = document.getElementById(\u0026#34;my-paragraph\u0026#34;); let templateContent = template.content; const shadowRoot = this.attachShadow({ mode: \u0026#34;open\u0026#34; }); // 将template挂载到Shadow DOM下 shadowRoot.appendChild(templateContent.cloneNode(true)); } }, ); slots slots顾名思义为插槽，它能够为template标签包含的内容预留位置，就像把template中的内容插入到对应的位置一样，所以叫作slots。 slots有属性name标识，并且允许在template标记占位符，这样使用template时，其中的内容便能准确无误地插入到对应地位置上。 \u0026lt;template id=\u0026#34;tpl\u0026#34;\u0026gt; \u0026lt;style\u0026gt; article { width: 20%; margin: 20px auto; border: solid 1px gray; padding: 8px; } header { background: lightblue; color: #fff; font-size: 24px; border: solid 1px lightblue; } .test { color: red; } \u0026lt;/style\u0026gt; \u0026lt;article\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!-- 博客标题插槽 --\u0026gt; \u0026lt;slot name=\u0026#39;title\u0026#39;\u0026gt;博客标题\u0026lt;/slot\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section\u0026gt; \u0026lt;!-- 博客内容插槽 --\u0026gt; \u0026lt;slot name=\u0026#39;cont\u0026#39;\u0026gt;博客内容博客内容博客内容博客内容博客内容博客内容...\u0026lt;/slot\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;my-blog\u0026gt; \u0026lt;span slot=\u0026#39;title\u0026#39;\u0026gt;第一篇博文\u0026lt;/span\u0026gt; \u0026lt;p slot=\u0026#39;cont\u0026#39;\u0026gt;这是第一篇博文内容这是第一篇博文内容这是第一篇博文内容这是第一篇博文内容.\u0026lt;/p\u0026gt; \u0026lt;/my-blog\u0026gt; \u0026lt;my-blog\u0026gt; \u0026lt;span slot=\u0026#39;title\u0026#39;\u0026gt;第二篇博文\u0026lt;/span\u0026gt; \u0026lt;p slot=\u0026#39;cont\u0026#39;\u0026gt;这是第二篇博文内容...\u0026lt;/p\u0026gt; \u0026lt;/my-blog\u0026gt; \u0026lt;my-blog\u0026gt; \u0026lt;p\u0026gt;sdfe\u0026lt;/p\u0026gt; \u0026lt;/my-blog\u0026gt; 最后效果如下图所示。 可以看到，通过slot指定插槽的名称，其中的内容能够准确无误地渲染到template定义的位置上，如果template中没有对应的内容，那么插槽将会渲染template定义的默认值（如上述的非具名slot内容）。 以上便是Web Component相关的基础知识和基础用法，但是它的强大远不于此，Web Component还有一系列的生命周期Hooks，这些内容将会在后续的博客中讨论。\n","permalink":"https://runtus.top/posts/webcomponents/","summary":"Web-Components Web-Components是一项标准，规范，目前它包含了三项主要技术：\nCustom Elements自定义元素：（标签）它是一组JavaScript API，能够自定义Element以及其行为。 Shadow DOM影子DOM。 HTML templatesHTML模板：通过\u0026lt;template\u0026gt;和\u0026lt;slot\u0026gt;元素编写不在呈现页面中显示的标记模板。 通过这三个特性的共同作用能够创建封装功能的定制元素，在说明Web-Component的用法之前，先简单说明上述三项特性。\nCustom Elements 自定义元素是Web Components中的一个重要特性，它能够让开发者将HTML页面（或者页面中的某个功能）封装为custom elements，从而达到复用的目的。目前支持custom elements的浏览器有FireFox，Chrome，Opera。\nCustom Elements的管理是通过CustomElementRegistry接口进行操作的，其用于处理Web文档中的custom elements，同时它还提供注册自定义元素和查询已注册元素的方法，它的实例通过window.customElements属性来获得。\nCustomElementRegistry接口有四个方法：\nCustomElementRegistry.define()：定义一个新的自定义元素。 CustomElementRegistry.get()：返回指定自定义元素的构造函数，如果未自定义元素，则返回undefined。 CustomElementRegistry.upgrade(): 更新一个自定义元素。 CustomElementRegistry.whenDefined()：执行并返回一个已经定义的自定义元素的promise，即如果定义了这么一个元素，那么返回对应的promise。 CustomElementRegistry.define() 该方法是四个方法中最重要的方法，用于创建自定义元素，它接受三个参数： 自定义元素的名称，且其必须符合元素名称的DOMString标准字符串。 用于定义元素行为的类。 一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。 // 自定义Div class SelfDiv extends HTMLElement { constructor(){ // super方法的调用是必须得 super() // 元素的相关业务代码 } } // 使用customElements实例(CustomElementRegistry接口)来完成注册功能 customElements.define(\u0026#34;word-count\u0026#34;, SelfDiv, { extends: \u0026#34;div\u0026#34; }); 上述代码便是自定义元素注册的简单演示。 shadow DOM shadown DOM也叫影子DOM，它最主要的功能是做封装，将元素的标记结构，样式以及行为隐藏起来，与外界隔离，这样能够保证封装的代码既不会被外界影响，同时也能保证内部的代码不会影响到外部的元素，这样便实现了Web Component的解耦合。 Shadow DOM接口可以将一个隐藏的，独立的DOM附加到一个元素上，目前为止FireFox,Chrome,Opera,Safari默认支持Shadow DOM，Chromium内核的Edge也支持。 Shadow DOM允许将隐藏的DOM树附加到常规的DOM树中 =\u0026gt; 以shadow root节点为起始根节点（Shadow Root的创建后续会说明），在这根节点的下方可以添加任何DOM元素，和普通的DOM元素没有任何区别。 下面有个示意图可以帮助理解。 上图的一些概念下面做一些解释： Shadow host：常规的DOM节点，Shadow DOM将会挂载到此处。 Shadow Tree：Shadow DOM内部的DOM树。 Shadow root: Shadow tree 的根节点。 注：Shadow DOM的操作方式和普通DOM操作方式没有任何区别，包括添加元素，设置属性等等，只不过Shadow DOM内部的任何改变都影响不了外部的DOM元素。 Shadow DOM的创建和挂载通过方法ElementShadow()来实现。 Element.","title":"Web components"},{"content":" Rust中的特征Trait类似于其他语言中的接口，它定义了一组可以被共享的行为，只要实现了特征，就能使用这组行为。\n特征 Trait 特征的定义 通过trait关键字对特征进行定义。 pub trait Student { fn GoClass(\u0026amp;self); fn LeaveClass(\u0026amp;self); fn getClassRoom(\u0026amp;self) -\u0026gt; String; } 上述声明了**身为学生应该有的几个特征行为：**即上课，下课和获取教室房间号，那么其他具有学生性质的结构体（或者说为类）需要遵循该特征。 需要注意：特征只是坐函数签名，并不是真正的实现函数，函数的实现在绑定了该特征的类里实现，下面一节会提到。 类型实现特征 使用for关键字来为类实现特征。 pub struct Bob { pub year: String, pub sex: String } impl Student for Bob { // 实现特征 fn GoClass(\u0026amp;self){ // .... } fn LeaveClass(\u0026amp;self) { // ... } fn getClassRoom(\u0026amp;self) { // ... } } 在Bob类型中实现了Student特征声明的三个函数，这是必须的，除非在特征中有默认的实现。 如果特征中有默认的函数实现，那么绑定的类型可以不用再次实现函数，若实现了对应的函数，那么会覆盖默认的特征函数实现。如下所示。 pub trait Student { fn GoClass(\u0026amp;self){ println!(\u0026#34;this is student!\u0026#34;); } fn LeaveClass(\u0026amp;self); fn getClassRoom(\u0026amp;self) -\u0026gt; String; } impl Student for Bob { fn GoClass(\u0026amp;self){ println!(\u0026#34;this is Bob!\u0026#34;); } fn LeaveClass(\u0026amp;self) { // ... } fn getClassRoom(\u0026amp;self) { // ... } } 调用Bob.GoClass时，会打印this is Bob!而不是this is student!，因为Bob类型中已经覆盖了GoClass之前的函数定义。 使用特征来作为函数参数 用特征来作为函数参数是非常重要的一点，相对类型的参数限制，特征的参数限制则显得更加细粒度，只要让传递的参数满足对应的特征即可，而不需要把所有类型都列举出来。 pub fn enterClassRoom(people: \u0026amp;impl Student) { // TODO } 上述代码中展示了使用如何使用特征作为函数的参数，impl Student便是实现语法，它本身是语法糖，正式的书写方式如下所示。 pub fn enterClassRoom\u0026lt;T: Student\u0026gt;(people: \u0026amp;T) { } 其实不难理解，把特征作为函数参数，其实就是用特征来约束范型，这也叫做特征约束。 多重特征约束 上述展示的代码是单个特征约束，除了单特征约束，还可以实现多特征约束，例如上述例子中，除了使参数满足Student约束外，还可以使其实现Monitor约束，如下所示。 // 语法糖 pub fn enterAdminRoom(people: \u0026amp;(impl Student + Monitor)){ } // 特征约束式 pub fn enterAdminRoom\u0026lt;T: Student + Monitor\u0026gt;(prople: \u0026amp;T){ } where关键字 当特征比较多时，用上述的表达方式会显得代码冗杂不易读，此时便可以使用where关键字来实现形式上的改进，如下所示。 pub fn someFunction\u0026lt;T, U\u0026gt;(t: \u0026amp;T, u: \u0026amp;U) -\u0026gt; i32 where T: Display + Clone, U: Clone + Debug { } 上述代码使得参数t必须满足Display和Clone特征，参数U必须满足Clone和Debug特征。 使用特征限制返回值 特征除了能够限制参数外，还可以限制返回值，其关键字用法也是impl Trait，和特征传参的语法糖形式相同。 fn returns_summarizable() -\u0026gt; impl Summary { Weibo { username: String::from(\u0026#34;sunface\u0026#34;), content: String::from( \u0026#34;m1 max太厉害了，电脑再也不会卡\u0026#34;, ) } } 实现了Summary特征的类型才能返回，这样做的好处是：如果返回的真实类型非常复杂时，我们需要把所有类型都要进行声明，这样也会增加代码复杂度，那么便可以使用impl Trait的方式要求返回值，只要让待返回数据的类型满足指定的特征就能返回。 例如使用impl Iterator来告诉调用者，该函数将会返回一个迭代器。 但是这种形式的返回有个限制：只能返回一个具体的类型。假如函数内部可能会返回两个及以上的类型，那么编译器会报错，如下所示。 fn returns_summarizable(switch: bool) -\u0026gt; impl Summary { if switch { Post { title: String::from( \u0026#34;Penguins win the Stanley Cup Championship!\u0026#34;, ), author: String::from(\u0026#34;Iceburgh\u0026#34;), content: String::from( \u0026#34;The Pittsburgh Penguins once again are the best \\ hockey team in the NHL.\u0026#34;, ), } } else { Weibo { username: String::from(\u0026#34;horse_ebooks\u0026#34;), content: String::from( \u0026#34;of course, as you probably already know, people\u0026#34;, ), } } } 上述代码中，可能返回Post类型，也可能返回Weibo类型，虽然它们都有Summary特征，但是编译依然会报错，如果要实现返回不同类型，则需要特征对象来实现，关于特征对象将会在下一章中介绍。 derive派生特征 在开发过程中，经常会遇到#[derive(xxxx)]类似的标注，其被称为特征派生语法，被 derive 标记的对象会自动实现对应的默认特征代码，继承相应的功能。 #[derive(Debug)] struct Point{ x: i32, y: i32 } fn main() { let p = Point{x:3,y:3}; println!(\u0026#34;{:?}\u0026#34;,p); } 上述代码中，为Point类型派生了Debug特征，使得其类型具有了格式化输出的功能，即能够直接通过println!来打印类型。 ","permalink":"https://runtus.top/posts/rust-trait/","summary":"Rust中的特征Trait类似于其他语言中的接口，它定义了一组可以被共享的行为，只要实现了特征，就能使用这组行为。\n特征 Trait 特征的定义 通过trait关键字对特征进行定义。 pub trait Student { fn GoClass(\u0026amp;self); fn LeaveClass(\u0026amp;self); fn getClassRoom(\u0026amp;self) -\u0026gt; String; } 上述声明了**身为学生应该有的几个特征行为：**即上课，下课和获取教室房间号，那么其他具有学生性质的结构体（或者说为类）需要遵循该特征。 需要注意：特征只是坐函数签名，并不是真正的实现函数，函数的实现在绑定了该特征的类里实现，下面一节会提到。 类型实现特征 使用for关键字来为类实现特征。 pub struct Bob { pub year: String, pub sex: String } impl Student for Bob { // 实现特征 fn GoClass(\u0026amp;self){ // .... } fn LeaveClass(\u0026amp;self) { // ... } fn getClassRoom(\u0026amp;self) { // ... } } 在Bob类型中实现了Student特征声明的三个函数，这是必须的，除非在特征中有默认的实现。 如果特征中有默认的函数实现，那么绑定的类型可以不用再次实现函数，若实现了对应的函数，那么会覆盖默认的特征函数实现。如下所示。 pub trait Student { fn GoClass(\u0026amp;self){ println!(\u0026#34;this is student!\u0026#34;); } fn LeaveClass(\u0026amp;self); fn getClassRoom(\u0026amp;self) -\u0026gt; String; } impl Student for Bob { fn GoClass(\u0026amp;self){ println!","title":"Rust Trait"},{"content":" 本文参考了Rust语言圣经中有关Rust包的介绍，攥写本章的目的是为了更好的掌握rust中包和模块的关系以及它们的代码组织方式，方便于未来的项目开发。\nRust中代码组织相关概念 在Rust中，代码的组织大致可以分为四个层次： 项目（Package） 工作空间（Workspace） 包（Crate） 模块（Module） Package 项目 Package其实就是通过命令cargo new创建的项目文件，其显著特征便是包含了cargo.toml文件，该文件标注了该Package的一些基本信息：例如名称，版本号，依赖等等。 一个Package由一个或多个包（Crate）组成，但是它最多只能包含一个库类型的包（即名为lib.rs的文件）。 Package还可以分为二进制Package和库Package。 二进制Package 直接使用命令cargo new package-name的Package-项目即为二进制项目，虽然在cargo.toml中没有显示指出Package的入口文件，但Cargo的惯例是：src/main.rs即为二进制包的根文件，即入口文件，所有的代码的执行都是从src/main.rs中的fn main()中开始执行的。 输入cargo run可以直接编译运行。 库Package 库Package在创建时需要增加--lib命令行参数选项，即cargo new package-lib-name --lib在，这样获得的Package是一个库Package，它只能作为一个第三方库被其他项目引用，而不能单独编译运行。 与 src/main.rs 一样，Cargo 知道，如果一个 Package 包含有 src/lib.rs，意味它包含有一个库类型的同名包 my-lib，该包的根文件是 src/lib.rs。 Package文件结构 需要注意的是，main.rs和lib.rs不是互斥关系，二者是可以共存的。当二者共存时，那就意味着它包含两个包：库包和二进制包，这两个包名也都是 package-name —— 都与 Package 同名。 下面是一个Package的文件结构。 . ├── Cargo.toml ├── Cargo.lock ├── src │ ├── main.rs │ ├── lib.rs │ └── bin │ └── main1.rs │ └── main2.rs ├── tests │ └── some_integration_tests.rs ├── benches │ └── simple_bench.rs └── examples └── simple_example.rs 默认的二进制包：src/main.rs，编译后的包名称和Package名称相同。 其余的二进制包: src/bin/main1.rs和src/bin/main2.rs，编译后是一个自身文件名相同的二进制包。 唯一的库包：src/lib.rs 测试文件: test/some_integration_tests.rs 基准性能测试benchmarks: benches/simple_bench.rs 模块Module 一个Package内有一个或者多个包（Crack），而一个包（Crack）里又可以有一个或者多个模块（Module）。 模块Module是用关键字mod实现的，并且模块之中可以直接嵌套模块，示例代码如下所示。 mod front_of_house { mod hosting { fn add_to_waitlist() {} fn seat_at_table() {} } mod serving { fn take_order() {} fn serve_order() {} fn take_payment() {} } } 模块front_of_house中嵌套了子模块hosting和serving。 模块的引用 调用模块内的函数的方式都是通过路径应用的方式来调用的，为何要称其为路径引用的方式，是因为模块的组织结构本身就是一棵树，称之为模块树，而模块树的组织方式和文件的组织方式相同，那么就可以把文件引用的方式来类比模块中函数的引用方式，所以称其为路径引用的方式。 路径应用方式有两种：绝对路径引用和相对路径引用。 绝对路径引用 绝对路径应用以根包开头，即crate。例如下所示： mod front_of_house { mod hosting { fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { // 绝对路径 crate::front_of_house::hosting::add_to_waitlist(); } 需要注意的是：根包的名称是crate，并且每层的调用符号为::。 相对路径 相对路径的起点便是以当前文件所对应的模块位置为起点进行调用，代码如下所示。 mod front_of_house { mod hosting { fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { // 相对路径 front_of_house::hosting::add_to_waitlist(); } 由于调用函数和模块定义在同一个文件中，所以可以直接引用模块名进行调用，如果模块声明定义和函数调用不在一个文件下，需要在该文件中进行声明（类似于Javascript的import语法），具体的例子会在后续的例子中介绍。 模块中的可见性 如果直接将上述路径引用的代码进行编译，会发现编译错误。具体原因便是Rust出于安全考虑，默认情况下所有的类型都是私有化的，包括模块本身，函数，方法，结构体等等。所以说在上述的例子中，除了能引用顶层模块front_of_house（因为它们的作用域在同一层中），其内层的模块以及方法都是无法调用的。 ⚠️这里需要说明一点的是：在Rust中子模块可以完全访问父模块的内容，但是父模块无法访问子模块的任何信息，子模块访问父模块信息通过super关键字进行调用。 所以为了让模块以及其内部的方法能被外界调用，需要关键字pub进行声明，更改后的代码如下所示。 mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { // 相对路径 front_of_house::hosting::add_to_waitlist(); } 这样便能使得编译顺利通过。 super和self关键字 super关键字在上述可见性一章已经谈到，用于子模块引用父模块的关键字。 关键字self则类似于this关键词，用于引用自身模块的项，例如刚才的相对路径例子中的调用，front_of_house::hosting::add_to_waitlist();，其本质是self::hosting::add_to_waitlist()。 模块与文件分离 为了代码合理组织，在大多数情况下最好把多个模块拆到多个文件中，正如刚才所言，多个模块组合在一起其实就形成了一个模块树，而模块树是类似于文件组织的结构，所以便可以参考模块树将模块分离到各个文件中。 现在将模块[Module]章节代码中的模块树画出，如下所示。 crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment 先创建一个文件src/front_of_house.rs，并把front_of_house模块的定义放进去，如下代码所示。 // src/front_of_house.rs pub mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} pub fn seat_at_table() {} } pub mod serving { pub fn take_order() {} pub fn serve_order() {} pub fn take_payment() {} } } 然后在src/lib.rs下进行引用。 // src/lib.rs mod front_of_house; // 声明 pub use crate::front_of_house::hosting; pub fn eat_at_restaurant() { hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist(); } 注意第一行代码mod front_of_house，这就是之前提到的模块声明，它的意思是告诉Rust从另一个和模块front_of_house同名的文件中加载该模块的内容，类似于import的功能。 此时front_of_house依然是个嵌套模块，所以可以考虑继续将嵌套模块拆分。 拆分子模块到文件中 创建一个同名的文件夹，然后在文件夹中创建与子模块同名的文件，如src/front_of_house/hosting.rs。 然后将hosting模块的函数定义放到该文件下，如下所示。 // src/front_of_house/hosting.rs pub fn add_to_waitlist() {} pub fn seat_at_table() {} 其余子模块的创建方式与之类似，这里不再赘述。 但是此时如果直接编译还是会出现错误，因为需要显示指定暴露了哪些子模块，在如今Rust版本下，有两种方法可以选择： 在父模块目录里（本节中指的就是front_of_house文件夹）创建mod.rs，在里面指定要暴露的子模块。(此方法是Rust1.30版本之前的唯一暴露子模块的方法) 与父模块目录同级的目录里（本节中指的就是src文件夹）创建front_of_house.rs，在里面指定要暴露的子模块。 无论是哪种方式，它们其中要填写的内容都是需要暴露的子模块的名称，如下所示。 pub mod hosting; // 暴露hosting子模块 pub mod serving; // 暴露serving子模块 ","permalink":"https://runtus.top/posts/rust%E5%8C%85%E7%AE%A1%E7%90%86/","summary":"本文参考了Rust语言圣经中有关Rust包的介绍，攥写本章的目的是为了更好的掌握rust中包和模块的关系以及它们的代码组织方式，方便于未来的项目开发。\nRust中代码组织相关概念 在Rust中，代码的组织大致可以分为四个层次： 项目（Package） 工作空间（Workspace） 包（Crate） 模块（Module） Package 项目 Package其实就是通过命令cargo new创建的项目文件，其显著特征便是包含了cargo.toml文件，该文件标注了该Package的一些基本信息：例如名称，版本号，依赖等等。 一个Package由一个或多个包（Crate）组成，但是它最多只能包含一个库类型的包（即名为lib.rs的文件）。 Package还可以分为二进制Package和库Package。 二进制Package 直接使用命令cargo new package-name的Package-项目即为二进制项目，虽然在cargo.toml中没有显示指出Package的入口文件，但Cargo的惯例是：src/main.rs即为二进制包的根文件，即入口文件，所有的代码的执行都是从src/main.rs中的fn main()中开始执行的。 输入cargo run可以直接编译运行。 库Package 库Package在创建时需要增加--lib命令行参数选项，即cargo new package-lib-name --lib在，这样获得的Package是一个库Package，它只能作为一个第三方库被其他项目引用，而不能单独编译运行。 与 src/main.rs 一样，Cargo 知道，如果一个 Package 包含有 src/lib.rs，意味它包含有一个库类型的同名包 my-lib，该包的根文件是 src/lib.rs。 Package文件结构 需要注意的是，main.rs和lib.rs不是互斥关系，二者是可以共存的。当二者共存时，那就意味着它包含两个包：库包和二进制包，这两个包名也都是 package-name —— 都与 Package 同名。 下面是一个Package的文件结构。 . ├── Cargo.toml ├── Cargo.lock ├── src │ ├── main.rs │ ├── lib.rs │ └── bin │ └── main1.rs │ └── main2.rs ├── tests │ └── some_integration_tests.rs ├── benches │ └── simple_bench.","title":"Rust包管理"},{"content":"使用rollup打包typscript-node项目为第三方库 tsc和rollup对比 tsc是Typescript官方的编译器，本身也具有打包功能，但是其本质只是编译器，它适合于打包直接运行的大型项目文件，并不适合构建独立的第三方库或组件。 rollup则是javascript打包器，它可以将ES6模块打包称单个javascript文件，同时它本身也采用了Tree Shaking优化算法，能使得打包文件大小得到进一步的优化。 另一方面，rollup支持插件功能，通过设置插件能满足大部分时候的打包需求，在下面即将要讲解的打包中，插件提供了很大的帮助。RollUp插件集合网站 rollup打包流程 本地安装 rollup 就我个人而言，不推荐安装全局的rollup包，因为在协同工作时，这样会导致rollup版本得不到统一而产生打包错误，所以推荐在本地安装rollup，本文使用的包管理工具为yarn，安装命令如下: yarn add rollup 安装完毕后，在package.json文件里设置对应的脚本，用于快速启动打包。 // package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;rollup -c\u0026#34; } } -c的意思是按照配置文件中设置的内容进行打包。 设置rollup.config.js文件 就如同tsconfig.json一样，rollup也是有一个对应的配置文件名为rollup.config.js，虽然其不是必须的，但配置文件强大且方便，所以在配置项目打包时基本都要用到配置文件。 在项目根目录创建对应的配置文件，在文件里根据自己的需求来编写对应的配置代码。 rollup.config.js是一个ES模块，它会根据文件内导出的内容来进行打包上的设置，如下所示。 // rollup.config.js export default { // 这里也可以是一个数组 input: [], output: [], external: [], plugins: [], // .... } 安装插件 需要三个插件： rollup-plugin-typescript2 =\u0026gt; 将typescript转移为javascript的插件 rollup/plugin-commonjs =\u0026gt; 将commonjs语法转换为es6 rollup-plugin-dts =\u0026gt; 生成声明文件d.ts文件 执行以下的命令 yarn add @rollup/plugin-commonjs rollup-plugin-typescript2 typescript tslib rollup-plugin-dts --dev 修改配置文件 关于配置文件的各个变量配置这里不赘述，如有需求，可查阅rollup官网的配置说明。 // rollup.config.js import ts from \u0026#39;rollup-plugin-typescript2\u0026#39; import commonjs from \u0026#39;@rollup/plugin-commonjs\u0026#39; import dts from \u0026#39;rollup-plugin-dts\u0026#39; // 打包结果语法遵循EsNext规范 const override = { compilerOptions: { module: \u0026#39;ESNext\u0026#39; } } export default [{ input: \u0026#39;src/index.ts\u0026#39;, // 打包两种文件，分别适配commonjs语法和esmodule语法 output: [{ file: \u0026#34;dist/index.cjs\u0026#34;, format: \u0026#34;cjs\u0026#34; }, { file: \u0026#39;dist/index.mjs\u0026#39;, format: \u0026#34;esm\u0026#34; } ], plugins: [ // 表明typescript打包遵循该项目的tsconfig.json配置的规则 ts({ tsconfig: \u0026#34;tsconfig.json\u0026#34;, tsconfigOverride: override // 配置复写 }), commonjs() ] }, { input: \u0026#34;src/index.ts\u0026#34;, // 生成类型文件 output: { file: \u0026#34;dist/index.d.ts\u0026#34;, format: \u0026#39;esm\u0026#39; }, external: [], // dts插件使用 plugins: [ dts({}) ] }] 配置package.json npm会根据package.json里的字段信息去决定哪些文件要上传至npm官网，其对应的字段为files，如下所示。 // package.json { \u0026#34;files\u0026#34;: [ \u0026#34;dist\u0026#34;, \u0026#34;*.d.ts\u0026#34; ] } 同时外界在引用第三方包时，import或require语法会根据package.json中字段的信息去获取对应的代码文件和声明文件。它们对应的字段分别为main,module和types { \u0026#34;main\u0026#34;: \u0026#34;dist/index.cjs\u0026#34;, // main是commonjs规范时引用的文件 \u0026#34;module\u0026#34;: \u0026#34;dist/index.mjs\u0026#34;, // module是esmodule规范时引用的文件 \u0026#34;types\u0026#34;: \u0026#34;dist/index.d.ts\u0026#34;, // types指定声明文件的位置 } 需要注意type字段和types字段的区别，前者则是指定当前项目是commonjs规范还是esmoudle规范，其值有module和commonjs(default)\n下面是整个package.json的内容\n{ \u0026#34;name\u0026#34;: \u0026#34;typescript-node-init\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.1\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;test for rollup\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;dist/index.cjs\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;dist/index.mjs\u0026#34;, \u0026#34;types\u0026#34;: \u0026#34;dist/index.d.ts\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;files\u0026#34;: [ \u0026#34;dist\u0026#34;, \u0026#34;*.d.ts\u0026#34; ], \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;rollup -c\u0026#34;, }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;Test\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@rollup/plugin-alias\u0026#34;: \u0026#34;^5.0.0\u0026#34;, \u0026#34;@rollup/plugin-commonjs\u0026#34;: \u0026#34;^24.1.0\u0026#34;, \u0026#34;@rollup/plugin-node-resolve\u0026#34;: \u0026#34;^15.0.2\u0026#34;, \u0026#34;rollup-plugin-dts\u0026#34;: \u0026#34;^5.3.0\u0026#34;, \u0026#34;rollup-plugin-typescript2\u0026#34;: \u0026#34;^0.34.1\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^5.0.4\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;bump\u0026#34;: \u0026#34;^0.2.5\u0026#34;, \u0026#34;rollup\u0026#34;: \u0026#34;^3.21.5\u0026#34;, \u0026#34;typescript-node-init\u0026#34;: \u0026#34;^1.0.1\u0026#34; } } 打包并上传至npm 当上述一切都完成后，便可以进行打包上传操作了，执行以下命令。 yarn build # 打包 npm publish # 上传 上传完毕后，你便可以在其他Ts项目里使用你自己打包上传的第三方库了。 ","permalink":"https://runtus.top/posts/node-typescript%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/","summary":"使用rollup打包typscript-node项目为第三方库 tsc和rollup对比 tsc是Typescript官方的编译器，本身也具有打包功能，但是其本质只是编译器，它适合于打包直接运行的大型项目文件，并不适合构建独立的第三方库或组件。 rollup则是javascript打包器，它可以将ES6模块打包称单个javascript文件，同时它本身也采用了Tree Shaking优化算法，能使得打包文件大小得到进一步的优化。 另一方面，rollup支持插件功能，通过设置插件能满足大部分时候的打包需求，在下面即将要讲解的打包中，插件提供了很大的帮助。RollUp插件集合网站 rollup打包流程 本地安装 rollup 就我个人而言，不推荐安装全局的rollup包，因为在协同工作时，这样会导致rollup版本得不到统一而产生打包错误，所以推荐在本地安装rollup，本文使用的包管理工具为yarn，安装命令如下: yarn add rollup 安装完毕后，在package.json文件里设置对应的脚本，用于快速启动打包。 // package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;rollup -c\u0026#34; } } -c的意思是按照配置文件中设置的内容进行打包。 设置rollup.config.js文件 就如同tsconfig.json一样，rollup也是有一个对应的配置文件名为rollup.config.js，虽然其不是必须的，但配置文件强大且方便，所以在配置项目打包时基本都要用到配置文件。 在项目根目录创建对应的配置文件，在文件里根据自己的需求来编写对应的配置代码。 rollup.config.js是一个ES模块，它会根据文件内导出的内容来进行打包上的设置，如下所示。 // rollup.config.js export default { // 这里也可以是一个数组 input: [], output: [], external: [], plugins: [], // .... } 安装插件 需要三个插件： rollup-plugin-typescript2 =\u0026gt; 将typescript转移为javascript的插件 rollup/plugin-commonjs =\u0026gt; 将commonjs语法转换为es6 rollup-plugin-dts =\u0026gt; 生成声明文件d.ts文件 执行以下的命令 yarn add @rollup/plugin-commonjs rollup-plugin-typescript2 typescript tslib rollup-plugin-dts --dev 修改配置文件 关于配置文件的各个变量配置这里不赘述，如有需求，可查阅rollup官网的配置说明。 // rollup.","title":"Node Typescript打包发布"},{"content":" 关于副作用以及外部引用与函数式编程的关系\nPure Happiness with Pure Functions 禁止与外界交互 在第二章中也有说到，保持纯函数的关键在于不能与外界有直接交互，即直接引用。 这样有个好处是能让函数能够自给自足，从而能够只看函数本身就能更加轻松了解到函数本身的功能，而不需要借助外部变量来理解，例如以下的例子。 let minimum = 21 const checkAge = age =\u0026gt; age =\u0026gt; minium checkage依赖与外部变量minium，假如该变量声明的位置很远，当后续维护时会对这段代码返回的结果感到匪夷所思，不知道其值到底从何而来。 副作用 对于函数而言，函数的副作用就是函数执行时对外界环境产生了影响（无论是依赖还是修改）。 上述的与外界交互也算是副作用的一种，副作用在计算机领域并不是贬义的含义，只是对代码执行过程的一种结果的描述，只不过在函数式编程中，副作用被视为不好的程序过程执行。 下面列举了一些副作用的例子。 更改文件fs 数据库访问 发起http请求 DOM控制 获取系统状态 获取用户的输入 so on\u0026hellip;.. 并不是说在函数式编程中，我们要完全拒绝以上操作，而是要能控制这一系列操作。后续会介绍如何去进行这一个控制过程（柯里化），下面先介绍如何将纯函数从一个普通的函数中分离出来。 纯函数的分离 一个对外界依赖的函数要分离成纯函数，就必须要显式告知函数要依赖的对象是谁，即把要依赖的对象作为参数传递，从而将外部依赖改为内部依赖。 // 不纯函数，其没有显示告知函数依赖的对象是谁。 const signUp = (attrs) =\u0026gt; { const user = saveUser(attrs); welcomeUser(user); }; // pure -\u0026gt; 将DB，Email显示告知 const signUp = (Db, Email, attrs) =\u0026gt; () =\u0026gt; { const user = saveUser(Db, attrs); welcomeUser(Email, user); }; 这样做的好处不仅仅是让函数的依赖关系更加明确从而使得函数可读性增强，而且还让函数的复用性增强，一旦Db或Email有变化，只需要重新设置这两参数，再获取一个SignUp即可。 ","permalink":"https://runtus.top/posts/functional_program_3/","summary":" 关于副作用以及外部引用与函数式编程的关系\nPure Happiness with Pure Functions 禁止与外界交互 在第二章中也有说到，保持纯函数的关键在于不能与外界有直接交互，即直接引用。 这样有个好处是能让函数能够自给自足，从而能够只看函数本身就能更加轻松了解到函数本身的功能，而不需要借助外部变量来理解，例如以下的例子。 let minimum = 21 const checkAge = age =\u0026gt; age =\u0026gt; minium checkage依赖与外部变量minium，假如该变量声明的位置很远，当后续维护时会对这段代码返回的结果感到匪夷所思，不知道其值到底从何而来。 副作用 对于函数而言，函数的副作用就是函数执行时对外界环境产生了影响（无论是依赖还是修改）。 上述的与外界交互也算是副作用的一种，副作用在计算机领域并不是贬义的含义，只是对代码执行过程的一种结果的描述，只不过在函数式编程中，副作用被视为不好的程序过程执行。 下面列举了一些副作用的例子。 更改文件fs 数据库访问 发起http请求 DOM控制 获取系统状态 获取用户的输入 so on\u0026hellip;.. 并不是说在函数式编程中，我们要完全拒绝以上操作，而是要能控制这一系列操作。后续会介绍如何去进行这一个控制过程（柯里化），下面先介绍如何将纯函数从一个普通的函数中分离出来。 纯函数的分离 一个对外界依赖的函数要分离成纯函数，就必须要显式告知函数要依赖的对象是谁，即把要依赖的对象作为参数传递，从而将外部依赖改为内部依赖。 // 不纯函数，其没有显示告知函数依赖的对象是谁。 const signUp = (attrs) =\u0026gt; { const user = saveUser(attrs); welcomeUser(user); }; // pure -\u0026gt; 将DB，Email显示告知 const signUp = (Db, Email, attrs) =\u0026gt; () =\u0026gt; { const user = saveUser(Db, attrs); welcomeUser(Email, user); }; 这样做的好处不仅仅是让函数的依赖关系更加明确从而使得函数可读性增强，而且还让函数的复用性增强，一旦Db或Email有变化，只需要重新设置这两参数，再获取一个SignUp即可。 ","title":"Functional_Program_3"},{"content":" 读 Professor Frisby\u0026rsquo;s Mostly Adequate Guide to Functional Programming 记录\nFunctional Programming原文链接\n本章主要简单介绍函数式编程中的一等公民，以及函数式编程的一些注意事项和好处。\n第二章: First Class Functions 在函数式编程中，函数是作为一等公民存在的，应该把函数和其他变量等同，即函数也是变量，变量的类型也可以是函数，函数的参数也可以是函数。 const hi = name =\u0026gt; `Hi, ${name}` const greeting = hi hi(\u0026#34;小明\u0026#34;); 常见的回调函数，其实就是把函数当作参数传递。 const callback = (...args) =\u0026gt; { // balabala } ajax(\u0026#34;/xianbei114514/1919810\u0026#34;, callback) 不要做无所谓的函数返回 在写代码时，有时会做无意义的操作，在一个函数中，将另一个函数返回。其实它们的功能都没有变化，只是换了个变量名而已。 // 不好的操作 const getServerStuff = callback =\u0026gt; ajaxCall(json =\u0026gt; callback(json)); 对于上述代码，getServerStuff本质就是想传递一个回调函数，并在回调函数中获取ajax请求得到的值，但完全没必要写那么多，它等同于下面代码实现。 // 好的操作 const getServerStuff = ajaxCall; 此时getServerStuff的功能也是传递一个回调函数并获取到ajax的值，这和上面有区别吗？没有区别。 减少代码冗余，增强代码可读性以及可维护性 继续拿上述的ajaxCall例子来说，假如我们传递的回调函数如下所示。 ajaxCall((json) =\u0026gt; callback(json)) 这只是一个调用，如果说有多处的ajaxCall都要进行如此的回调函数的传递，那么一旦我们的业务发生改变时，就会去修改每一处代码，并且每次都要写一遍回调函数的形式，显得非常冗余。 所以考虑将函数作为变量来传递。 const cb = (json) =\u0026gt; callback(json) ajaxCall(cb) 此时一旦遇到上述情况，直接去修改cb的内容即可，并且代码量也会减少。 禁止this的出现 在函数式编程中，要保证函数是够**“纯”（1，5！）的，即不能让函数内的任何行为影响到函数外，而this指针便是一个例子，this指向的是执行函数的作用域，一旦使用了this，便会导致函数和外界进行交互，从而不纯**。 但在实际生产过程中，有时的业务情况又不得不这样操作，所以不能完全循规蹈矩，而是要懂随机应变，少量的交互并不会影响整体的代码质量。再说一句，若要调用含有this指针的函数，最好先使用bind函数改变this指针指向，这样不仅能让代码更加易读，还能减少一些未来执行时可能遇见的错误。 // 借用网上的例子 // scary fs.readFile(\u0026#39;freaky_friday.txt\u0026#39;, Db.save); // less so fs.readFile(\u0026#39;freaky_friday.txt\u0026#39;, Db.save.bind(Db)); ","permalink":"https://runtus.top/posts/functional_program_2/","summary":"读 Professor Frisby\u0026rsquo;s Mostly Adequate Guide to Functional Programming 记录\nFunctional Programming原文链接\n本章主要简单介绍函数式编程中的一等公民，以及函数式编程的一些注意事项和好处。\n第二章: First Class Functions 在函数式编程中，函数是作为一等公民存在的，应该把函数和其他变量等同，即函数也是变量，变量的类型也可以是函数，函数的参数也可以是函数。 const hi = name =\u0026gt; `Hi, ${name}` const greeting = hi hi(\u0026#34;小明\u0026#34;); 常见的回调函数，其实就是把函数当作参数传递。 const callback = (...args) =\u0026gt; { // balabala } ajax(\u0026#34;/xianbei114514/1919810\u0026#34;, callback) 不要做无所谓的函数返回 在写代码时，有时会做无意义的操作，在一个函数中，将另一个函数返回。其实它们的功能都没有变化，只是换了个变量名而已。 // 不好的操作 const getServerStuff = callback =\u0026gt; ajaxCall(json =\u0026gt; callback(json)); 对于上述代码，getServerStuff本质就是想传递一个回调函数，并在回调函数中获取ajax请求得到的值，但完全没必要写那么多，它等同于下面代码实现。 // 好的操作 const getServerStuff = ajaxCall; 此时getServerStuff的功能也是传递一个回调函数并获取到ajax的值，这和上面有区别吗？没有区别。 减少代码冗余，增强代码可读性以及可维护性 继续拿上述的ajaxCall例子来说，假如我们传递的回调函数如下所示。 ajaxCall((json) =\u0026gt; callback(json)) 这只是一个调用，如果说有多处的ajaxCall都要进行如此的回调函数的传递，那么一旦我们的业务发生改变时，就会去修改每一处代码，并且每次都要写一遍回调函数的形式，显得非常冗余。 所以考虑将函数作为变量来传递。 const cb = (json) =\u0026gt; callback(json) ajaxCall(cb) 此时一旦遇到上述情况，直接去修改cb的内容即可，并且代码量也会减少。 禁止this的出现 在函数式编程中，要保证函数是够**“纯”（1，5！）的，即不能让函数内的任何行为影响到函数外，而this指针便是一个例子，this指向的是执行函数的作用域，一旦使用了this，便会导致函数和外界进行交互，从而不纯**。 但在实际生产过程中，有时的业务情况又不得不这样操作，所以不能完全循规蹈矩，而是要懂随机应变，少量的交互并不会影响整体的代码质量。再说一句，若要调用含有this指针的函数，最好先使用bind函数改变this指针指向，这样不仅能让代码更加易读，还能减少一些未来执行时可能遇见的错误。 // 借用网上的例子 // scary fs.","title":"Functional_Program"},{"content":" 所有权系统和引用在Rust中是至关重要的，它的设计使得rust的GC机制与众不同，也让rust获得了性能上的回报。\n所有权 所有权：一个数值只能被一个变量所拥有，即该变量唯一拥有该数值，若变量离开了其作用域，数值也会被释放掉。 如果将一个变量赋值给另一个变量，则意味着对应的值的所有权会被移交出去，那么原先的变量将不再拥有值的所有权，这也是为什么在rust中，变量的赋值也叫变量的绑定。 // 例子 fn main(){ let s1 = String::from(\u0026#34;Hello\u0026#34;); let s2 = s1; // 所有权移交 -\u0026gt; 即move println!(\u0026#34;{}\u0026#34;, s1); // 报错 } 可以看到，上述例子的s1将所有权移交给s2后，自己便不再拥有对字符串Hello的控制。 从内存的视角观察 还是上述例子，在内存里表示出来，如下图所示。 可以看出，再进行变量绑定时，s2实际上是s1的浅拷贝结果，但唯一不同的是指针的移交操作，即指针不是单纯的拷贝，而是从s1上“移交”给了s2，这也是一个move的过程。\n如果不想让s1的所有权移交出去，则可以调用String的clone方法来实现深拷贝 ，在堆内存上再开辟一个空间，这样两个变量都有对应的值，这样就不会发生变量无法使用的情况了。\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); // 直接重新开辟一个空间，尽量少用，会影响rust性能 println!(\u0026#34;s1 = {}, s2 = {}\u0026#34;, s1, s2); 需要注意的是，这并不能说明存储在堆内存中的数据只能有一个引用（即指针），这里只强调了move这个操作，即所有权的移交过程，而没有说明堆数据只能有一个引用。 Copy类型 之所以提到copy类型是因为它与上述的String类型有所不同，具有Copy属性的数据类型的数据都是直接存储于栈内存中的，即具有copy特征的数据在进行赋值时，旧变量依然可以使用。 fn main(){ let a = 1; let b = a; // 将 a 赋值给 b } 当赋值时，进行了浅拷贝操作，由于简单类型直接在栈上进行浅拷贝，开销小，两个1时存储在不同的栈内存空间里，所以两个变量都有与之对应的数值，所以不会像刚才的String类型一样，发生s1不可使用的情况。\n下面是一些具有Copy属性的类型：\n整数类型 布尔类型 浮点数类型 字符类型 元祖 不可变引用 \u0026amp;T 好处: 避免内存二次释放以及开发上不必要的困扰 Rust垃圾回收比较特殊，它是在每个作用域结束时会调用一次drop函数来清理对内存。拿上述的String的例子来说，两个String变量指向同一个位置，如果没有所有权的限制，那么s1和s2离开作用域时，gc会对同一块堆内存进行二次释放，这样会导致内存的泄漏问题。 所以一旦有了所有权的移交，Rust认为s1已经不再拥有对数据的所有权，所以不会对s1处理任何东西，而只对s2的堆内存进行释放处理。 同时，所有权还能保证开发时产生不必要的困扰，假如有多个变量对同一块内存进行引用，那么当其中一个变量一不小心对内存进行修改时，其产生的副作用就会波及到所有与之相关的变量上，造成令人匪夷所思的结果。显然，有了所有权的限制，我们不会有上述的担忧。 ","permalink":"https://runtus.top/posts/rust-%E5%80%9F%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%A8/","summary":"所有权系统和引用在Rust中是至关重要的，它的设计使得rust的GC机制与众不同，也让rust获得了性能上的回报。\n所有权 所有权：一个数值只能被一个变量所拥有，即该变量唯一拥有该数值，若变量离开了其作用域，数值也会被释放掉。 如果将一个变量赋值给另一个变量，则意味着对应的值的所有权会被移交出去，那么原先的变量将不再拥有值的所有权，这也是为什么在rust中，变量的赋值也叫变量的绑定。 // 例子 fn main(){ let s1 = String::from(\u0026#34;Hello\u0026#34;); let s2 = s1; // 所有权移交 -\u0026gt; 即move println!(\u0026#34;{}\u0026#34;, s1); // 报错 } 可以看到，上述例子的s1将所有权移交给s2后，自己便不再拥有对字符串Hello的控制。 从内存的视角观察 还是上述例子，在内存里表示出来，如下图所示。 可以看出，再进行变量绑定时，s2实际上是s1的浅拷贝结果，但唯一不同的是指针的移交操作，即指针不是单纯的拷贝，而是从s1上“移交”给了s2，这也是一个move的过程。\n如果不想让s1的所有权移交出去，则可以调用String的clone方法来实现深拷贝 ，在堆内存上再开辟一个空间，这样两个变量都有对应的值，这样就不会发生变量无法使用的情况了。\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); // 直接重新开辟一个空间，尽量少用，会影响rust性能 println!(\u0026#34;s1 = {}, s2 = {}\u0026#34;, s1, s2); 需要注意的是，这并不能说明存储在堆内存中的数据只能有一个引用（即指针），这里只强调了move这个操作，即所有权的移交过程，而没有说明堆数据只能有一个引用。 Copy类型 之所以提到copy类型是因为它与上述的String类型有所不同，具有Copy属性的数据类型的数据都是直接存储于栈内存中的，即具有copy特征的数据在进行赋值时，旧变量依然可以使用。 fn main(){ let a = 1; let b = a; // 将 a 赋值给 b } 当赋值时，进行了浅拷贝操作，由于简单类型直接在栈上进行浅拷贝，开销小，两个1时存储在不同的栈内存空间里，所以两个变量都有与之对应的数值，所以不会像刚才的String类型一样，发生s1不可使用的情况。","title":"Rust-所有权"},{"content":" 记录docker的基本概念和用法，系统的再认识一次docker\ndocker是什么 Docker是对Linux容器的一种封装，并提供简单易用的接口，同时它也是目前最流行的Linux容器解决方案。\n在docker出现之前，环境移植一直是非常麻烦的事情，当我们需要把项目从一台机器迁移到另一台机器时，不仅仅是迁移源代码，更重要的是要保证环境的一致性，而一次次环境的搭建则显得冗余且效率极低，所以在思考有没有一种方式能够把环境一起进行迁移。\n虚拟机的出现在一定程度上解决了这个问题，但接踵而至的问题是：\n虚拟机占用资源多，它本质就是一台完整的操作系统， 冗余步骤多，由于是完整的操作系统，一些系统级别的操作步骤不可避免。 启动慢。 所以Linux发展出了另一种虚拟化技术：Linux容器。而docker则是Linux容器的一种解决方案（也是最流行的）\n可以简单的将docker理解为一种非常轻量级的虚拟机。\ndocker镜像（image文件） docker把应用程序及其依赖打包在image文件里，通过image文件，就会生成容器（后续会提到），即镜像文件其实就是容器的模版，而容器则是镜像文件的实例（可以一一对应类与对象） image文件是二进制文件。在实际开发中，我们会在别人写好的image文件上加一些自定义设置从而形成我们需要的image文件，而不是自己从零开发一个image文件（当然，有需求另说）。 # 有关image命令 docker image ls # 列出docker镜像 docker image rm [imageName] # 删除某镜像文件 容器文件 由image生成的容器实例，本身也是一个文件，称为容器文件。同时，当关闭容器时不会删除容器文件，只是让容器停止运行而已。 docker container ls # 本机正在运行的容器 docker container ls --all # 本机所有容器 每个容器都有一个唯一ID，如果需要终结容器的运行，需要使用kill命令docker container kill。 如需要删除容器文件，需要使用rm命令。 docker container rm [containerID] ","permalink":"https://runtus.top/posts/%E5%86%8D%E6%8B%BEdocker/","summary":" 记录docker的基本概念和用法，系统的再认识一次docker\ndocker是什么 Docker是对Linux容器的一种封装，并提供简单易用的接口，同时它也是目前最流行的Linux容器解决方案。\n在docker出现之前，环境移植一直是非常麻烦的事情，当我们需要把项目从一台机器迁移到另一台机器时，不仅仅是迁移源代码，更重要的是要保证环境的一致性，而一次次环境的搭建则显得冗余且效率极低，所以在思考有没有一种方式能够把环境一起进行迁移。\n虚拟机的出现在一定程度上解决了这个问题，但接踵而至的问题是：\n虚拟机占用资源多，它本质就是一台完整的操作系统， 冗余步骤多，由于是完整的操作系统，一些系统级别的操作步骤不可避免。 启动慢。 所以Linux发展出了另一种虚拟化技术：Linux容器。而docker则是Linux容器的一种解决方案（也是最流行的）\n可以简单的将docker理解为一种非常轻量级的虚拟机。\ndocker镜像（image文件） docker把应用程序及其依赖打包在image文件里，通过image文件，就会生成容器（后续会提到），即镜像文件其实就是容器的模版，而容器则是镜像文件的实例（可以一一对应类与对象） image文件是二进制文件。在实际开发中，我们会在别人写好的image文件上加一些自定义设置从而形成我们需要的image文件，而不是自己从零开发一个image文件（当然，有需求另说）。 # 有关image命令 docker image ls # 列出docker镜像 docker image rm [imageName] # 删除某镜像文件 容器文件 由image生成的容器实例，本身也是一个文件，称为容器文件。同时，当关闭容器时不会删除容器文件，只是让容器停止运行而已。 docker container ls # 本机正在运行的容器 docker container ls --all # 本机所有容器 每个容器都有一个唯一ID，如果需要终结容器的运行，需要使用kill命令docker container kill。 如需要删除容器文件，需要使用rm命令。 docker container rm [containerID] ","title":"再拾docker"},{"content":" Golang学习记录\n关于swtich Golang中的switch的每个case自带break关键字，即不用手动去设置break关键字。 import ( \u0026#34;fmt\u0026#34; ) func main(){ variables := 12 switch variables { case 24: fmt.Println(\u0026#39;24\u0026#39;) case 12: fmt.Println(\u0026#39;12\u0026#39;) case 36: fmt.Println(\u0026#39;36\u0026#39;) default: fmt.Println(\u0026#39;114514\u0026#39;) } } // 12 如果在其他语言中这样编写switch代码块，36和default代码块中的输出也会执行。 fallthrough关键字 当然，golang也提供了能够无视掉默认break的关键字，即fallthrough，在指定的case最后一行加上fallthrough，则对应的case代码块将会忽视掉默认的break操作。 // 接上 func main(){ variables := 12 switch variables { case 24: fmt.Println(\u0026#39;24\u0026#39;) case 12: fmt.Println(\u0026#39;12\u0026#39;) fallthrough case 36: fmt.Println(\u0026#39;36\u0026#39;) default: fmt.Println(\u0026#39;114514\u0026#39;) } } // 12 // 36 关于数组 在golang中的数组和c一样，一旦定义了大小就不可更改，且声明方式有多种，如下: // var variable_name [SIZE] variable_type func main(){ var balance = [3]float32{100, 2.21, 4.12} // {}中的数字个数不能大于[]中定义的数组大小 var c = [5]int{1,2,3} d := [...] int{1,2,3,4} // 不显示设置数组大小，而是根据{}中定义的数字个数来确定 e := [...] int{4: 100}// [0, 0, 0, 0, 100] -\u0026gt; 这w里的4: 100 表示数组中第五号元素为100，其余位置补0 f := [...] int{1: 12, 4: 12, 9: 12} // [0 12 0 0 12 0 0 0 0 12] -\u0026gt; 也可以指定多个下标元素 } 和js不一样的是，如果需要获得数组的长度，需要调用len方法，并把对应数组当作参数传入。 len(array) // array的长度 值类型 在golang中，数组并不是引用类型的变量，而是值类型的变量，即给新变量赋值数组时，新变量接收到的不是指针，而是数组本身的副本copy，新数组和旧数组内部元素的更改不会互相影响。 package main import \u0026#34;fmt\u0026#34; func main() { a := [...]string{\u0026#34;USA\u0026#34;, \u0026#34;China\u0026#34;, \u0026#34;India\u0026#34;, \u0026#34;Germany\u0026#34;, \u0026#34;France\u0026#34;} b := a // a copy of a is assigned to b b[0] = \u0026#34;Singapore\u0026#34; fmt.Println(\u0026#34;a is \u0026#34;, a) fmt.Println(\u0026#34;b is \u0026#34;, b) } // a is [USA China India Germany France] // b is [Singapore China India Germany France] // 可以看到a数组内部的元素并没有同步更新 Slice 切片 Slice是对Go语言中数组的抽象。由于数组不可改变，特定场景中这样的集合变量就不太实用，于是slice便出现了，它也可以理解为“动态数组”可以追加元素。 需要注意的是，Slice只是对现有数组的引用，它本身没有任何数据，Slice上的改变都会影响到底层数组内值的更改。 从概念上来说，Slice就像一个结构体，它包含三个元素: 指针，指向数组中slice指定的开始位置（本质是对数组的引用） 长度，slice的长度。 最大长度，slice的开始位置到数组的最后位置的长度 Slice定义语法 // 声明语法 var identifier []type 切片不需要说明长度，也可以使用make函数来进行切片创建。 var slice []type = make([]type, len) slice := make([]type, len) // make创建的范式如下 make([]T, length, capacity) 如果要进行初始化，可以如下 s := []int {1, 2, 3} // 注意, []中没有三个点，如果有三个点，表明是数组的初始化。 s := array[startIndex: endIndex] // 通过数组的切片来获得，此时s表示数组array的指针。 修改切片 由于silce只是底层数组的引用，所以slice上的修改会同步反映到底层数组中。 func main() { darr := [...]int{57, 89, 90, 82, 100, 78, 67, 69, 59} dslice := darr[2:5] fmt.Println(\u0026#34;array before\u0026#34;,darr) for i := range dslice { dslice[i]++ } fmt.Println(\u0026#34;array after\u0026#34;,darr) } // array before [57 89 90 82 100 78 67 69 59] // array after [57 89 91 83 101 78 67 69 59] // 可以看到，第三个元素到第五个元素都自增了一次 len() 和 cap() len方法和array的用法一样，用来获得切片此时的长度，而cap方法则是获取切片的最大长度。 func main() { a := []string{\u0026#34;USA\u0026#34;, \u0026#34;China\u0026#34;, \u0026#34;India\u0026#34;, \u0026#34;Germany\u0026#34;, \u0026#34;France\u0026#34;} d := a[1:2] fmt.Println(len(d), cap(d)) } // 1, 4 // cap(d) = 4 -\u0026gt; 从切片开始的位置（第二个元素）到数组最后一个元素位置有4个 append() 和 copy() append是在切片后增加元素，copy则是获取切片的拷贝（注意，这里的拷贝是深拷贝，即底层的数组也会跟着一起拷贝，两个切片之间不会建立联系） append增加元素也会影响到底层数组，但如果增加元素后，切片已经超过最大长度，则golang会重新在底层创建一个适合于新切片的最大长度的数组，并将对应的slice指向新的数组上，此时便不会影响到旧的底层数组，示例代码如下 package main import \u0026#34;fmt\u0026#34; func main() { a := []string{\u0026#34;USA\u0026#34;, \u0026#34;China\u0026#34;, \u0026#34;India\u0026#34;, \u0026#34;Germany\u0026#34;, \u0026#34;France\u0026#34;} b := a[1:3] b = append(b, \u0026#34;Jap\u0026#34;) d := a[1:5] d = append(d, \u0026#34;smart\u0026#34;) fmt.Println(\u0026#34;切片a: \u0026#34;, a) fmt.Println(\u0026#34;切片b: \u0026#34;, b) fmt.Println(\u0026#34;切片d: \u0026#34;, d) } /* 切片a: [USA China India Jap France] 切片b: [China India Jap] 切片d: [China India Jap France smart] 可以看到，切片b的增加影响到了切片a，但是切片d的增加却对a没有任何影响。 */ 待解决问题: interface变量是啥\n","permalink":"https://runtus.top/posts/go-learning-1/","summary":"Golang学习记录\n关于swtich Golang中的switch的每个case自带break关键字，即不用手动去设置break关键字。 import ( \u0026#34;fmt\u0026#34; ) func main(){ variables := 12 switch variables { case 24: fmt.Println(\u0026#39;24\u0026#39;) case 12: fmt.Println(\u0026#39;12\u0026#39;) case 36: fmt.Println(\u0026#39;36\u0026#39;) default: fmt.Println(\u0026#39;114514\u0026#39;) } } // 12 如果在其他语言中这样编写switch代码块，36和default代码块中的输出也会执行。 fallthrough关键字 当然，golang也提供了能够无视掉默认break的关键字，即fallthrough，在指定的case最后一行加上fallthrough，则对应的case代码块将会忽视掉默认的break操作。 // 接上 func main(){ variables := 12 switch variables { case 24: fmt.Println(\u0026#39;24\u0026#39;) case 12: fmt.Println(\u0026#39;12\u0026#39;) fallthrough case 36: fmt.Println(\u0026#39;36\u0026#39;) default: fmt.Println(\u0026#39;114514\u0026#39;) } } // 12 // 36 关于数组 在golang中的数组和c一样，一旦定义了大小就不可更改，且声明方式有多种，如下: // var variable_name [SIZE] variable_type func main(){ var balance = [3]float32{100, 2.","title":"go-learning-1"},{"content":" Javascript和HTML的交互都是通过事件来实现的，而事件的产生与执行则是遵循着传统软件工程领域中的观察者模式，其能够做到页面行为和页面展示的解耦合。\n本节内容会从事件流谈起，然后逐一介绍几种注册事件的方式以及他们其中的一些细节，最后还会提到关于**事件委托（代理）**的概念。\n事件流 事件流描述了页面接受事件的顺序。因为一个事件的触发可能会影响好几处地方，这很容易理解，比如在页面上嵌套着写了几个div元素，同时在最里层的div元素上进行事件触发，那这不仅仅是最内层的div对事件进行响应，任意一层的嵌套的div都会对事件进行相应处理。（其实通过上述的观察者模式也可以推断出其合理性，因为一个对象可以由多个观察者进行观察） 所以多个监听事件的元素响应顺序需要进行统一，因为一些历史原因，事件的响应顺序有两种模式：冒泡和捕获。 事件冒泡 顾名思义，事件的冒泡就如水底下的气泡一下，从内到外，同理，事件冒泡规定的事件流顺序也是从内而外，事件会从最深层的节点开始触发，然后向外传播到document（文档）。 代码如下所示。 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;ddd\u0026#34;\u0026gt; click me \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 此时我如果对id=ddd的div元素进行click事件触发，那么该事件会以如下顺序发生: div body html document 现代的浏览器的事件会一直冒泡到window对象。 事件捕获 事件捕获则和事件冒泡相反，事件的响应顺序是从外到内的，还是以上一个例子为例，那么对应click事件讲会以如下顺序发生: document html body div DOM事件流 DOM2 Events规范里规定里事件流为分三个部分：事件捕获，到达目标和事件冒泡。 需要注意的是，div元素（即直接触发元素）是不会响应捕获事件的，因为通常认为直接触发事件是冒泡阶段发生的，所以它也是冒泡阶段第一个发生的事件。 但现在大多数支持DOM事件流的浏览器都实现了一个小小的拓展，即在捕获阶段在事件目标上触发事件。最终结果表现为有两个机会来处理事件。 事件处理程序 事件意味着用户或浏览器执行的某种动作，而为响应事件而调用的函数被称为事件处理程序（事件监听器）。 HTML事件处理程序 HTML事件处理程序是以HTML属性的形式来进行指定的。该属性的值必须是能够执行的javascript代码。 比如下面这个例子，就是按钮在被点击时执行一段代码。 \u0026lt;button onclick=\u0026#34;console.log(\u0026#39;click\u0026#39;)\u0026#34;\u0026gt; click me \u0026lt;/button\u0026gt; 当然也可以以函数的形式来进行响应事件定义。 \u0026lt;script\u0026gt; function click(event){ console.log(\u0026#39;click\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;button onclick=\u0026#34;click(event)\u0026#34;\u0026gt; click me \u0026lt;/button\u0026gt; 可以看到，除了把函数单独拎出来以外，还多了一个event对象，这个是一个特殊的局部变量，它定义了事件触发的一些属性以及被触发元素的一些属性。 除此之外，HTML事件处理程序中的this就是DOM元素本身，所以可以直接使用this对象去获取对应元素上的属性。 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Click Me\u0026#34; onclick=\u0026#34;console.log(this.value)\u0026#34;\u0026gt; 这里还有个比较有趣的地方，获取元素属性时可以直接省略掉this，直接使用value，即下面写法也能达到同样的效果。 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Click Me\u0026#34; onclick=\u0026#34;console.log(value)\u0026#34;\u0026gt; 因为这个包装函数在创建时其作用域链被with操作符给延长了，所以document和元素自身的成员都可以被当成局部变量来使用。 function() { with(document) { with(this) { // 属性值 } } } 但最好不要这样做，因为不仅仅会显得很诡异，而且在后期调试时也会造成误解。 HTML事件处理程序一个比较大的问题是：它把HTML和Javascript在代码上进行了强耦合（在逻辑上依然是分开的），如果我们需要更改响应程序，那么两处都需要进行修改。\n所以更多的时候，我们使用的是Javascript去指定事件处理程序而不是HTML。\nDOM0 事件处理程序 这是Javascript指定事件处理程序的传统方式，在Javascript中对DOM元素的属性进行赋值从而达到事件监听的效果。 let btn = document.getElementById(\u0026#34;myBtn\u0026#34;); // 如果在下面的事件赋值之前进行事件点击，是没有任何响应的。 btn.onclick = function() { console.log(\u0026#34;Clicked\u0026#34;); }; 如果需要移除事件处理程序，只需要对onclick属性赋值null即可。 btn.onclick = null; DOM2 事件处理程序 DOM2 Events为事件处理程序的赋值和移除定义了两个方法: addEventListener 和 removeEventListener。其目的在于统一事件注册接口，因为不只有click这么一个事件，还有诸多的类似于mouseover，scroll等的事件，所以把接口统一是很有必要的。 如果要给按钮添加click事件，可以这样写: let btn = document.getElementById(\u0026#34;myBtn\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; { console.log(this.id); }, false); // 第三个参数表示是冒泡事件还是捕获事件 // false -\u0026gt; 冒泡(缺省状态) // true -\u0026gt; 捕获 需要注意的是，通过addEventListener添加的匿名函数无法被移除，如上述例子添加的click事件就无法移除，所以事件的处理函数最好单独用一个变量进行存储，方便以后删除。 let btn = document.getElementById(\u0026#34;myBtn\u0026#34;); let handle = () =\u0026gt; { console.log(this.id); } btn.addEventListener(\u0026#34;click\u0026#34;, handle ,false); // 进行一番处理后移除监听函数 btn.removeEventListener(\u0026#39;click\u0026#39;, handle) 事件对象 event 事件对象就是之前在HTML事件处理程序中提到的Event对象，只不过在Javascript事件处理程序中不需要显示传入Event对象，因为DOM的所有事件函数都已经装载了event对象，直接使用第一个变量即可。 let btn = document.getElementById(\u0026#34;myBtn\u0026#34;); let handle = (e) =\u0026gt; { console.log(e.target); } btn.addEventListener(\u0026#34;click\u0026#34;, handle ,false); 这里需要提到event对象的两个比较混淆的属性：target和currentTarget。 target指的是事件目标，即直接触发了事件的那个DOM元素本身。 而currentTarget则是当前事件的处理程序所绑定的元素。这可能不怎么好理解，下面有个实例。 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;btn\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; document.body.addEventListener(\u0026#39;click\u0026#39;, function(e) { console.log(\u0026#39;事件冒泡获得\u0026#39;) console.log(this === document.body) // true console.log(this === e.currentTarget) // true console.log(this === e.target) // false }) \u0026lt;/script\u0026gt; 当我点击id=btn的div元素时，直接触发事件的元素是div，但由于事件冒泡所以body上也会响应该事件，且执行对应的事件函数。 而这里的target指的是id=btn的div元素，currentTarget则指的是body，即绑定事件的DOM元素。 事件委托（代理） 绑定事件监听函数是会占据内存空间的，虽然每个事件本身不会占据太多空间，但一旦数量多起来，还是会对性能造成一定的影响，所以在优化内存占用时，会尽可能地去减少事件的注册数量，尽量用一个代理函数去处理多个事件。 从代码实现的层面来考虑，通过事件冒泡和DOM树机制可以联想到，多个子节点的事件进行冒泡时最终会汇聚到某个父节点上，利用这一点，我们就不必在每个子节点上都设置事件监听函数，而是在对应的父节点上设置一个事件冒泡拦截函数，用这一个函数去处理每个子节点的事件触发，这就完成了一次事件委托，极大减少了事件监听的数量。 最常见的应用便是列表节点的事件监听，如下所示: \u0026lt;!-- 这里直接使用红宝书上的例子 --\u0026gt; \u0026lt;ul id=\u0026#34;myLinks\u0026#34;\u0026gt; \u0026lt;li id=\u0026#34;goSomewhere\u0026#34;\u0026gt;Go somewhere\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;doSomething\u0026#34;\u0026gt;Do something\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;sayHi\u0026#34;\u0026gt;Say hi\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; let list = document.getElementById(\u0026#34;myLinks\u0026#34;); list.addEventListener(\u0026#34;click\u0026#34;, (event) =\u0026gt; { let target = event.target; switch(target.id) { case \u0026#34;doSomething\u0026#34;: document.title = \u0026#34;I changed the document\u0026#39;s title\u0026#34;; break; case \u0026#34;goSomewhere\u0026#34;: location.href = \u0026#34;http:// www.wrox.com\u0026#34;; break; case \u0026#34;sayHi\u0026#34;: console.log(\u0026#34;hi\u0026#34;); break; } }); \u0026lt;/script\u0026gt; ","permalink":"https://runtus.top/posts/0120-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6/","summary":"Javascript和HTML的交互都是通过事件来实现的，而事件的产生与执行则是遵循着传统软件工程领域中的观察者模式，其能够做到页面行为和页面展示的解耦合。\n本节内容会从事件流谈起，然后逐一介绍几种注册事件的方式以及他们其中的一些细节，最后还会提到关于**事件委托（代理）**的概念。\n事件流 事件流描述了页面接受事件的顺序。因为一个事件的触发可能会影响好几处地方，这很容易理解，比如在页面上嵌套着写了几个div元素，同时在最里层的div元素上进行事件触发，那这不仅仅是最内层的div对事件进行响应，任意一层的嵌套的div都会对事件进行相应处理。（其实通过上述的观察者模式也可以推断出其合理性，因为一个对象可以由多个观察者进行观察） 所以多个监听事件的元素响应顺序需要进行统一，因为一些历史原因，事件的响应顺序有两种模式：冒泡和捕获。 事件冒泡 顾名思义，事件的冒泡就如水底下的气泡一下，从内到外，同理，事件冒泡规定的事件流顺序也是从内而外，事件会从最深层的节点开始触发，然后向外传播到document（文档）。 代码如下所示。 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;ddd\u0026#34;\u0026gt; click me \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 此时我如果对id=ddd的div元素进行click事件触发，那么该事件会以如下顺序发生: div body html document 现代的浏览器的事件会一直冒泡到window对象。 事件捕获 事件捕获则和事件冒泡相反，事件的响应顺序是从外到内的，还是以上一个例子为例，那么对应click事件讲会以如下顺序发生: document html body div DOM事件流 DOM2 Events规范里规定里事件流为分三个部分：事件捕获，到达目标和事件冒泡。 需要注意的是，div元素（即直接触发元素）是不会响应捕获事件的，因为通常认为直接触发事件是冒泡阶段发生的，所以它也是冒泡阶段第一个发生的事件。 但现在大多数支持DOM事件流的浏览器都实现了一个小小的拓展，即在捕获阶段在事件目标上触发事件。最终结果表现为有两个机会来处理事件。 事件处理程序 事件意味着用户或浏览器执行的某种动作，而为响应事件而调用的函数被称为事件处理程序（事件监听器）。 HTML事件处理程序 HTML事件处理程序是以HTML属性的形式来进行指定的。该属性的值必须是能够执行的javascript代码。 比如下面这个例子，就是按钮在被点击时执行一段代码。 \u0026lt;button onclick=\u0026#34;console.log(\u0026#39;click\u0026#39;)\u0026#34;\u0026gt; click me \u0026lt;/button\u0026gt; 当然也可以以函数的形式来进行响应事件定义。 \u0026lt;script\u0026gt; function click(event){ console.log(\u0026#39;click\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;button onclick=\u0026#34;click(event)\u0026#34;\u0026gt; click me \u0026lt;/button\u0026gt; 可以看到，除了把函数单独拎出来以外，还多了一个event对象，这个是一个特殊的局部变量，它定义了事件触发的一些属性以及被触发元素的一些属性。 除此之外，HTML事件处理程序中的this就是DOM元素本身，所以可以直接使用this对象去获取对应元素上的属性。 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Click Me\u0026#34; onclick=\u0026#34;console.log(this.value)\u0026#34;\u0026gt; 这里还有个比较有趣的地方，获取元素属性时可以直接省略掉this，直接使用value，即下面写法也能达到同样的效果。 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Click Me\u0026#34; onclick=\u0026#34;console.log(value)\u0026#34;\u0026gt; 因为这个包装函数在创建时其作用域链被with操作符给延长了，所以document和元素自身的成员都可以被当成局部变量来使用。 function() { with(document) { with(this) { // 属性值 } } } 但最好不要这样做，因为不仅仅会显得很诡异，而且在后期调试时也会造成误解。 HTML事件处理程序一个比较大的问题是：它把HTML和Javascript在代码上进行了强耦合（在逻辑上依然是分开的），如果我们需要更改响应程序，那么两处都需要进行修改。","title":"0120-浏览器事件"},{"content":" 虽然原生DOM API已经能做许多事情了，但是仍然不断有标准或专有的扩展出现，以支持更多的功能，由于各个浏览器对DOM扩展的支持是专有的，为了统一这些专有的DOM API，W3C开始着手将这些专有扩展转变为标准规范。\nSelectors API Selectors APIs 是浏览器原生支持的CSS查询API，由于是原生支持，解析和遍历DOM树可以通过底层编译语言实现，相比其他Javascript库（比如jQuery），性能有数量级的提升。 Selectors API Level 1 主要是两个API：querySelector() 和 querySelectorAll() querySelector() 该方法接受CSS选择符参数，返回匹配到的第一个后代元素，如果没有匹配元素则返回null。 // 匹配 class 为 list 的第一个DOM元素 document.querySelector(\u0026#39;.list\u0026#39;) // 匹配 id 为 myDiv 的第一个DOM元素 document.querySelector(\u0026#39;#myDiv\u0026#39;) // 匹配 class=header DOM元素子元素中 id为someDiv的元素 const header = querySelector(\u0026#39;.header\u0026#39;); header.querySelector(\u0026#39;#someDiv\u0026#39;) 如果直接在document上使用querySelector方法，会从文档元素开始搜索（前两个例子）；在Element上使用querySelector方法，则只会在该元素的后代中查询（第三个例子）。 querySelectorAll() 该方法和querySelector类似，接受CSS选择符参数，只不过它会返回匹配的所有节点。即返回的是一个NodeList的静态实例。\n⚠️注意：无论是querySelector还是querySelectorAll返回的都是DOM元素的静态快照，即和之前提到的getElementById获取的动态实例不同，更改静态快照是不会影响DOM元素在页面上的渲染。\nmatches() matches方法接受一个css选择符参数，用于判断是否存在对应css选择符的DOM元素，如果存在返回true，否则返回false。 if(document.body.matches(\u0026#34;body.header\u0026#34;)){ // true } CSS类扩展 HTML5增加了一些特性以方便使用CSS类。 getElementsByClassName() 该方法接受一个参数，包含一个或多个类名的字符串，返回类名中包含对应类的元素的NodeList。 // 返回 class 包含 username 和 current 的类 document.getElementsByClassName(\u0026#39;username current\u0026#39;) classList属性 classList属性提供了快速操作DOM元素类名的方法，如果是之前，对一个含有多个class的DOM元素进行类名操作会很麻烦，基本操作都是把其类字符串解析成数组，然后一个一个进行匹配操作，最后再合并为一个新的类字符串重新赋值回去。 // 要删除\u0026#34;user\u0026#34;类 let targetClass = \u0026#34;user\u0026#34;; // 把类名拆成数组 let classNames = div.className.split(/\\s+/); // 找到要删除类名的索引 let idx = classNames.indexOf(targetClass); // 如果有则删除 if (idx \u0026gt; -1) { classNames.splice(i,1); } // 重新设置类名 div.className = classNames.join(\u0026#34; \u0026#34;); 现在通过classList可以快速对类名进行操作。\nadd(value) -\u0026gt; 类名列表添加值为value的类 contains(value) -\u0026gt; 返回布尔值，表示给定value是否存在 remove(value) -\u0026gt; 从类名列表中删除指定字符串 toggle(value) -\u0026gt; 如果类名中存在指定的value，则进行删除；如果不存在，则添加。 这个扩展方法在需要通过class来控制样式变换时非常有效。\n","permalink":"https://runtus.top/posts/dom%E6%89%A9%E5%B1%95/","summary":"虽然原生DOM API已经能做许多事情了，但是仍然不断有标准或专有的扩展出现，以支持更多的功能，由于各个浏览器对DOM扩展的支持是专有的，为了统一这些专有的DOM API，W3C开始着手将这些专有扩展转变为标准规范。\nSelectors API Selectors APIs 是浏览器原生支持的CSS查询API，由于是原生支持，解析和遍历DOM树可以通过底层编译语言实现，相比其他Javascript库（比如jQuery），性能有数量级的提升。 Selectors API Level 1 主要是两个API：querySelector() 和 querySelectorAll() querySelector() 该方法接受CSS选择符参数，返回匹配到的第一个后代元素，如果没有匹配元素则返回null。 // 匹配 class 为 list 的第一个DOM元素 document.querySelector(\u0026#39;.list\u0026#39;) // 匹配 id 为 myDiv 的第一个DOM元素 document.querySelector(\u0026#39;#myDiv\u0026#39;) // 匹配 class=header DOM元素子元素中 id为someDiv的元素 const header = querySelector(\u0026#39;.header\u0026#39;); header.querySelector(\u0026#39;#someDiv\u0026#39;) 如果直接在document上使用querySelector方法，会从文档元素开始搜索（前两个例子）；在Element上使用querySelector方法，则只会在该元素的后代中查询（第三个例子）。 querySelectorAll() 该方法和querySelector类似，接受CSS选择符参数，只不过它会返回匹配的所有节点。即返回的是一个NodeList的静态实例。\n⚠️注意：无论是querySelector还是querySelectorAll返回的都是DOM元素的静态快照，即和之前提到的getElementById获取的动态实例不同，更改静态快照是不会影响DOM元素在页面上的渲染。\nmatches() matches方法接受一个css选择符参数，用于判断是否存在对应css选择符的DOM元素，如果存在返回true，否则返回false。 if(document.body.matches(\u0026#34;body.header\u0026#34;)){ // true } CSS类扩展 HTML5增加了一些特性以方便使用CSS类。 getElementsByClassName() 该方法接受一个参数，包含一个或多个类名的字符串，返回类名中包含对应类的元素的NodeList。 // 返回 class 包含 username 和 current 的类 document.getElementsByClassName(\u0026#39;username current\u0026#39;) classList属性 classList属性提供了快速操作DOM元素类名的方法，如果是之前，对一个含有多个class的DOM元素进行类名操作会很麻烦，基本操作都是把其类字符串解析成数组，然后一个一个进行匹配操作，最后再合并为一个新的类字符串重新赋值回去。 // 要删除\u0026#34;user\u0026#34;类 let targetClass = \u0026#34;user\u0026#34;; // 把类名拆成数组 let classNames = div.","title":"DOM扩展"},{"content":" 浏览器缓存是性能优化中最直接，高效的优化方式，它可以显著减少因为网络传输而带来的损耗。\n对于数据请求来说，大致可以分为 请求 -\u0026gt; 处理 -\u0026gt; 响应这三个步骤，而浏览器缓存则主要在第一步和第三步做手脚，即请求发出时寻找合适的缓存，拿到新的响应数据时做新的缓存。 缓存带给我们最直观的感受就是，每次加载页面，第二次之后加载总是比第一次加载的更快，这就是缓存的功劳，下面讲从缓存位置和缓存策略两个方面介绍浏览器相关缓存。 缓存位置 浏览器的缓存位置大概可以分为四种： Service Worker Memory Cache Disk Cache Push Cache（HTTP 2） 他们有各自的优先级，当发出请求时，浏览器会依次去寻找缓存，如果都没有命中，才会发出请求。 Service Worker Service Worker是浏览器背后的独立线程，可以用来实现缓存功能，但是需要注意，如果要使用Service Worker，传输协议必须是HTTPS。 Service Worker实现缓存大致三个步骤。 注册Service Worker。 监听install事件，并对需要的文件进行缓存。 拦截HTTPS请求，并根据请求内容去命中缓存，如果命中，则直接使用缓存，否则请求数据。 下面是一串实例代码（源代码来自前端面试之道） // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register(\u0026#39;sw.js\u0026#39;) .then(function(registration) { console.log(\u0026#39;service worker 注册成功\u0026#39;) }) .catch(function(err) { console.log(\u0026#39;servcie worker 注册失败\u0026#39;) }) } // sw.js // 监听install事件，缓存文件 self.addEventListener(\u0026#39;install\u0026#39;, e =\u0026gt; { e.waitUntil( caches.open(\u0026#39;my-cache\u0026#39;).then(function(cache) { return cache.addAll([\u0026#39;./index.html\u0026#39;, \u0026#39;./index.js\u0026#39;]) }) ) }) // 拦截请求，并根据请求去命中响应数据 self.addEventListener(\u0026#39;fetch\u0026#39;, e =\u0026gt; { e.respondWith( caches.match(e.request).then(function(response) { if (response) { return response } console.log(\u0026#39;fetch source\u0026#39;) }) ) }) Memory Cache -\u0026gt; 内存缓存 由于是内存缓存，所以速度会比后续马上讲到的磁盘缓存速度快很多，但是内存空间非常有限，所以一般内存缓存的内容都比较小，且生命周期短，会随着进程的释放而释放（关闭页面）。 内存缓存一般是css，js，svg，小图片文件等，打开浏览器的开发者工具，重新刷新网络页面，可以发现很多请求右侧都有memory cache的提示，说明这些请求就是命中内存缓存中的内容而直接返回的内容。 Disk Cache 磁盘缓存虽然速度没有内存缓存快，但是容量大，基本什么内容都可以存在磁盘中，并且可以存储内容的生命周期长。 磁盘缓存会根据HTTP Header中国呢的字段判断哪些内容需要缓存，哪些资源可以直接使用，哪些资源已经过期需要重新请求。需要注意的是，相同地址的资源一旦被磁盘缓存下来，就不会再次去请求数据，比如我直接更改博客图片链接所指向的图片内容（链接不变），重新刷新后会发现图片依然是原来的图片。 Push Cache(Http2) push cache是HTTP/2的内容，当上面三个缓存都没有命中时，才会被使用。并且缓存的时间非常短暂，只在session中存在，一旦session结束就会被释放。由于接触的不多，这里不细讲。 缓存策略 缓存策略分为两种：强缓存和协商缓存。并且它们的缓存策略都是通过HTTP Header来实现的。需要注意的是，这两种缓存并不是互斥的，即强缓存和协商缓存在一次请求中是同时存在的，下面会细说。\n强缓存 强缓存通过设置两种HTTP Header来实现：Expires和Cache-Control。强缓存表示的是在缓存期间内不需要请求，响应码为200. Expires Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires是HTTP/1的响应头，它表示的是请求的资源会在上述的时间后过期。如果资源会再次过期，并且Expires是基于本地时间进行判断的，如果人为更改了本地时间，可能会造成缓存失效。 Cache-Control cache-control: public, max-age=31536000, s-maxage=31536000, immutable Cache-Control是HTTP/1.1的请求/响应头，并且它的优先级高于Expires，该资源表示资源是可以被客户端，代理服务器缓存的，且缓存时间为一年。 上述可以看到，Cache-Control可以使用多种指令，从而达到多个目的，下面是一些常见指令的作用。 协商缓存 协商缓存一般发生在强缓存不能进行的时候，当浏览器需要命中缓存却发现缓存已经过期时，它不会立即删除缓存，而是抱着试一试的态度，带着缓存的唯一标识信息去询问后端资源有没有更改，如果没有更改，就直接返回304(Not Modified)，并更新本地缓存有效期。\n和强缓存类似，协商缓存也需要借助HTTP Header字段的帮助，它们分别是Last-Modified和E-Tag\nLast-Modified 和 If-Modified-Since -\u0026gt; HTTP/1 Last-Modified 表示本地文件最后修改日期，If-Modified-Since会把Last-Modified的值发送给服务器，询问服务器在该时间段后，资源是否发生了更改，如果有更新，则会正常请求资源（200），并更新本地缓存，如果没有，则直接返回缓存资源（304）。 ETag 和 If-None-Match ETag类似于文件id，If-None-Match会把ETag的值发送给服务器，并询问对应资源是否有更改，如果没有变动就直接返回本地缓存，如果有变动则返回新的资源，并更新本地缓存。需要注意的是，ETag的优先级比Last-Modified高。 ","permalink":"https://runtus.top/posts/1224-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","summary":"浏览器缓存是性能优化中最直接，高效的优化方式，它可以显著减少因为网络传输而带来的损耗。\n对于数据请求来说，大致可以分为 请求 -\u0026gt; 处理 -\u0026gt; 响应这三个步骤，而浏览器缓存则主要在第一步和第三步做手脚，即请求发出时寻找合适的缓存，拿到新的响应数据时做新的缓存。 缓存带给我们最直观的感受就是，每次加载页面，第二次之后加载总是比第一次加载的更快，这就是缓存的功劳，下面讲从缓存位置和缓存策略两个方面介绍浏览器相关缓存。 缓存位置 浏览器的缓存位置大概可以分为四种： Service Worker Memory Cache Disk Cache Push Cache（HTTP 2） 他们有各自的优先级，当发出请求时，浏览器会依次去寻找缓存，如果都没有命中，才会发出请求。 Service Worker Service Worker是浏览器背后的独立线程，可以用来实现缓存功能，但是需要注意，如果要使用Service Worker，传输协议必须是HTTPS。 Service Worker实现缓存大致三个步骤。 注册Service Worker。 监听install事件，并对需要的文件进行缓存。 拦截HTTPS请求，并根据请求内容去命中缓存，如果命中，则直接使用缓存，否则请求数据。 下面是一串实例代码（源代码来自前端面试之道） // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register(\u0026#39;sw.js\u0026#39;) .then(function(registration) { console.log(\u0026#39;service worker 注册成功\u0026#39;) }) .catch(function(err) { console.log(\u0026#39;servcie worker 注册失败\u0026#39;) }) } // sw.js // 监听install事件，缓存文件 self.addEventListener(\u0026#39;install\u0026#39;, e =\u0026gt; { e.waitUntil( caches.open(\u0026#39;my-cache\u0026#39;).then(function(cache) { return cache.addAll([\u0026#39;./index.html\u0026#39;, \u0026#39;./index.js\u0026#39;]) }) ) }) // 拦截请求，并根据请求去命中响应数据 self.","title":"1224-浏览器缓存"},{"content":"NodeList 和 HTMLCollection区别\nNodeList是节点的集合，而HTMLCollection是元素的集合。\n节点包括很多类型，文档节点，元素节点，属性节点，文本节点，这一点通过Node类型上的12个数值常量表示就可以看出。\nNode.ELEMENT_NODE（1） Node.ATTRIBUTE_NODE（2） Node.TEXT_NODE（3） Node.CDATA_SECTION_NODE（4） Node.ENTITY_REFERENCE_NODE（5） Node.ENTITY_NODE（6） Node.PROCESSING_INSTRUCTION_NODE（7） Node.COMMENT_NODE（8） Node.DOCUMENT_NODE（9） Node.DOCUMENT_TYPE_NODE（10） Node.DOCUMENT_FRAGMENT_NODE（11） Node.NOTATION_NODE（12） // 常用的获取DOM元素的接口及其返回的数据结合类型 Node.childNodes instanceof Nodelist Node.chidren instanceof HTMLCollection document.getElementByxxxx instanceof HTMLCollection 注意：NodeList，HTMLCollection，NamedNodeMap 都是实时的，意味着文档结构的变化会实时地在它们身上反映出来。\n","permalink":"https://runtus.top/posts/1222-dom1/","summary":"NodeList 和 HTMLCollection区别\nNodeList是节点的集合，而HTMLCollection是元素的集合。\n节点包括很多类型，文档节点，元素节点，属性节点，文本节点，这一点通过Node类型上的12个数值常量表示就可以看出。\nNode.ELEMENT_NODE（1） Node.ATTRIBUTE_NODE（2） Node.TEXT_NODE（3） Node.CDATA_SECTION_NODE（4） Node.ENTITY_REFERENCE_NODE（5） Node.ENTITY_NODE（6） Node.PROCESSING_INSTRUCTION_NODE（7） Node.COMMENT_NODE（8） Node.DOCUMENT_NODE（9） Node.DOCUMENT_TYPE_NODE（10） Node.DOCUMENT_FRAGMENT_NODE（11） Node.NOTATION_NODE（12） // 常用的获取DOM元素的接口及其返回的数据结合类型 Node.childNodes instanceof Nodelist Node.chidren instanceof HTMLCollection document.getElementByxxxx instanceof HTMLCollection 注意：NodeList，HTMLCollection，NamedNodeMap 都是实时的，意味着文档结构的变化会实时地在它们身上反映出来。","title":"1222-DOM"},{"content":" 如今的浏览器虽然接口已大致统一，但是每家浏览器难免都有自己的“想法”，于是会出现个别的不统一，这些差异迫使Web开发者自己去设计兼容这些差异，客户端检测就是最常见的检测手段，通过检测结果来进一步克服和避免这些缺陷。\n客户端检测可大致分为三种：能力检测，用户代理检测，软件与硬件检测。\n能力检测 能力检测也成为特性检测，因为不同浏览器提供的接口不是完全相同，于是可以通过简单的逻辑判断来检测在该浏览器环境下能否调用特定API，同时还能间接判断出浏览器类型。 比如，在IE5之前没有document.getElementById这个DOM方法，但是可以通过document.all来实现相同的功能。于是，可以进行如下的能力检测。 const getElementById = (id) =\u0026gt; { if(document.getElementById){ return document.getElementById(id) } else if (document.all){ return document.all[id] } else { throw new Error(\u0026#39;该浏览不支持任何通过ID获取DOM元素的方法\u0026#39;) } } 需要注意的是，实现能力检测是一定要落实到具体的功能上，即某个能力的存在并不能代表其他能力也存在。 function getWindowWidth() { if (document.all) { // 假设 IE return document.documentElement.clientWidth; // 不正确的用法！ } else { return window.innerWidth; } } 比如上述例子，document.all的存在并不能说明documentElement.clientWidth的存在。其实这段代码的本意是通过document.all来判断当前浏览器是不是IE浏览器，事实document.all的存在并不能一定确认该浏览器就是IE浏览器。 基于能力检测进行浏览器分析 除了上述可以进行基本的功能检测以外，还可以通过能力检测来进行浏览器的特性支持检测，比如是否支持Netscape插件，是否具有DOM Level 1能力等等。 // 红宝书P384 // 检测浏览器是否支持 Netscape 式的插件 let hasNSPlugins = !!(navigator.plugins \u0026amp;\u0026amp; navigator.plugins.length); // 检测浏览器是否具有 DOM Level 1 能力 let hasDOM1 = !!(document.getElementById \u0026amp;\u0026amp; document.createElement \u0026amp;\u0026amp; document.getElementsByTagName); 当然，也可以通过特定的能力检测来判断浏览器的类型，即根据对浏览器特性的检测与已知特性对比，来确认用户使用的是什么浏览器。 // 红宝书 P385 class BrowserDetector { constructor() { // 测试条件编译 // IE6~10 支持 this.isIE_Gte6Lte10 = /*@cc_on!@*/false; // 测试 documentMode // IE7~11 支持 this.isIE_Gte7Lte11 = !!document.documentMode; // 测试 StyleMedia 构造函数 // Edge 20 及以上版本支持 this.isEdge_Gte20 = !!window.StyleMedia; // 测试 Firefox 专有扩展安装 API // 所有版本的 Firefox 都支持 this.isFirefox_Gte1 = typeof InstallTrigger !== \u0026#39;undefined\u0026#39;; // 测试 chrome 对象及其 webstore 属性 // Opera 的某些版本有 window.chrome，但没有 window.chrome.webstore // 所有版本的 Chrome 都支持 this.isChrome_Gte1 = !!window.chrome \u0026amp;\u0026amp; !!window.chrome.webstore; // Safari 早期版本会给构造函数的标签符追加\u0026#34;Constructor\u0026#34;字样，如： // window.Element.toString(); // [object ElementConstructor] // Safari 3~9.1 支持 this.isSafari_Gte3Lte9_1 = /constructor/i.test(window.Element); // 推送通知 API 暴露在 window 对象上 // 使用默认参数值以避免对 undefined 调用 toString() // Safari 7.1 及以上版本支持 this.isSafari_Gte7_1 = (({pushNotification = {}} = {}) =\u0026gt; pushNotification.toString() == \u0026#39;[object SafariRemoteNotification]\u0026#39; )(window.safari); // 测试 addons 属性 // Opera 20 及以上版本支持 this.isOpera_Gte20 = !!window.opr \u0026amp;\u0026amp; !!window.opr.addons; } isIE() { return this.isIE_Gte6Lte10 || this.isIE_Gte7Lte11; } isEdge() { return this.isEdge_Gte20 \u0026amp;\u0026amp; !this.isIE(); } isFirefox() { return this.isFirefox_Gte1; } isChrome() { return this.isChrome_Gte1; } isSafari() { return this.isSafari_Gte3Lte9_1 || this.isSafari_Gte7_1; } isOpera() { return this.isOpera_Gte20; } } 上述代码会随着浏览器的变迁及发展而不同，不过提供的主要API可以保持不变。 用户代理检测 每个浏览器都包含一串用户代理字符串，在浏览器端，可以通过navigator.userAgent来获得。在服务器端，常见的做法是根据接受到的用户代理字符串来确定浏览器并执行响应操作。而用户代理字符串会在浏览器发起HTTP请求时自动附加在HTTP请求头里，及user-agent字段。\n但同时用户代理字符串也是饱受争议的，因为用户代理字段有很长一段时间具有很大的欺诈性，无论是人为伪造，还是各大厂商浏览器自带的用户代理字符串。这牵扯到浏览器的发展史，详细浏览器发展史请参考红宝书P386。\n为啥会出现连浏览器自带的用户代理字符串都会有欺诈性，原因我大概总结一下：各大厂商研发浏览器时，为了让自己浏览器不被冷落而是快速融入当时的Web环境中而不得不选择的手段。当年Netscape Navigator 3浏览器大火之时，IE3页横空出世，但是网景公司的浏览器的用户代理字段代号是Mozilla，而当时市面上基本所有的开发者都会去检测用户代理字段看其是否为Mozilla，如果IE3的用户代理字段不顺应潮流，那么根本融入不进当时的Web环境，因为几乎没有网页去适配IE3，所以微软才打算，把代号改成和网景浏览器相同的代号Mozilla。\n同理，后面的浏览器都纷纷效仿这钟做法（除了Opera，但是Opera 9以后还是选择了妥协）。但是这违背了用户代理字段设计出来的初衷，于是为了增加浏览器的辨识度，浏览器厂商考虑在用户代理字符串中再加入一段特定的标识符，用来说明浏览器类型，比如Chrome的userAgent如下所示。\n\u0026gt; navigator.userAgent //\u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\u0026#39; 所以因为这段历史，目前市面上所有的浏览器的用户代理字符串开头的代号都是Mozilla 软件与硬件检测 除开浏览器功能上的检测，浏览器还提供了许多操作系统，硬件和周边设备的信息，这些属性都暴露在window.navigator上。 这一部分的接口很多，提供了诸如地址信息，硬件内存，当前网络情况等信息的API接口，这里不一一列举，需要用的时候再去查找相关用法。（红宝书P394 - P400） ","permalink":"https://runtus.top/posts/1220-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/","summary":"如今的浏览器虽然接口已大致统一，但是每家浏览器难免都有自己的“想法”，于是会出现个别的不统一，这些差异迫使Web开发者自己去设计兼容这些差异，客户端检测就是最常见的检测手段，通过检测结果来进一步克服和避免这些缺陷。\n客户端检测可大致分为三种：能力检测，用户代理检测，软件与硬件检测。\n能力检测 能力检测也成为特性检测，因为不同浏览器提供的接口不是完全相同，于是可以通过简单的逻辑判断来检测在该浏览器环境下能否调用特定API，同时还能间接判断出浏览器类型。 比如，在IE5之前没有document.getElementById这个DOM方法，但是可以通过document.all来实现相同的功能。于是，可以进行如下的能力检测。 const getElementById = (id) =\u0026gt; { if(document.getElementById){ return document.getElementById(id) } else if (document.all){ return document.all[id] } else { throw new Error(\u0026#39;该浏览不支持任何通过ID获取DOM元素的方法\u0026#39;) } } 需要注意的是，实现能力检测是一定要落实到具体的功能上，即某个能力的存在并不能代表其他能力也存在。 function getWindowWidth() { if (document.all) { // 假设 IE return document.documentElement.clientWidth; // 不正确的用法！ } else { return window.innerWidth; } } 比如上述例子，document.all的存在并不能说明documentElement.clientWidth的存在。其实这段代码的本意是通过document.all来判断当前浏览器是不是IE浏览器，事实document.all的存在并不能一定确认该浏览器就是IE浏览器。 基于能力检测进行浏览器分析 除了上述可以进行基本的功能检测以外，还可以通过能力检测来进行浏览器的特性支持检测，比如是否支持Netscape插件，是否具有DOM Level 1能力等等。 // 红宝书P384 // 检测浏览器是否支持 Netscape 式的插件 let hasNSPlugins = !!(navigator.plugins \u0026amp;\u0026amp; navigator.plugins.length); // 检测浏览器是否具有 DOM Level 1 能力 let hasDOM1 = !","title":"1220-客户端检测"},{"content":" 观察者模式和发布订阅模式是平常业务开发中最常见的设计模式，虽然网上大多数文章将二者归为一类，其实不然，它们两者之间还是有细微的差距。\n先来个观察者模式的定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的某个属性（或状态）发生变化时，会通知所有观察者对象，让它们自动更新。 现实映射 举一个🌰，高中的时候，我会经常去问老师问题，有时候遇到比较难的问题，老师一时半会解不开，老师会说**\u0026ldquo;你先去做其他的事情吧，一会儿我找到解题思路了来叫你\u0026rdquo;**。于是乎我先去做其他事情，等待老师的召唤。过了一会儿，老师叫另一个同学来叫我去办公室找他，于是我马上放下手中的活，冲向的老师的办公室\u0026hellip;\u0026hellip; 在这里例子里，我是一位观察者，而老师则是一位我观察的对象，当老师的状态发生了变化（指想出了题的思路），我就会接受到对应的信息，然后马上更新我自己的状态（指润去找老师）。 来点转换 上述例子如果在发布-订阅模式里，我则摇身一变，变成了订阅者，专门订阅老师发布的通知信息，而老师则作为了发布者。 其实，上述例子还不能完全展示出定义所说的一对多关系，因为订阅者只有我一个人，但其实稍微扩展一下，变成多位同学向老师询问同一道题目，那这就是标准的观察者模式了，多位观察者“观察”老师的状态。 来点代码 通过上述的定义和描述，大概可以知道，在观察者模式中，一共有两个类：发布者类和订阅者类。作为一个发布者，很容易可以想到它有下面几个基本方法：增加订阅者，通知订阅者，移除订阅者。思路有了，下面就直接实现。 // 发布者类 class Publisher { constructor() { this.observers = [] // Observer -\u0026gt; 观察员 } // 添加订阅者 add(observers) { this.observers.push(...observers) } // 移除订阅者 remove(observer) { this.observers.forEach((item, index) =\u0026gt; { if (item === observer) { this.observer.splice(index, 1) } }) } // 通知订阅者 notify() { this.observers.forEach((item) =\u0026gt; { item.update(); // 注意，订阅者的方法应该它们本身定义的 }) } } 发布者基本类设计完毕，下面开始设计下订阅者，其实订阅者很简单，它最核心的就一个方法：收到发布者的信息后，去进行状态更新。如下所示。 // 定义订阅者类 class Observer { constructor() { console.log(\u0026#39;创建订阅者\u0026#39;) } update() { console.log(\u0026#39;更新状态\u0026#39;) } } 好了，上述两段代码就是最基本的观察者模式实现，实际场景的观察者模式都是基于上面的代码进行迭代。比如下面我将会把之前说的实例进行代码实现 // 教师类 class Teachere extends Publisher { constructor() { super() // this.answers = null this.observers = [] } getAnswers() { return this.answers } setAnswers(ques) { this.answers = answers; console.log(\u0026#39;老师想出了答案，快来办公室找老师\u0026#39;) this.notify() } notify() { const that = this; this.observers.forEach(item =\u0026gt; { item.update(that) }) } } // 学生类 class Student extends Observer { constructor() { console.log(\u0026#34;我是学生\u0026#34;) } update(info) { const answer = info.getAnswers() // ... 进行相关的更新操作 } } 观察者模式和发布-订阅模式的区别 其实在刚才的例子不算严格意义上的发布-订阅模式，因为发布-订阅模式中，发布者和订阅者二者之间是透明的，即它们是彼此感受不到对方的，无论是发布事件，还是订阅事件，都是交给一个统一的管理系统来进行处理的，这就类比于游戏原神中的每日委托一样，委托者在冒险家协会进行每日任务的委托，而旅行者-我则会去冒险家协会去领取每日任务，这个过程中，我们彼此感受不到对方，而是全权交给冒险家协会来进行管理的。 如果放到Javascript世界中，无论是Vue的EventBus还是Nodejs中的EventEmitter类，它们的设计理念就是发布-订阅模式，即发布事件 - 订阅事件这一个过程。 // 订阅事件 event.on(\u0026#34;callTeacher\u0026#34;, function(...args){ }) // 发布事件 event.emit(\u0026#39;callTeacher\u0026#39;, arg1, arg2, arg3, ...args) 很明显，和观察者模式不同的是，发布-订阅模式则将订阅者和发布者完全解耦，二者再也没有直接关联，它们的一切处理都统一交给第三方处理。 下面是一个简单的EventEmitter实现，为了加深对发布-订阅模式的认识。 // 发布-订阅模式的管理站 class EventEmitter { constructor() { // handlers -\u0026gt; map，存储事件和回调之间的关系 this.handlers = {} } // eventname -\u0026gt; 事件名称 , cb -\u0026gt; 响应的回调函数 on(eventName, cb) { if (!this.handlers[eventName]) { this.handlers[eventName] = [] } this.handlers[eventName].push(cb); } emit(eventName, ...args) { if (this.handlers[eventName]) { // 这里用拷贝，否则once的删除会导致handlers的forEach遍历失序 const handlers = this.handlers[eventName].slice() handlers[eventName].forEach(cb =\u0026gt; { cb(...args) }) } } off(eventName, cb) { if (this.handlers[eventName]) { this.handlers[eventName].forEach((item, index) =\u0026gt; { if (item === cb) { this.handlers[eventName].splice(index, 1) } }) } } // 为事件注册单次监听器 once(eventName, cb) { const wrapper = (...args) =\u0026gt; { cb(...args) this.off(eventName, wrapper) } this.on(eventName, wrapper) } } ","permalink":"https://runtus.top/posts/1218-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"观察者模式和发布订阅模式是平常业务开发中最常见的设计模式，虽然网上大多数文章将二者归为一类，其实不然，它们两者之间还是有细微的差距。\n先来个观察者模式的定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的某个属性（或状态）发生变化时，会通知所有观察者对象，让它们自动更新。 现实映射 举一个🌰，高中的时候，我会经常去问老师问题，有时候遇到比较难的问题，老师一时半会解不开，老师会说**\u0026ldquo;你先去做其他的事情吧，一会儿我找到解题思路了来叫你\u0026rdquo;**。于是乎我先去做其他事情，等待老师的召唤。过了一会儿，老师叫另一个同学来叫我去办公室找他，于是我马上放下手中的活，冲向的老师的办公室\u0026hellip;\u0026hellip; 在这里例子里，我是一位观察者，而老师则是一位我观察的对象，当老师的状态发生了变化（指想出了题的思路），我就会接受到对应的信息，然后马上更新我自己的状态（指润去找老师）。 来点转换 上述例子如果在发布-订阅模式里，我则摇身一变，变成了订阅者，专门订阅老师发布的通知信息，而老师则作为了发布者。 其实，上述例子还不能完全展示出定义所说的一对多关系，因为订阅者只有我一个人，但其实稍微扩展一下，变成多位同学向老师询问同一道题目，那这就是标准的观察者模式了，多位观察者“观察”老师的状态。 来点代码 通过上述的定义和描述，大概可以知道，在观察者模式中，一共有两个类：发布者类和订阅者类。作为一个发布者，很容易可以想到它有下面几个基本方法：增加订阅者，通知订阅者，移除订阅者。思路有了，下面就直接实现。 // 发布者类 class Publisher { constructor() { this.observers = [] // Observer -\u0026gt; 观察员 } // 添加订阅者 add(observers) { this.observers.push(...observers) } // 移除订阅者 remove(observer) { this.observers.forEach((item, index) =\u0026gt; { if (item === observer) { this.observer.splice(index, 1) } }) } // 通知订阅者 notify() { this.observers.forEach((item) =\u0026gt; { item.update(); // 注意，订阅者的方法应该它们本身定义的 }) } } 发布者基本类设计完毕，下面开始设计下订阅者，其实订阅者很简单，它最核心的就一个方法：收到发布者的信息后，去进行状态更新。如下所示。 // 定义订阅者类 class Observer { constructor() { console.","title":"设计模式 - 观察者模式 - 发布订阅模式"},{"content":" vuepress是SSR渲染，即vue挂载之前是在服务端进行的，所以尽量不要在before Mounted之前的hooks中调用浏览器API，否则打包时会报错。 关于css中的 mix-blender滤镜模式，和 z-index关联比较多，具体体现在我在使用darkmodejs时，如何避免图片被mix-blender渲染，虽然官方给的方法是加入isolation：isolate属性（另启层叠上下文），但是并没有什么用，感觉是哪个地方出问题了，关于层叠上下文还有上述提到的属性需要重新学习下。 另外，层叠上下文z-index和position关联很大，这个也要去做深究，我如果只是给image加z-index，则无法避免被滤镜覆盖的事实，应该是需要把他们纳入统一个层叠上下文才行，所以需要position：relative（注意，position默认是static）。这一块儿的知识也要重点去温习。 const testFn = async () =\u0026gt; { const a = 2; for(let i = 0; i \u0026lt; a; i++){ // xxxxxx } return new Promise((res) =\u0026gt; { res(); }) } A-.-\u0026gt;B ","permalink":"https://runtus.top/posts/vuepress%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","summary":" vuepress是SSR渲染，即vue挂载之前是在服务端进行的，所以尽量不要在before Mounted之前的hooks中调用浏览器API，否则打包时会报错。 关于css中的 mix-blender滤镜模式，和 z-index关联比较多，具体体现在我在使用darkmodejs时，如何避免图片被mix-blender渲染，虽然官方给的方法是加入isolation：isolate属性（另启层叠上下文），但是并没有什么用，感觉是哪个地方出问题了，关于层叠上下文还有上述提到的属性需要重新学习下。 另外，层叠上下文z-index和position关联很大，这个也要去做深究，我如果只是给image加z-index，则无法避免被滤镜覆盖的事实，应该是需要把他们纳入统一个层叠上下文才行，所以需要position：relative（注意，position默认是static）。这一块儿的知识也要重点去温习。 const testFn = async () =\u0026gt; { const a = 2; for(let i = 0; i \u0026lt; a; i++){ // xxxxxx } return new Promise((res) =\u0026gt; { res(); }) } A-.-\u0026gt;B ","title":"vuepress开发遇到的一些问题"},{"content":"视图编码（可视化编码） = 标记 + 视觉通道\n可视化设计的三部曲 可展示数据的筛选 -\u0026gt; 可视化编码映射（视图编码） -\u0026gt; 视图与交互设计\n数据可视化设计的注意事项 在对数据可视化之前，要选择合适的标记和视觉通道，选择合适的视觉通道编码能够更加清晰，直观地展现出数据的特点，同时能够使用户更加容易地分析数据特征。\n不同的视觉通道编码信息会产生不同的效果，这种效果也被称为表现力和有效性。\n表现力和有效性决定着数据可视化的最终效果。\n在表现力排序中，无论是定量型视觉通道还是定性型视觉通道，空间位置都具有最大表现力。\n决定表现力的四个维度： 精准性 可辨认性 可分离性 -\u0026gt; 不同的视觉通道编码之间互相干扰的程度 视觉突出 -\u0026gt; 人依靠本能，在很快的时间内快速感应到图形中的异常点。此维度在发现异常数据的可视化分析中至关重要。 提升表现力的方法： 聚焦：通过恰当的技术手段就将可视化结果中的最重要的部分重点突出。\n均衡：空间布局要合理，将重要的元素位于中心区域，其余元素均衡分布。\n简单：元素尽量简单，避免画面过于复杂。\n隐喻：尽量用人们所熟悉的某样事物去表达信息，从而使得可视化内容更加直观、易懂。\n数据按照它们之间的特征，可以大致分为以下的三类：\n数值型数据，分类型数据，有序性数据\n","permalink":"https://runtus.top/posts/%E5%88%9D%E5%85%A5%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","summary":"视图编码（可视化编码） = 标记 + 视觉通道\n可视化设计的三部曲 可展示数据的筛选 -\u0026gt; 可视化编码映射（视图编码） -\u0026gt; 视图与交互设计\n数据可视化设计的注意事项 在对数据可视化之前，要选择合适的标记和视觉通道，选择合适的视觉通道编码能够更加清晰，直观地展现出数据的特点，同时能够使用户更加容易地分析数据特征。\n不同的视觉通道编码信息会产生不同的效果，这种效果也被称为表现力和有效性。\n表现力和有效性决定着数据可视化的最终效果。\n在表现力排序中，无论是定量型视觉通道还是定性型视觉通道，空间位置都具有最大表现力。\n决定表现力的四个维度： 精准性 可辨认性 可分离性 -\u0026gt; 不同的视觉通道编码之间互相干扰的程度 视觉突出 -\u0026gt; 人依靠本能，在很快的时间内快速感应到图形中的异常点。此维度在发现异常数据的可视化分析中至关重要。 提升表现力的方法： 聚焦：通过恰当的技术手段就将可视化结果中的最重要的部分重点突出。\n均衡：空间布局要合理，将重要的元素位于中心区域，其余元素均衡分布。\n简单：元素尽量简单，避免画面过于复杂。\n隐喻：尽量用人们所熟悉的某样事物去表达信息，从而使得可视化内容更加直观、易懂。\n数据按照它们之间的特征，可以大致分为以下的三类：\n数值型数据，分类型数据，有序性数据","title":"初入数据可视化"},{"content":"随便谈谈 距离上次写博客已经是一年前的事情，老博客的内容也因为自身的一些原因被丢失。同时最近在准备预推免复习时，突然发觉如果一天复习下来不进行总结，大概率第二天会忘记。 所以，为了能获得较好的复习效果，同时也是为了抓回写博客的习惯，又重新搭了个hexo的博客，希望自己能够坚持下去。 Github主题链接。 大三的遗憾 大三一年可以说是充满挑战的一年，但也是碌碌无为的一年。实习虽去了字节跳动，但发现进去依然干着搬砖的活。本以为可以写点SDK之类的，可惜因为人员缺乏，只能跑去写业务，累呀，也没有什么比较大的收获，因为除了写业务还是写业务。 于是乎，还是打算在六月的某日离职，全力准备夏令营（结果到头来是夏零营）。 不过都过去了，现在最重要还是眼前的预推免，希望自己能够坚持下来，将每日的学习总结以博客的形式呈现于此。 ","permalink":"https://runtus.top/posts/0907-%E5%BC%80%E7%AF%87%E8%AF%B4%E6%98%8E/","summary":"随便谈谈 距离上次写博客已经是一年前的事情，老博客的内容也因为自身的一些原因被丢失。同时最近在准备预推免复习时，突然发觉如果一天复习下来不进行总结，大概率第二天会忘记。 所以，为了能获得较好的复习效果，同时也是为了抓回写博客的习惯，又重新搭了个hexo的博客，希望自己能够坚持下去。 Github主题链接。 大三的遗憾 大三一年可以说是充满挑战的一年，但也是碌碌无为的一年。实习虽去了字节跳动，但发现进去依然干着搬砖的活。本以为可以写点SDK之类的，可惜因为人员缺乏，只能跑去写业务，累呀，也没有什么比较大的收获，因为除了写业务还是写业务。 于是乎，还是打算在六月的某日离职，全力准备夏令营（结果到头来是夏零营）。 不过都过去了，现在最重要还是眼前的预推免，希望自己能够坚持下来，将每日的学习总结以博客的形式呈现于此。 ","title":"保研说明"},{"content":" 这篇博客主要记录的是保研的大概过程以及作者今年从六月份到九月份的保研经历，希望能够让未来保研的学弟学妹们更清晰地了解保研的整个过程以及其中的一些避坑指南。\n本人基本情况📖 本科院校：电子科技大学/信息与软件工程学院\n均分：87.5\n排名：18/186（10%）\n四级：500\n六级：492\n无科研经历\n竞赛获得奖项\n中国软件杯国家三等奖 三创杯四川省二等奖 微信小程序开发大赛西南赛区三等奖 最终去向：电子科技大学/计算机科学与工程学院（电子信息）\n从上述基本情况可以看出，本人在本科期间不算优秀，没有任何科研经历，竞赛也是一些较小的比赛，不过好在大三时去字节跳动实习过半年，这也算是一个加分项。\n保研基本流程 总的来说，保研基本分为三个阶段：\n夏令营（六月 - 八月） 预推免（八月末 - 九月） 九推（九月 - 十月系统关闭）（这里的系统是指国家推免招生系统，后续会提到） 其中，需要注意的是前两个阶段，即夏令营和预推免。\n夏令营 夏令营是可以等效理解为高考录取的提前一批，各位学生通过学校研究生院官网了解到对应院校的夏令营信息，通过报名，学院筛选后，进入到院校夏令营中。如下的两个链接。 南京大学夏令营信息\n电子科技大学夏令营信息\n一般来说，每个高校的夏令营流程如下: 了解学院基本情况 -\u0026gt; 了解学院中的各个实验室（即了解导师） -\u0026gt; 学院组织统一面试（筛选优秀营员） -\u0026gt; 夏令营结束 注意，大多数学院的夏令营优秀营员相当于已经被学院拟录取了，所以夏令营的面试一定要提前好好准备一下，毕竟多一个offer不亏。 夏令营注意事项 一定，一定，一定要保证信息的流通！保研其实就是再打一场信息战，谁掌握的信息多，谁的优势就越大，不要有**“好麻烦啊，我不想去找消息”的想法**，要善于利用渠道去获得各个院校的夏令营的开放时间，免得错过（本人就是错过了非常多的夏令营，没有拿到保底offer，最后九推差点没书读）。\n一般来说，可以从下面两个渠道来获得各个院校夏令营信息：\n全国各地保研学生自发组织的QQ群 -\u0026gt; 每个专业的QQ群不一样，比如计算机保研交流群：605176069。 GitHub仓库：由全国各地用爱发电同学实时更新的夏令营信息集合。如下链接（可能需要梯子） 2021年CS保研夏令营通知公告\n关注微信公众号：保研夏令营 最好在夏令营阶段就联系好导师，因为越好的导师越抢手，而好的导师则是决定着你未来三年读研体验，因为在读研期间，大多数时间都是跟着自己的导师做科研/项目。\n多报几个学校的夏令营，由于现在疫情影响，基本所有院校的夏令营都是线上进行，于是没有了空间上的成本，多报几个夏令营则是多给自己选择的机会，防止到保研后期手足无措。\n预推免 预推免的举行时间一般是每年的八月中旬到九月底（开推免系统之前），和夏令营类似，各个院校会在自己的研究生院上公布对应的预推免报名时间。 预推免的流程只有两步，即初审和复试。初审是报名的研究生院老师根据学生提交的信息而进行简单的评估，而复试则和夏令营类似，由学院专家组对学生进行20分钟左右的面试。一般在面试结束后的一天到两天左右就会出结果。 预推免注意事项 和夏令营类似，要及时了解到各个学校学院的预推免报名时间，以免错过。 有些学校在夏令营时没有给出推免名额，他们把所有名额都放到了预推免上，比如电子科技大学。 同理，预推免也可以多报几个学校，如果说只报了一个学校，并且面试的时候发挥失常了，那可能就要寄了（当然在九推时也可以捡漏，后面会提到）。 九推 何为推免系统？ 在说九推之前，先说一下什么是国家推免生系统。 前面有提到，各个学院会在夏令营和预推免时发放拟录取offer，需要注意，这里只是拟录取，并不是真正的拟录取，因为这只是学院的口头offer，国家是不认的。 真正的录取则是要通过上述提到的推免系统来进行录取，它类似于高考填报志愿的系统，通过该系统进行录取的推免生，才算是真正拟录取（为何说是拟录取，因为后期如果推免生本人做了一些违反规定的事情，那会被取消资格，这里只是保证学校层次不会把你咕了） 如下所示，是推免系统的界面 正文 关于九推，如果说你在夏令营或预推免已经拿到了学校offer了，那直接根据学校要求，在志愿系统上填报对应院校即可。 可如果你之前一个offer都没拿到，或者只是在某个学校的wl（候补名单）中，那可能需要在九推的时候捡漏了。 每年都会出现学院招不满推免学生的情况，特别是近几年疫情期间，没了空间成本，这种鸽的现象越来越严重，甚至有的学校会被鸽穿，比如今年的华中科大和湖南大学。 于是，这个时候就可以捡漏了，可以从以下两种比较常见的办法捡漏： 直接联系学院的研招办，询问具体情况，有些学院你甚至没有去面试，都可以被录取，比如这次我联系的华中科大计算机学院，可惜我们学校先录取的我，于是只能放弃了。 有些学院会开二次预推免招生进行补录，冲就完事了。 有关于推免系统填报的相关流程和细节，可以参照下面的微信公众号文章。 2021推免系统填报指南\n本人保研经历 说完正常的保研流程，这里谈谈我自己的保研经历，总的来说，我的这次保研是很失败的，夏令营没有抓住机会，预推免也过分自信，导致最后九推填系统时没有完全确定的学校。\n但是，我认为还是有必要拿出来说一说，毕竟越是失败的经历，越能展示一些坑点所在，最后希望我的经历能够带给你一些帮助。\n六月 -\u0026gt; 夏令营报名进行时 -\u0026gt; 因为躺平心态而错过 基本从六月开始，各个院校的夏令营通知就陆续发出来了，可我那个时候却在忙于实习工作的离职交接，基本都到了六月二十号，我才把工作那边的事情忙完并成功离职。按道理说，这个时候去准备投递夏令营完全不迟，但是由于才从10-9-5.5的工作中解脱出来，我非常想躺平了。 所以我没有主动去找各个院校的夏令营通知，而是从我们班级保研群里（班长创建）随便了解到的几个学校中选了两所进行投递，一个中科大和南大。 中科大：由于我报名的是中科大的先研院，所以那边要求先联系导师，然后夏令营才有可能被筛选进。此时我的心想“好麻烦啊，还要找导师，不想去弄”，于是乎，我失去了参加先研院夏令营的资格。 **南大计院：**南大今年的夏令营需要先进行一轮初试，即通过网上做题来达到筛选的目的，我也收到了初试的通知，但我当时也是因为摸鱼 + 不敢去试试（我怕南大的题难）的双重心态，于是也放弃了本次南大初试（我现在回想起来，真想给我那个时候一拳，且不谈摸鱼，不敢去试完全是扯谈，因为这根本没有任何成本，试一试又不亏，说不定就过了，所以希望学弟学妹能够引以为鉴，不要害怕这些初试和面试，要相信自己） 于是六月是没有任何成果的一个月\n七月，八月 -\u0026gt; 夏令营进行时 + 预推免开始报名 七月，八月各个院校的夏令营热火朝天的进行着，但我最终只报名了电子科技大学的计算机学院的夏令营，可惜的是，学院夏令营不分配推免名额，它全部留给了预推免。通过学院的夏令营，我了解到一个实验室和我之前实习做的方向很接近，于是我便提前联系了那个实验室的老师，和实验室的学长学姐以及老师进行简单的交流后，学长学姐以及老师都比较喜欢我，于是很快就和老师达成了双向选择。\n这也是这两个月中的唯一一件好事了，但恰恰这一件事情，却间接导致了我后续夏令营以及预推免的报名。\n因为双向选择 + 所谓的听说的本校照顾政策，那个时候我的心就已经留在本校了，因为听说本校的面试只是走流程（后来的事实表面不可能是这样的），所以我更加坚信，我百分百能够留本校了。\n所以我没有报名其他任何学校的夏令营，包括八月中旬开始的预推免。\n而这将近两个月的时间，我一直在准备本校的预推免面试，这里我因为掌握信息不够充分的缘故，又吃了一次大亏。我以为我校和其他院校一样，预推免时会重点考察408的内容，于是直接从网上买了王道的408-2022考研资料抱着啃。谁想到，我们本校的预推免面试重点考察数据结构算法那一块的内容，并且只问一道题。所以，一定要保证信息的流通，当时的我应该提前去找之前面试过的学长学姐了解一下，然后再来有针对性地复习。\n九月 -\u0026gt; 预推免面试 -\u0026gt; 九推填报捡漏 由于前面所说，我因为过分信任自己能够上岸，所以只选择了本校的预推免，其他学校都没有去报名。 结果在面试当天，我拉了大跨：首先进行英语自我介绍，用英语回答了一些基本的常规问题，随后便是自己选择了一道题，我选了一道多路归并算法的时间复杂度计算，这直戳我的软肋，因为关于时间复杂度的计算我一直都是懵的，加上多路归并我也只是了解过，但是了解的不多，所以这道题最后以“毫无思路”告终，最后便是介绍自己的项目，然后回答一些项目中遇到的问题，然后就结束了。 9.26号出成绩时，看到我在本校的候补名单里，我瞬间感觉天都塌下来了，并不是因为我在候补（因为我有预料到），而是因为我没有去准备其他保底学校的offer，我那天没睡着觉，我不断安慰自己，实在找不到书读，就直接上班吧。但我内心深处是很想继续深造的，所以这样的安慰效果甚微。 在推免系统开放的那天，我从朋友那里了解到，今年华科被鸽穿了，现在去联系还来得及，这次我没有放弃这个机会，直接到华科的官网去寻找华科各个实验室的简介以及联系方式，然后开始疯狂地联系导师。我的运气还不错，联系的第二个导师告诉我，他的名额正好多出一个（因为刚好有人把他鸽了），问我有没有兴趣，我就像抓住救命稻草一样，马上把自己简历发给他，然后经过简单交流后，他同意为我留一个指标，但最关键的还是要看招办那边有没有名额，于是我马上打电话给招办询问，得知有机会后，我在志愿系统上马上填报了华中科大。 至于上图的湖南大学，也是因为在填报系统前一天得知，湖大也被鸽穿了，于是想投一投试试运气。 极限上岸 不过今年貌似我们学校计算机学院被鸽的有点惨，所以即使我在候补的第十七位，在下午三点十分的时候，招办给我打电话说，我被补录到了。我很高兴，因为我最初的想法就是能够在本校深造，于是我马上接受了我校计院的待录取（极限上岸属于是）。 不过华科在下午四点多钟的时候也决定录取我了，不过因为我已经接受了本校的录取，所以只能拒绝了。 小小地总结一下 从本人的经历来看，虽然结果差强人意，但过程却是非常失败的，千万不要有躺平或摸鱼的心态（除非你已经有确定的院校offer），我这次很大程度上就是被这种心态所影响所以导致最后一个保底offer都没有。 其次，一定要保证自己掌握到充足的信息，信息的不流通会间接导致保研的失败，比如我这次面试本校计院，就是因为没有提前去了解面试的内容，所以复习时做了许多无用功。 再者，千万不要有我是本校的，那就有照顾政策的思想，如今的社会，能力才是最根本的保证，千万不要抱有侥幸心理，努力提升自我才是根本，如果自我实力够强，还需要去担心本校有没有照顾政策吗？那直接是“手到擒来”了。 最后，千万不要放弃，即使在前两个阶段没有拿到offer，也可以尽力在九推时捡漏，因为疫情期间，海王遍地是，**很多学校在最后填报系统时都多多少少被鸽了一些名额，所以要抓住这个时机，有的学校可能会开二次预推免面试，有的学校可能给招办打电话说一下就可以了。**总之，是有书读的，关键就是看自己是否能够把握到那个补录机会了。 希望我的经历能够带给未来的保研er一些帮助，如果再给我一次保研的机会，我肯定会努力去争取夏令营和预推免，可惜没有如果。\n最后的最后，祝愿未来的保研er能够保研顺利，找到自己心仪的导师！\n需要想找我进一步交流的同学，可以通过邮箱联系我runtugo1999@gmail.com\n","permalink":"https://runtus.top/posts/%E8%B0%88%E8%B0%88%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86/","summary":"这篇博客主要记录的是保研的大概过程以及作者今年从六月份到九月份的保研经历，希望能够让未来保研的学弟学妹们更清晰地了解保研的整个过程以及其中的一些避坑指南。\n本人基本情况📖 本科院校：电子科技大学/信息与软件工程学院\n均分：87.5\n排名：18/186（10%）\n四级：500\n六级：492\n无科研经历\n竞赛获得奖项\n中国软件杯国家三等奖 三创杯四川省二等奖 微信小程序开发大赛西南赛区三等奖 最终去向：电子科技大学/计算机科学与工程学院（电子信息）\n从上述基本情况可以看出，本人在本科期间不算优秀，没有任何科研经历，竞赛也是一些较小的比赛，不过好在大三时去字节跳动实习过半年，这也算是一个加分项。\n保研基本流程 总的来说，保研基本分为三个阶段：\n夏令营（六月 - 八月） 预推免（八月末 - 九月） 九推（九月 - 十月系统关闭）（这里的系统是指国家推免招生系统，后续会提到） 其中，需要注意的是前两个阶段，即夏令营和预推免。\n夏令营 夏令营是可以等效理解为高考录取的提前一批，各位学生通过学校研究生院官网了解到对应院校的夏令营信息，通过报名，学院筛选后，进入到院校夏令营中。如下的两个链接。 南京大学夏令营信息\n电子科技大学夏令营信息\n一般来说，每个高校的夏令营流程如下: 了解学院基本情况 -\u0026gt; 了解学院中的各个实验室（即了解导师） -\u0026gt; 学院组织统一面试（筛选优秀营员） -\u0026gt; 夏令营结束 注意，大多数学院的夏令营优秀营员相当于已经被学院拟录取了，所以夏令营的面试一定要提前好好准备一下，毕竟多一个offer不亏。 夏令营注意事项 一定，一定，一定要保证信息的流通！保研其实就是再打一场信息战，谁掌握的信息多，谁的优势就越大，不要有**“好麻烦啊，我不想去找消息”的想法**，要善于利用渠道去获得各个院校的夏令营的开放时间，免得错过（本人就是错过了非常多的夏令营，没有拿到保底offer，最后九推差点没书读）。\n一般来说，可以从下面两个渠道来获得各个院校夏令营信息：\n全国各地保研学生自发组织的QQ群 -\u0026gt; 每个专业的QQ群不一样，比如计算机保研交流群：605176069。 GitHub仓库：由全国各地用爱发电同学实时更新的夏令营信息集合。如下链接（可能需要梯子） 2021年CS保研夏令营通知公告\n关注微信公众号：保研夏令营 最好在夏令营阶段就联系好导师，因为越好的导师越抢手，而好的导师则是决定着你未来三年读研体验，因为在读研期间，大多数时间都是跟着自己的导师做科研/项目。\n多报几个学校的夏令营，由于现在疫情影响，基本所有院校的夏令营都是线上进行，于是没有了空间上的成本，多报几个夏令营则是多给自己选择的机会，防止到保研后期手足无措。\n预推免 预推免的举行时间一般是每年的八月中旬到九月底（开推免系统之前），和夏令营类似，各个院校会在自己的研究生院上公布对应的预推免报名时间。 预推免的流程只有两步，即初审和复试。初审是报名的研究生院老师根据学生提交的信息而进行简单的评估，而复试则和夏令营类似，由学院专家组对学生进行20分钟左右的面试。一般在面试结束后的一天到两天左右就会出结果。 预推免注意事项 和夏令营类似，要及时了解到各个学校学院的预推免报名时间，以免错过。 有些学校在夏令营时没有给出推免名额，他们把所有名额都放到了预推免上，比如电子科技大学。 同理，预推免也可以多报几个学校，如果说只报了一个学校，并且面试的时候发挥失常了，那可能就要寄了（当然在九推时也可以捡漏，后面会提到）。 九推 何为推免系统？ 在说九推之前，先说一下什么是国家推免生系统。 前面有提到，各个学院会在夏令营和预推免时发放拟录取offer，需要注意，这里只是拟录取，并不是真正的拟录取，因为这只是学院的口头offer，国家是不认的。 真正的录取则是要通过上述提到的推免系统来进行录取，它类似于高考填报志愿的系统，通过该系统进行录取的推免生，才算是真正拟录取（为何说是拟录取，因为后期如果推免生本人做了一些违反规定的事情，那会被取消资格，这里只是保证学校层次不会把你咕了） 如下所示，是推免系统的界面 正文 关于九推，如果说你在夏令营或预推免已经拿到了学校offer了，那直接根据学校要求，在志愿系统上填报对应院校即可。 可如果你之前一个offer都没拿到，或者只是在某个学校的wl（候补名单）中，那可能需要在九推的时候捡漏了。 每年都会出现学院招不满推免学生的情况，特别是近几年疫情期间，没了空间成本，这种鸽的现象越来越严重，甚至有的学校会被鸽穿，比如今年的华中科大和湖南大学。 于是，这个时候就可以捡漏了，可以从以下两种比较常见的办法捡漏： 直接联系学院的研招办，询问具体情况，有些学院你甚至没有去面试，都可以被录取，比如这次我联系的华中科大计算机学院，可惜我们学校先录取的我，于是只能放弃了。 有些学院会开二次预推免招生进行补录，冲就完事了。 有关于推免系统填报的相关流程和细节，可以参照下面的微信公众号文章。 2021推免系统填报指南","title":"谈谈保研经历"},{"content":" 这是一篇不成体系的记录，只是为了记录一些零散的容易忘记的概念知识点\n线性表 具有相同数据类型的n（n \u0026gt;= 0）个数据元素的有限序列。 顺序表 线性表的顺序存储又称为顺序表， 即用一组连续的存储空间来存储线性表中的元素。 顺序表特点：逻辑顺序和物理顺序相同。 高级语言中，顺序表的代表为数组。 线性表的链式存储 地址没有要求连续，即要求逻辑上相邻的数据在物理存储上没有要求，数据与数据之间通过指针来进行联系。 线性表一般有两种表现方式（根据存储方式的不同）：顺序表和链表\n栈 一种特殊的线性表，不过要求只能在一端进行数据的读写（推入push和弹出pop）。 堆 计算机中一种特殊的数据结构，它通常被看作是用一棵树的数组对象。 它有两个特性： 堆一定是一颗完全二叉树（所以才可以用数组来表示） 二叉树里所有的子树的根节点都大于（或小于）它的子节点，即大根堆和小根堆的区别。 ","permalink":"https://runtus.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9D%82%E8%AE%B0/","summary":" 这是一篇不成体系的记录，只是为了记录一些零散的容易忘记的概念知识点\n线性表 具有相同数据类型的n（n \u0026gt;= 0）个数据元素的有限序列。 顺序表 线性表的顺序存储又称为顺序表， 即用一组连续的存储空间来存储线性表中的元素。 顺序表特点：逻辑顺序和物理顺序相同。 高级语言中，顺序表的代表为数组。 线性表的链式存储 地址没有要求连续，即要求逻辑上相邻的数据在物理存储上没有要求，数据与数据之间通过指针来进行联系。 线性表一般有两种表现方式（根据存储方式的不同）：顺序表和链表\n栈 一种特殊的线性表，不过要求只能在一端进行数据的读写（推入push和弹出pop）。 堆 计算机中一种特殊的数据结构，它通常被看作是用一棵树的数组对象。 它有两个特性： 堆一定是一颗完全二叉树（所以才可以用数组来表示） 二叉树里所有的子树的根节点都大于（或小于）它的子节点，即大根堆和小根堆的区别。 ","title":"数据结构-杂记"},{"content":" 网络层被设计成“向上提供简单灵活的，无连接的，尽最大努力交付的数据报服务”的特性，即所传输的分组没有保证，可能出错，丢失，重复，失序，或超时。\n但这样设置好处是：网络的造价大大降低（比如路由器），运行方式灵活，能够适应多种应用（即在网络层之上的传输层可以基于灵活的网络层作很多拓展工作）\n异构网络互联 不同协议的网络子系统通过**中间设备（中继设备）**相互连接起来，形成更大的系统。（P135） 中继设备： 物理层：中继器，集线器（Hub） 数据链路层：网桥或交换机 网络层：路由器 网络层之上：网关 路由与转发 路由器的两功能：路由选择（确定哪一条路径 =\u0026gt; 构建和维护路由表）和分组转发（当一个分组到达时要完成的动作 =\u0026gt; 查询，转发以及队列管理和任务调度等）。 拥塞控制 网络进入拥塞状态的方法：观察网络吞吐量和负载的关系。 如果随着网络负载的增加，网络的吞吐量明显小于正常吞吐量（或者不增反降），则说明可能（一定）进入了拥塞状态。（注意：正常情况下，负载越高，吞吐量越大） 拥塞控制和流量控制（联系到链路层的流量控制）的区别 流量控制是在发送端和接受端点对点通信时的数据传输控制，它数局部性控制，且是接收端来控制发送端 而拥塞控制则是一个全局性的问题，它确保的是一个子网内的数据能够成功传输到彼此。 拥塞控制的方法 开环控制：静态的预防方法，系统启动后，设置的控制调度算法不能改版。 闭环控制：动态方法，采用监测网络系统去监视，及时检测哪里发生了拥塞，然后将拥塞的信息传输到合适的地方，以便调整网络系统的运行。 路由算法 静态路由算法 =\u0026gt; 网络管理员手动配置的路由信息，它不能适应网络状态的变化。 动态路由算法 =\u0026gt; 通过路由器之间相互传递信息并且根据一定的算法，实时更新路由表的信息。 动态路由算法的两个主要算法 距离-向量路由算法 =\u0026gt; 实现协议RIP（路由信息协议） =\u0026gt; 应用层协议，使用了UDP传送数据 所有结点定期地将它们的**整个路由选择表（下面统称为路由表）**传送给其所有的相邻结点。 每个结点从相邻结点拿到路由表信息后，迭代计算到每个结点的最短距离，并实时更新自己的路由表。 链路状态路由算法 =\u0026gt; 实现协议OSPF（开放最短路径优先） =\u0026gt; 网络层协议，使用ip数据包传递数据 每个结点（路由器）向本自治系统的所有节点发送自己和自己相邻路由器之间的链路状态，即先把信 息发送给相邻的路由器，然后通过相邻的路由器再次发送给它的相邻路由器，这样不断迭代传递，最终所有结点都能获得发送结点的相邻链路状态。 =\u0026gt; 泛洪法 最后每个路由器都能获得自治系统内所有节点的相邻链路状态，然后按照一定的算法，更新自己的路由转发表。 所以该算法要求每个参与算法的结点都具有完全的网络拓扑信息。 层次路由 设想一下，如果对网络中众多的路由不分层次，则会使得每次转发的路由表（或链路信息）异常庞大，无论是更新还是查阅都会非常消耗性能，其次灵活性也不高，因为没有分层，导致整个路由系统必须统一协议标准，而不能“因地制宜”。 所以考虑把整个互联网划分为较小的自治系统（每个自治系统有多个局域网），每个较小的自治系统可以设置自己的路由协议，同时也需要自治系统间的协议来屏蔽不同路由协议自治系统的通信。 自治系统内使用的路由选择协议叫做内部网关协议（IGP） =\u0026gt; 例如RIP，OSPF等 自治系统间使用的路由选择协议叫做外部网关协议（EGP） =\u0026gt; 例如BGP等。 ipv4 ipv4分组格式如下所示 注意：有些描述存储大小的字段是有单位的，比如首部长度，总长度等，这些会在下面单独说明\n首部长度单位: 32位（4Byte） 总长度：首部加数据段的总长度，单位：Byte 片位移：由于MTU的限制，ip数据报如果过长会被分片，那么该字段则表示该片段在原分组的相对位置，用于之后在目的地拼接。长度单位：8Byte，所以每个分片的长度一定是8B的整数倍（除最后一片） 网络地址转换（NAT） 将专门网络地址转换为公用地址，从而隐藏内部管理的IP地址。这样做的好处是可以增多主机的ip分配，一个局域网的主机可以用多个内网ip标识，而它们的公网地址则只需要用一个ip标识即可，而NAT就做的是这其中的转换工作。\n即一台主机可以用 一个公网ip + 一个内网ip 唯一标识。\n实现了NAT协议的路由器也叫做NAT路由器，其中维护着NAT表。\nNAT转换表存放着**「本地ip地址：端口」 : 「全球ip地址」：端口**的映射。 ipv4几种分类方式（概述） 传统分类（A，B，C，D，E）两级分类 每个ip地址分成网络号（第一级）和主机号（第二级）两部分。根据网络号占用的位数不同，以及网络号首几位的数值不同可以分为A-E五个类别。 从上述描述可以看出，这种分类方式灵活性很差，每一类占用的网络号是固定的，如果按照网络号占用的位数来分类，实际上只能分成三类（即A，B，C三类常用ip地址）。 子网划分 两级ip地址的空间利用率有时候很低，因为网络号的位数是固定的，当给一个物理网络分配网络号后，路由表就会变得很大而使网络性能变差。 所以考虑引入子网号字段，使二级ip地址变为三级ip地址，这种做法也叫做子网划分。 子网号是从主机号中借用若干bit而形成的，所以就出现了「\u0026lt;网络号\u0026gt;，\u0026lt;子网号\u0026gt;，\u0026lt;主机号\u0026gt;」这样的结构。 需要注意的是：子网划分是一个单位内部的事情，它对于外部表现是透明的，即对外部仍然表现为没有划分子网的网络。此时需要下面描述的子网掩码来解决子网掩码的识别问题。 子网掩码 为了告诉外界主机或路由器对A，B，C类网络进行了子网划分，使用了子网掩码来表示子网号对主机号的借位。借位的位数可以通过子网掩码上的**“1”**来进行判断，即如果没有借位，则默认子网掩码为255.0.0.0，255.255.0.0，255.255.255.0. CIDR 无分类域间路由选择（CIDR） 消除了传统A，B，C类网络划分，可以更有效地分配IPv4的地址空间。 CIDR分类中的IP格式：「\u0026lt;网络前缀\u0026gt;，\u0026lt;主机号\u0026gt;」，或者使用“斜线记法”: IP地址/网络前缀。其中网络前缀对应于网络号的部分（位为1的部分）。 ARP协议 =\u0026gt; 将ip地址转化为MAC地址 当某路由器获得下一跳路由器的ip地址时，不是通过ip地址去直接访问的，而是通过ARP将ip转化为MAC地址再去访问对应的路由器地址。 DHCP 动态主机配置协议 用户主机动态地分配IP地址，它提供了即插即用的联网机制。 ICMP 网际报文控制协议 网络层使用ICMP来让主机或路由器来报告差错和异常信息。 ","permalink":"https://runtus.top/posts/0913-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"网络层被设计成“向上提供简单灵活的，无连接的，尽最大努力交付的数据报服务”的特性，即所传输的分组没有保证，可能出错，丢失，重复，失序，或超时。\n但这样设置好处是：网络的造价大大降低（比如路由器），运行方式灵活，能够适应多种应用（即在网络层之上的传输层可以基于灵活的网络层作很多拓展工作）\n异构网络互联 不同协议的网络子系统通过**中间设备（中继设备）**相互连接起来，形成更大的系统。（P135） 中继设备： 物理层：中继器，集线器（Hub） 数据链路层：网桥或交换机 网络层：路由器 网络层之上：网关 路由与转发 路由器的两功能：路由选择（确定哪一条路径 =\u0026gt; 构建和维护路由表）和分组转发（当一个分组到达时要完成的动作 =\u0026gt; 查询，转发以及队列管理和任务调度等）。 拥塞控制 网络进入拥塞状态的方法：观察网络吞吐量和负载的关系。 如果随着网络负载的增加，网络的吞吐量明显小于正常吞吐量（或者不增反降），则说明可能（一定）进入了拥塞状态。（注意：正常情况下，负载越高，吞吐量越大） 拥塞控制和流量控制（联系到链路层的流量控制）的区别 流量控制是在发送端和接受端点对点通信时的数据传输控制，它数局部性控制，且是接收端来控制发送端 而拥塞控制则是一个全局性的问题，它确保的是一个子网内的数据能够成功传输到彼此。 拥塞控制的方法 开环控制：静态的预防方法，系统启动后，设置的控制调度算法不能改版。 闭环控制：动态方法，采用监测网络系统去监视，及时检测哪里发生了拥塞，然后将拥塞的信息传输到合适的地方，以便调整网络系统的运行。 路由算法 静态路由算法 =\u0026gt; 网络管理员手动配置的路由信息，它不能适应网络状态的变化。 动态路由算法 =\u0026gt; 通过路由器之间相互传递信息并且根据一定的算法，实时更新路由表的信息。 动态路由算法的两个主要算法 距离-向量路由算法 =\u0026gt; 实现协议RIP（路由信息协议） =\u0026gt; 应用层协议，使用了UDP传送数据 所有结点定期地将它们的**整个路由选择表（下面统称为路由表）**传送给其所有的相邻结点。 每个结点从相邻结点拿到路由表信息后，迭代计算到每个结点的最短距离，并实时更新自己的路由表。 链路状态路由算法 =\u0026gt; 实现协议OSPF（开放最短路径优先） =\u0026gt; 网络层协议，使用ip数据包传递数据 每个结点（路由器）向本自治系统的所有节点发送自己和自己相邻路由器之间的链路状态，即先把信 息发送给相邻的路由器，然后通过相邻的路由器再次发送给它的相邻路由器，这样不断迭代传递，最终所有结点都能获得发送结点的相邻链路状态。 =\u0026gt; 泛洪法 最后每个路由器都能获得自治系统内所有节点的相邻链路状态，然后按照一定的算法，更新自己的路由转发表。 所以该算法要求每个参与算法的结点都具有完全的网络拓扑信息。 层次路由 设想一下，如果对网络中众多的路由不分层次，则会使得每次转发的路由表（或链路信息）异常庞大，无论是更新还是查阅都会非常消耗性能，其次灵活性也不高，因为没有分层，导致整个路由系统必须统一协议标准，而不能“因地制宜”。 所以考虑把整个互联网划分为较小的自治系统（每个自治系统有多个局域网），每个较小的自治系统可以设置自己的路由协议，同时也需要自治系统间的协议来屏蔽不同路由协议自治系统的通信。 自治系统内使用的路由选择协议叫做内部网关协议（IGP） =\u0026gt; 例如RIP，OSPF等 自治系统间使用的路由选择协议叫做外部网关协议（EGP） =\u0026gt; 例如BGP等。 ipv4 ipv4分组格式如下所示 注意：有些描述存储大小的字段是有单位的，比如首部长度，总长度等，这些会在下面单独说明\n首部长度单位: 32位（4Byte） 总长度：首部加数据段的总长度，单位：Byte 片位移：由于MTU的限制，ip数据报如果过长会被分片，那么该字段则表示该片段在原分组的相对位置，用于之后在目的地拼接。长度单位：8Byte，所以每个分片的长度一定是8B的整数倍（除最后一片） 网络地址转换（NAT） 将专门网络地址转换为公用地址，从而隐藏内部管理的IP地址。这样做的好处是可以增多主机的ip分配，一个局域网的主机可以用多个内网ip标识，而它们的公网地址则只需要用一个ip标识即可，而NAT就做的是这其中的转换工作。\n即一台主机可以用 一个公网ip + 一个内网ip 唯一标识。","title":"计算机网络-网络层"},{"content":" 链路层重点：组帧，流量控制与可靠传输机制，介质访问控制\n数据链路层是在物理层提供服务的基础上为网络层提供相关服务，它能够加强物理层中比特流的传输，也能将物理层上可能会出错的物理链路改造为逻辑上无差错的数据链路，然后为网络层提供对应服务。 为网络层提供的连接服务 无确认，无连接服务。 有确认，无连接服务。 有确认，有连接服务。 需要注意的是：只要是能够连接，则一定会有确认，即不存在无确认，有连接的服务。 帧定界 数据帧的长度由首部，尾部，以及数据三者决定，而首部和尾部包含了许多控制信息，其中就包含了帧边界的标识，这就是所谓的帧定界。（注意：链路层封装的数据帧也称为组帧，它的作用就是解决帧定界，帧同步，透明传输等问题）\n透明传输：接受方能够正确识别帧尾部，而不会因为数据段有和尾部相同的标识而提前结束帧识别。 下面列举几种帧定界的方法。\n字符计数法。 字符填充的首位定界符法。 零比特填充的首位标志法。 违规编码法。 MTU（最大传输单元）：帧数据部分长度的上线（IP数据包）\n差错控制 比特传输过程中难免会遇到差错，比如1变为0，0变为1，这种差错也称为比特差错，于是需要通过编码方式对传输的比特实现差错控制，减少或避免误差。 检错编码 =\u0026gt; 检验传输的比特是否出错 奇偶校验法 循环冗余码（CRC：Cycle Redundancy Code） 纠错编码 =\u0026gt; 对出错的比特进行纠错 =\u0026gt; 海明校验 流量控制 为了防止发送方的速度过于快而导致接受方来不及接收从而造成的丢帧现象出现，需要对发送方的发送数据速率作一定的限制，而流量控制的常见方法是通过接收方来控制发送方的速率（由接收方感知，如果速率过快，则返回特定的信息）。 常见的两种流量控制方法 停止-等待协议 ： 发送方发送一帧后，必须等待这一帧的回复才能继续发送下一帧。 滑动窗口协议：发送方维持一组能够发送帧的集合，称为发送窗口，同理接收方也维持一组预接收帧的集合，称为接受窗口。发送窗口外的帧不会发送，接收窗口外的帧不会接收。 可靠传输机制 可靠传输同时使用确认和超时传输这两种机制来完成。 确认是指发送方发送帧后，为了确保该帧顺利到达接收方且没有出错，应该要收到对应的帧回复。 超时传输指发送方发送帧后，会启动一个定时器，如果超过一定时间还没有收到回复帧，则认为帧丢失，需要重传。 自动重传请求（ARQ：Auto Repeat reQuest） 接收方通过请求发送方重传出错的帧来恢复出错的帧。它是处理信道所带来差错的办法之一。 ARQ分类 停止-等待ARQ 后退N帧ARQ（Go-Back-N：GBN） 选择性重传（Selective Repeat：SR） =\u0026gt; 接收方需具备缓存器，缓存出错帧之后已经到达接收方的帧。 介质访问控制（Medium Access Control： MAC） 为使用介质的每个设备与使用同一个介质的其它设备的通信隔离开来，简而言之，就是要保证各个通信设备在使用同一介质时互不干扰，这就是介质访问控制的作用。 常见的介质访问控制分为信道划分MAC（静态划分），随机访问MAC（动态分配），轮询访问MAC（动态分配）。 信道划分介质访问控制 顾名思义，按照某种标准，将信道划分为多个部分以供给多个通信设备使用，由于划分是固定的，所以也是静态划分信道的方法。 频分多路复用（FDM） 时分多路复用（TDM） 波分多路复用（WDM） 码分多路复用（CDM） =\u0026gt; 也叫做码分多址（CDMA：Code Division Multiple Access） 随机访问介质访问控制 ALOHA协议 =\u0026gt; 不检测，直接传，如果一段时间没收到确认，则重传。\n时隙ALOHA协议 =\u0026gt; 时间被划分为一段段等长的时隙（Slot），只能在每个时隙开始的时候才能发送。\nCSMA协议（Carrier Sense Multiple Access：载波侦听多路访问）：基于ALOHA的改进协议，主要是多了一个载波侦听装置。\n1-坚持CSMA =\u0026gt; 监听到信道空闲，就一定会发送（概率为1） 非坚持CSMA =\u0026gt; 监听到信道忙，放弃监听，过一段时间再监听 p-坚持CSMA =\u0026gt; 监听到信道空闲，概率p会发送数据，1-p概率推迟到下一个时隙（并不是下一个时隙发送） CSMA/CD协议（CD =\u0026gt; 碰撞检测） -\u0026gt; 一边发送一边监听 -\u0026gt; 适用于有线连接的局域网\n检测到碰撞后，实行指数退避算法 引出了最小帧长的概念（注意和MTU区别）：保证发送端在发送帧时能够接收到本次发送帧的数据（接收端回复），所以有最小帧长的概念。 =\u0026gt; 最小帧长 = 传播时延（单向） * 2 * 传输速率 CSMA/CA协议（CA =\u0026gt; 碰撞避免） =\u0026gt; 不能完全避免，只是降低碰撞的概率\n也有退避算法，但是和CSMA/CD不同，CD是只有碰撞时才会触发，而CA则是遵循除非站点第一次传输数据，否则都要执行对应的退避算法的原则\n隐藏站的解决方法 =\u0026gt; 预约信道\nRTS控制帧 =\u0026gt; 在发送前广播的特殊帧，请求预约\nCTS控制帧 =\u0026gt; AP广播的特殊帧，给源站允许发送的许可，同时抑制其他站点的发送。\n轮询访问介质访问控制 =\u0026gt; 令牌传递协议 ","permalink":"https://runtus.top/posts/0910-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/","summary":"链路层重点：组帧，流量控制与可靠传输机制，介质访问控制\n数据链路层是在物理层提供服务的基础上为网络层提供相关服务，它能够加强物理层中比特流的传输，也能将物理层上可能会出错的物理链路改造为逻辑上无差错的数据链路，然后为网络层提供对应服务。 为网络层提供的连接服务 无确认，无连接服务。 有确认，无连接服务。 有确认，有连接服务。 需要注意的是：只要是能够连接，则一定会有确认，即不存在无确认，有连接的服务。 帧定界 数据帧的长度由首部，尾部，以及数据三者决定，而首部和尾部包含了许多控制信息，其中就包含了帧边界的标识，这就是所谓的帧定界。（注意：链路层封装的数据帧也称为组帧，它的作用就是解决帧定界，帧同步，透明传输等问题）\n透明传输：接受方能够正确识别帧尾部，而不会因为数据段有和尾部相同的标识而提前结束帧识别。 下面列举几种帧定界的方法。\n字符计数法。 字符填充的首位定界符法。 零比特填充的首位标志法。 违规编码法。 MTU（最大传输单元）：帧数据部分长度的上线（IP数据包）\n差错控制 比特传输过程中难免会遇到差错，比如1变为0，0变为1，这种差错也称为比特差错，于是需要通过编码方式对传输的比特实现差错控制，减少或避免误差。 检错编码 =\u0026gt; 检验传输的比特是否出错 奇偶校验法 循环冗余码（CRC：Cycle Redundancy Code） 纠错编码 =\u0026gt; 对出错的比特进行纠错 =\u0026gt; 海明校验 流量控制 为了防止发送方的速度过于快而导致接受方来不及接收从而造成的丢帧现象出现，需要对发送方的发送数据速率作一定的限制，而流量控制的常见方法是通过接收方来控制发送方的速率（由接收方感知，如果速率过快，则返回特定的信息）。 常见的两种流量控制方法 停止-等待协议 ： 发送方发送一帧后，必须等待这一帧的回复才能继续发送下一帧。 滑动窗口协议：发送方维持一组能够发送帧的集合，称为发送窗口，同理接收方也维持一组预接收帧的集合，称为接受窗口。发送窗口外的帧不会发送，接收窗口外的帧不会接收。 可靠传输机制 可靠传输同时使用确认和超时传输这两种机制来完成。 确认是指发送方发送帧后，为了确保该帧顺利到达接收方且没有出错，应该要收到对应的帧回复。 超时传输指发送方发送帧后，会启动一个定时器，如果超过一定时间还没有收到回复帧，则认为帧丢失，需要重传。 自动重传请求（ARQ：Auto Repeat reQuest） 接收方通过请求发送方重传出错的帧来恢复出错的帧。它是处理信道所带来差错的办法之一。 ARQ分类 停止-等待ARQ 后退N帧ARQ（Go-Back-N：GBN） 选择性重传（Selective Repeat：SR） =\u0026gt; 接收方需具备缓存器，缓存出错帧之后已经到达接收方的帧。 介质访问控制（Medium Access Control： MAC） 为使用介质的每个设备与使用同一个介质的其它设备的通信隔离开来，简而言之，就是要保证各个通信设备在使用同一介质时互不干扰，这就是介质访问控制的作用。 常见的介质访问控制分为信道划分MAC（静态划分），随机访问MAC（动态分配），轮询访问MAC（动态分配）。 信道划分介质访问控制 顾名思义，按照某种标准，将信道划分为多个部分以供给多个通信设备使用，由于划分是固定的，所以也是静态划分信道的方法。 频分多路复用（FDM） 时分多路复用（TDM） 波分多路复用（WDM） 码分多路复用（CDM） =\u0026gt; 也叫做码分多址（CDMA：Code Division Multiple Access） 随机访问介质访问控制 ALOHA协议 =\u0026gt; 不检测，直接传，如果一段时间没收到确认，则重传。","title":"计算机网络-链路层"},{"content":" 本章主要总结操作系统中的内存管理\n随着技术的发展，内存的容量再不断增大，但是也不能把所有用户数据和程序一起装入内存，因此操作系统需要对内存空间进行合理的划分和有效的动态分配，从而提高系统的资源利用率。对内存的合理划分以及有效的动态划分就是内存管理的概念。 程序执行过程 每段程序执行前大致需要经过三个过程：编译 -\u0026gt; 链接 -\u0026gt; 装入 编译：将源代码通过编译器编译为一个个目标模块。 链接：将每个目标模块和所需库函数链接起来，形成一个完整的装入模块。 静态链接（装入前链接），即在装入内存之前把所有的模块和对应的库函数进行链接从而形成一个可执行程序，以后不会再拆开。 装入时动态链接，即在装入内存时，一边装入一边链接。 运行时动态链接，即在执行对应模块代码时，实时链接。 装入：将链接后形成的模块装入内存中。 绝对装入 =\u0026gt; 程序相对地址和实际装入的物理地址相同。 可重定位装入 =\u0026gt; 程序相对地址加一个重定位地址形成实际的物理地址。 动态运行时装入 =\u0026gt; 在执行对应的模块时，才开始执行地址转换，地址转换的偏移量则从重定位寄存器中取出。 内存分配管理方式 连续分配方式：用户程序被分配进一个连续的内存空间 单一连续分配方式: 整个内存中只运行一道用户程序。 固定分区分配 内存被划分为若干个固定大小的区域。当有程序需要装入内存时，从分区说明表上寻找合适的内存区域并分配给它。 动态分区分配 =\u0026gt; 不预先对内存进行分区，而是等程序装入内存时动态分区。 首次适应算法 最佳适应算法 最坏适应算法 邻近适应算法（首次适应算法的改进，即下一次分配内存是从上一次分配内存结束位置开始） 区分内部碎片还是外部碎片的关键在于：内存分区是提前分好还是运行时实时分配的。\n对于前者，很容易理解每个内存分区就可以称之为“内”，所以就有了内部碎片的说话。\n对于后者，由于没有提前分区，所以自然没有“内”的概念，那么所有的内存都是“外”，所以此时产生的碎片也称为外部碎片。\n即固定分区会产生内部碎片，动态分区会产生外部碎片。\n非连续分配方式 基本分页存储管理方式 =\u0026gt; 一维表示即可，即给定一个地址，便可以算出它的页号以及偏移地址（因为页的大小是确定的） 基本分段存储管理方式 =\u0026gt; 二维表示，因为每段的大小不同，导致一个地址无法算出其它信息，段号和段内位移地址要显式给出 段页式存储管理方式 =\u0026gt; 对代码分段，对内存分页。 分页系统和分段系统的共同之处：\n它们都有对应的“表”，分页系统是页表，分段系统是段表。当然对于表来说也有对应的寄存器（页表/段表寄存器） 它们都可以加入**快表（联想存储器 TLB）**来提高地址转移效率。 不同之处：\n分页系统的地址可以进行一维表示，而分段系统的地址需要二维表示。 分段系统中的每段是具有一定逻辑意义的代码集合（比如一块函数定义），方便代码共享。 虚拟内存 局部性原理 =\u0026gt; 高速缓存技术依赖的原理 时间局部性：程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问，不久后该数据可能再次被访问。产生时间局部性的原因是程序中往往含有大量的循环操作 空间局部性：一旦程序访问了某个存储单元，不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在某个区域。 虚拟存储器 根据局部性原理，程序装入时，可以只将程序的部分装入，其余部分留在外存。程序执行过程中，若程序不在内存中，则从外存中调入对应部分的程序代码，然后继续执行程序。另一方面，操作系统也把不再执行的代码重新换出到外存（实际情况是如果代码段没有被修改，则直接丢弃）。这样，系统好像就为用户提供了一个比内存大的多的存储器，称其为虚拟存储。\n实现方式\n请求分页存储管理 请求分段存储管理 请求段页式存储管理 它们都需要的硬件支持：\n一定的内外存。\n地址转换机构。\n中断机构（程序访问部分不在内存时，发生缺页/段中断）\n页表（段表）机制。\n特别说明下页表机制（这里以页表存储管理为例），由于程序在运行时有部分在外存（不像之前直接全部调入），于是需要标记外存的程序段的地址。\n另一方面，为了分辨对应页的代码是否在内存中，还需要一个状态位来进行说明。除此之外，为了优化调入换出次数，提高执行效率，则还需要设置访问字段以及修改位。\n那么上述的字段设置在哪里设置比较好呢？显而易见页表是最适合的位置，即给页表增加几个状态位专门安放上述的几种状态字。\n页面置换算法 最佳置换算法（OPT） 先进先出算法（FIFO）=\u0026gt; 可能会出现Belady异常，即分配物理块数越多，缺页次数反而越大。 最近最久未使用（LRU）置换算法 时钟（CLOCK）置换算法 =\u0026gt; 最近未使用算法（NRU） 改进型CLOCK算法 改进型CLOCK算法主要是增加了修改位的判断，即优先换出没有修改的内存页（可以直接扔掉而不是写回外存） 页面分配策略 系统必须考虑给特定的进程分配几个页框比较合适。 分配算法 固定分配局部置换 可变分配全局置换 可变分配局部置换 从何处调入页面 在外存上分为文件区（存放文件）和对换区（存放对换页面）。\n文件区：采用离散分配方式，读写速度相对较慢。\n对换区：采用连续分配方式，读写速度相对较快。\n如果对换区足够大，则操作系统在程序执行之前把需要调入的页面从文件区复制到对换区。 如果对换区大小有限，则不会修改的文件都从文件区调入（因为不用写回），可能会被修改的则复制到对换区。这样可以提高写回速度。 抖动： 进程执行过程中，如果换页的时间超过了执行时间，则判断其发生了抖动。 抖动的解决方法：工作集。 ","permalink":"https://runtus.top/posts/0909-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"本章主要总结操作系统中的内存管理\n随着技术的发展，内存的容量再不断增大，但是也不能把所有用户数据和程序一起装入内存，因此操作系统需要对内存空间进行合理的划分和有效的动态分配，从而提高系统的资源利用率。对内存的合理划分以及有效的动态划分就是内存管理的概念。 程序执行过程 每段程序执行前大致需要经过三个过程：编译 -\u0026gt; 链接 -\u0026gt; 装入 编译：将源代码通过编译器编译为一个个目标模块。 链接：将每个目标模块和所需库函数链接起来，形成一个完整的装入模块。 静态链接（装入前链接），即在装入内存之前把所有的模块和对应的库函数进行链接从而形成一个可执行程序，以后不会再拆开。 装入时动态链接，即在装入内存时，一边装入一边链接。 运行时动态链接，即在执行对应模块代码时，实时链接。 装入：将链接后形成的模块装入内存中。 绝对装入 =\u0026gt; 程序相对地址和实际装入的物理地址相同。 可重定位装入 =\u0026gt; 程序相对地址加一个重定位地址形成实际的物理地址。 动态运行时装入 =\u0026gt; 在执行对应的模块时，才开始执行地址转换，地址转换的偏移量则从重定位寄存器中取出。 内存分配管理方式 连续分配方式：用户程序被分配进一个连续的内存空间 单一连续分配方式: 整个内存中只运行一道用户程序。 固定分区分配 内存被划分为若干个固定大小的区域。当有程序需要装入内存时，从分区说明表上寻找合适的内存区域并分配给它。 动态分区分配 =\u0026gt; 不预先对内存进行分区，而是等程序装入内存时动态分区。 首次适应算法 最佳适应算法 最坏适应算法 邻近适应算法（首次适应算法的改进，即下一次分配内存是从上一次分配内存结束位置开始） 区分内部碎片还是外部碎片的关键在于：内存分区是提前分好还是运行时实时分配的。\n对于前者，很容易理解每个内存分区就可以称之为“内”，所以就有了内部碎片的说话。\n对于后者，由于没有提前分区，所以自然没有“内”的概念，那么所有的内存都是“外”，所以此时产生的碎片也称为外部碎片。\n即固定分区会产生内部碎片，动态分区会产生外部碎片。\n非连续分配方式 基本分页存储管理方式 =\u0026gt; 一维表示即可，即给定一个地址，便可以算出它的页号以及偏移地址（因为页的大小是确定的） 基本分段存储管理方式 =\u0026gt; 二维表示，因为每段的大小不同，导致一个地址无法算出其它信息，段号和段内位移地址要显式给出 段页式存储管理方式 =\u0026gt; 对代码分段，对内存分页。 分页系统和分段系统的共同之处：\n它们都有对应的“表”，分页系统是页表，分段系统是段表。当然对于表来说也有对应的寄存器（页表/段表寄存器） 它们都可以加入**快表（联想存储器 TLB）**来提高地址转移效率。 不同之处：\n分页系统的地址可以进行一维表示，而分段系统的地址需要二维表示。 分段系统中的每段是具有一定逻辑意义的代码集合（比如一块函数定义），方便代码共享。 虚拟内存 局部性原理 =\u0026gt; 高速缓存技术依赖的原理 时间局部性：程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问，不久后该数据可能再次被访问。产生时间局部性的原因是程序中往往含有大量的循环操作 空间局部性：一旦程序访问了某个存储单元，不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在某个区域。 虚拟存储器 根据局部性原理，程序装入时，可以只将程序的部分装入，其余部分留在外存。程序执行过程中，若程序不在内存中，则从外存中调入对应部分的程序代码，然后继续执行程序。另一方面，操作系统也把不再执行的代码重新换出到外存（实际情况是如果代码段没有被修改，则直接丢弃）。这样，系统好像就为用户提供了一个比内存大的多的存储器，称其为虚拟存储。\n实现方式\n请求分页存储管理 请求分段存储管理 请求段页式存储管理 它们都需要的硬件支持：","title":"操作系统-2"},{"content":" 在复试时，很少问及计算题，大多数都是的问题都是和概念直接相关，所以要深刻理解操作系统各个组成部分的概念。\n本篇主要归纳操作系统的基本概念以及进程相关概念和算法\n操作系统基本概念 首先需要知道操作系统在整个计算机系统中的定位：\n​\t计算机系统大致可以分为四个部分（自底向上）：计算机硬件 -\u0026gt; 操作系统 -\u0026gt; 应用程序软件 -\u0026gt; 用户。\n从上述结构可以轻易看到，操作系统管理着计算机的各个硬件，具体表现为对资源的合理调度，分配等，同时也为上层应用程序软件提供抽象出来的硬件功能。\n综上所述，操作系统可以定义为控制和管理整个计算机的硬件和软件资源，并合理地组织，分配资源、调度工作，进而为用户和其它软件提供方便接口与环境的程序集合。 提炼一下，操作系统就是一系列程序的集合，不过这些程序有着上述管理功能。\n特征（四大特征） 并发 =\u0026gt; 注意并发和并行的区别。 共享 （两种共享方式，也对应着后续会提到的资源共享形式） 互斥共享 同时访问 虚拟 =\u0026gt; 用逻辑的对应物去映射实际的物理设备，让用户在使用时感觉是在真正使用物理设备。 经典例子: 请求分页系统，SPOOLing技术 异步 =\u0026gt; 进程以不可预知的速度向前执行（进程的异步性） 异步也是操作系统中需要进程控制的原因之一，因为要保证怎么个异步法，各个进程的最终结果都一样。 其中，**并发和共享是其它特性的基础，**它们两也相互依存。\n管理的计算机资源（包括硬件和软件）分类 处理机管理 =\u0026gt; 进程的调度与分配 存储器管理 =\u0026gt; 内存管理 文件管理 =\u0026gt; 文件的存储形式：逻辑存储和物理存储 I/O设备管理 =\u0026gt; 外存相关概念以及相关管理 运行环境 CPU的状态分为两类：用户态（目态）和核心态（管态） 用户的程序运行在目态，而操作系统的内核运行在管态。有一些特殊的特权指令，只有在CPU处于管态时才能调用。 特权指令 -\u0026gt; 操作系统不允许用户直接调用的指令，比如I/O指令，置中断指令等等。 如果说用户程序必须使用特权指令的功能，则需要通过中断或异常操作来达到目的，即发生中断或异常时，CPU状态会从用户态转向核心态。 中断和异常 操作系统的发展过程大体上就是一个想法设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源释放，而这一行为就需要通过中断来实现。\n中断（外中断）：CPU执行指令以外的事情发生而引起的中断，即外中断不是由指令本身引起的（比如访问数组越界等），而是外界因素导致的（比如I/O中断，时间片中断），它和当前处理机正在运行的程序有关。\n异常（内中断，陷入trap）：CPU执行指令时发生的错误异常事件。比如地址越界，请求分页系统的缺页以及专门的陷入指令（这个也是上述用户能够主动进入核心态的办法，也称为系统调用）。\n​\t系统调用的本质是用户把CPU的使用权交给了操作系统内核的程序，然后让内核程序去执行对应的特权指令，等执行完毕后，再把使用权返回。即关键指令的调用实质还是内核调用而不是用户直接调用。\n进程管理 基本概念 在多道程序运行的系统中，由于程序直接“暴露在内存里”，所以导致程序没有封闭性，它们能够彼此看见对方内部的结构，甚至调用，这显然是不行的。于是为了方便描述程序和控制程序的并发，体现操作系统的并发性和共享性，所以引入了进程的概念。 进程（动态的）：是程序的一次执行过程（进程实体的运行过程），是CPU资源分配和调度的基本单位（引入线程之前） PCB（Process Control Block） 程序段 相关数据段 状态 创建态 就绪态 运行态 终止态 阻塞态 它们各自的定义这里不再描述。 需要说明的是，当进程从运行态变换到阻塞态时，是一个主动的行为（即自己需要去请求某个外设资源或等待某一事件发生而引起的阻塞），这是一种特殊的，由运行的用户态程序去调用操作系统内核过程的形式。 而从阻塞态转移到就绪态，这是一个被动过程，因为它需要外界信号进行触发。例如请求的外设已经完成了对应的任务，或是请求的某个资源已经空闲出来等。 进程通信 共享存储空间通信 -\u0026gt; 多个进程共享内存中的某块空间，当需要通信时，在内存中进行读写即可。 消息传递 -\u0026gt; 调用操作系统提供的消息传递方法进行进程通信，即通过发送消息和接受消息两个原语进行通信。 直接通信，即发送进程直接把消息发送给接收消息进程。 间接通信，即发送进程把消息发送给某个中间实体，使其成为一个信箱，而接受进程直接从实体中取消息即可，反之亦然。 管道通信 -\u0026gt; 由pipe文件来连接发消息进程和接受消息进程从而达到通信的目的。（消息查看2022王道考研操作系统P35） 线程 由于进程的切换会有较大的时空开销，于是考虑引入线程，从而提高系统的并发性能（因为线程切换所引起的时空开销要远远小于进程）。\n线程是轻量级的进程，它是CPU的执行单位。需要值得注意的是，**线程本身不占有资源，它共享它所在的进程的资源，**即进程的资源被它拥有的线程所共享。 在引入线程的系统里，进程仅仅作为系统资源分配的基本单位，而线程则成为了处理机的分配单元。 实现方式 用户级线程（User-Level Thread: ULT） 线程的管理全部由用户程序来实现，内核意识不到线程的存在。 内核级线程（Kernel-Level Thread: KLT) 线程的管理工作全部由内核实现，内核为每个线程维护乡下问信息，应用程序不能直接管理线程，只能通过内核级线程接口来进行相关操作。 处理机调度 在系统中，进程的数量绝大多数时候都大于处理机的数量，所以如何分配处理机给进程使用成为了一大难点，如果分配不合理，不仅会极大影响系统的运行效率和资源利用率，严重情况下甚至会造成死锁。\n而处理机的调度则是对处理机进行合理的分配，它执行某种公平的算法从而使得处理机能够合理分配给各个进程，以实现进程的并发执行。\n调度的层次 高级调度 -\u0026gt; 作业调度，即把作业从外存调入内存中。 中级调度 -\u0026gt; 内存调度，作用是提高内存的利用率，当某些进程不能运行时，可以暂时将其调至外存，从而实现资源的释放（此时，该进程的状态也称为挂起态） 低级调度（进程调度）。按照某种方法或策略从就绪队列中选择对应的进程，并将处理机分配给它。 调度方式（注意和后面的算法区别） 非剥夺式调度（非抢占调度） 剥夺式调度（抢占式调度） =\u0026gt; 剥夺不是任意性行为，而需要遵循某种原则，这种原则就是后面要提到的调度算法。 调度的衡量标准 这里不一一列举全部标准，只说明几个简单准则\n周转时间：作业从提交到完成的全过程时间 带权周转时间：周转时间 / 作业实际运行时间 。 =\u0026gt; 因为在整个周转时间里，作业除了运行时间，还有等待时间。 等待时间：作业处于等处理机状态的时间总和（创建，就绪，阻塞）。 这里等待时间和上述周转时间中提到的等待时间是同一回事，同时该指标也是衡量算法优劣的重要标准。 响应时间：作业从提交到系统首次响应所经历的时间。 调度算法（重点） 先到先服务（FCFS：First Come First Serve） 短作业优先（SJF：Short Job First） 优先级调度算法 为每个作业进程设置优先级，根据优先级高级来进行调度。 优先度有静态优先级和动态优先级两种分类。注意把这里的动态优先级和下述的高响应比做对比 高响应比有限调度算法 响应比计算 R = (等待时间 + 要求服务时间) / 要求服务时间 从上述公示可以看出：对于短作业，要求服务时间小，R比较大，优先级一开始较高；对于长作业，虽然一开始R较低，随着时间的推迟，等待时间变大，R随之增大。所以它对于短，长作业都是相对公平的。 时间片轮转调度算法 多级反馈队列调度算法 设置多个时间片队列，每个队列内的分配的时间片相同，每个队列之间从第一队列到第n队列分配的时间片依次增大，作业从第一队列开始执行，如果没执行完，则放置下一队列继续执行，依此类推，直到最后一个队列。 需要注意的是，第1 - 第n-1队列对内调度算法为FCFS，第n队列调度算法为时间片轮转算法。 进程同步 相关概念 在多道程序系统中，进程是并发执行的，不同进程之间存在着不同的制约关系，为了能够较好的协调这种制约关系，从而引入了进程同步的概念\n临界资源 同一段时间内只能被一个进程访问的资源。 临界区 访问临界资源的代码区。 同步（直接制约关系） 共同完成同一个任务的多个进程之间，在执行任务的某个阶段，需要某种制约关系让它们相互等待，相互传递消息从而使得多个进程能够按照一定速度，并以正确顺序去完成该作业，这种制约关系就称为同步。 互斥（间接制约关系） 一个进程进入到临界区使用临界资源时，另一个进程必须等待，直到前一个进程退出临界区。 四大准则： 空闲让进 忙则等待 有限等待 让权等待 实现临界区互斥的方法 软件实现方法（王道考研P76） 硬件实现方法 中断屏蔽方法（开关中断） 硬件指令方法（即设置原子操作去访问临界区） 信号量 信号量是一种功能较强的机制，它能够用来解决互斥和同步的问题，它只能被wait(S)和signal(S)两个原语访问。 管程 计算机中的软件资源或硬件资源，都可以用某种数据结构的特性抽象地描述其特性。即用少量的信息和对对资源的操作来表征某种资源。\n管程：代表共享数据的数据结构，以及对共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程。 =\u0026gt; 相当于把共享数据的数据结构以及对它的一系列操作抽象出来，抽象成一组管理程序，而这组管理程序就叫做管程，它能够保持进程互斥，无序程序员手动实现互斥。 死锁 当有多个进程持有一定资源时又去争夺其它进程持有的不可剥夺资源，此时便发生了死锁。\n死锁：多个进程因争夺资源而造成的一种僵局（互相等待），若无外力作用，则程序无法继续执行下去。 死锁产生的必要条件 互斥条件：资源的互斥性。 不可剥夺条件：不可剥夺资源。 请求并保持条件：每个进程在持有资源的同时又去请求别的进程持有的资源。 循环等待条件。 死锁处理的策略 预防死锁 关于死锁的预防，只要打破上述四个必要条件之一，便可以预防死锁。 =\u0026gt; 王道P124 死锁避免 和预防死锁不同的是，预防死锁是在进程执行之前进行一系列操作，而死锁避免是在进程运行过程中（资源动态分配过程中），防止系统进入不安全状态。 解决方法：银行家算法 死锁检测和解除 检测采用资源分配图辅助分析。 死锁的接触有以下方法可以参考。 资源剥夺法 =\u0026gt; 剥夺死锁进程的资源，把它挂起 撤销进程法 =\u0026gt; 强制撤销部分或全部死锁进程，释放资源 进程回退法 =\u0026gt; 将一个（或多个）死锁进程回退到发生死锁之前。 进程部分结束\n","permalink":"https://runtus.top/posts/0908-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"在复试时，很少问及计算题，大多数都是的问题都是和概念直接相关，所以要深刻理解操作系统各个组成部分的概念。\n本篇主要归纳操作系统的基本概念以及进程相关概念和算法\n操作系统基本概念 首先需要知道操作系统在整个计算机系统中的定位：\n​\t计算机系统大致可以分为四个部分（自底向上）：计算机硬件 -\u0026gt; 操作系统 -\u0026gt; 应用程序软件 -\u0026gt; 用户。\n从上述结构可以轻易看到，操作系统管理着计算机的各个硬件，具体表现为对资源的合理调度，分配等，同时也为上层应用程序软件提供抽象出来的硬件功能。\n综上所述，操作系统可以定义为控制和管理整个计算机的硬件和软件资源，并合理地组织，分配资源、调度工作，进而为用户和其它软件提供方便接口与环境的程序集合。 提炼一下，操作系统就是一系列程序的集合，不过这些程序有着上述管理功能。\n特征（四大特征） 并发 =\u0026gt; 注意并发和并行的区别。 共享 （两种共享方式，也对应着后续会提到的资源共享形式） 互斥共享 同时访问 虚拟 =\u0026gt; 用逻辑的对应物去映射实际的物理设备，让用户在使用时感觉是在真正使用物理设备。 经典例子: 请求分页系统，SPOOLing技术 异步 =\u0026gt; 进程以不可预知的速度向前执行（进程的异步性） 异步也是操作系统中需要进程控制的原因之一，因为要保证怎么个异步法，各个进程的最终结果都一样。 其中，**并发和共享是其它特性的基础，**它们两也相互依存。\n管理的计算机资源（包括硬件和软件）分类 处理机管理 =\u0026gt; 进程的调度与分配 存储器管理 =\u0026gt; 内存管理 文件管理 =\u0026gt; 文件的存储形式：逻辑存储和物理存储 I/O设备管理 =\u0026gt; 外存相关概念以及相关管理 运行环境 CPU的状态分为两类：用户态（目态）和核心态（管态） 用户的程序运行在目态，而操作系统的内核运行在管态。有一些特殊的特权指令，只有在CPU处于管态时才能调用。 特权指令 -\u0026gt; 操作系统不允许用户直接调用的指令，比如I/O指令，置中断指令等等。 如果说用户程序必须使用特权指令的功能，则需要通过中断或异常操作来达到目的，即发生中断或异常时，CPU状态会从用户态转向核心态。 中断和异常 操作系统的发展过程大体上就是一个想法设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源释放，而这一行为就需要通过中断来实现。\n中断（外中断）：CPU执行指令以外的事情发生而引起的中断，即外中断不是由指令本身引起的（比如访问数组越界等），而是外界因素导致的（比如I/O中断，时间片中断），它和当前处理机正在运行的程序有关。\n异常（内中断，陷入trap）：CPU执行指令时发生的错误异常事件。比如地址越界，请求分页系统的缺页以及专门的陷入指令（这个也是上述用户能够主动进入核心态的办法，也称为系统调用）。\n​\t系统调用的本质是用户把CPU的使用权交给了操作系统内核的程序，然后让内核程序去执行对应的特权指令，等执行完毕后，再把使用权返回。即关键指令的调用实质还是内核调用而不是用户直接调用。\n进程管理 基本概念 在多道程序运行的系统中，由于程序直接“暴露在内存里”，所以导致程序没有封闭性，它们能够彼此看见对方内部的结构，甚至调用，这显然是不行的。于是为了方便描述程序和控制程序的并发，体现操作系统的并发性和共享性，所以引入了进程的概念。 进程（动态的）：是程序的一次执行过程（进程实体的运行过程），是CPU资源分配和调度的基本单位（引入线程之前） PCB（Process Control Block） 程序段 相关数据段 状态 创建态 就绪态 运行态 终止态 阻塞态 它们各自的定义这里不再描述。 需要说明的是，当进程从运行态变换到阻塞态时，是一个主动的行为（即自己需要去请求某个外设资源或等待某一事件发生而引起的阻塞），这是一种特殊的，由运行的用户态程序去调用操作系统内核过程的形式。 而从阻塞态转移到就绪态，这是一个被动过程，因为它需要外界信号进行触发。例如请求的外设已经完成了对应的任务，或是请求的某个资源已经空闲出来等。 进程通信 共享存储空间通信 -\u0026gt; 多个进程共享内存中的某块空间，当需要通信时，在内存中进行读写即可。 消息传递 -\u0026gt; 调用操作系统提供的消息传递方法进行进程通信，即通过发送消息和接受消息两个原语进行通信。 直接通信，即发送进程直接把消息发送给接收消息进程。 间接通信，即发送进程把消息发送给某个中间实体，使其成为一个信箱，而接受进程直接从实体中取消息即可，反之亦然。 管道通信 -\u0026gt; 由pipe文件来连接发消息进程和接受消息进程从而达到通信的目的。（消息查看2022王道考研操作系统P35） 线程 由于进程的切换会有较大的时空开销，于是考虑引入线程，从而提高系统的并发性能（因为线程切换所引起的时空开销要远远小于进程）。","title":"操作系统-1"},{"content":"123 ","permalink":"https://runtus.top/friends/","summary":"123 ","title":""},{"content":"","permalink":"https://runtus.top/ncm/","summary":"","title":""},{"content":"npm发包相关的packagejson配置说明 将自己的项目上传至npm上时，需要正确设置packagejson中的相关字段，否则会导致上传的项目无法正确在其他地方引用，甚至无法上传至npm官网。\n1. name name是整个项目的名称，也是在npm仓库中的唯一索引，当别人下载自己上传的npm包时，其关键字索引便是项目名称。 yarn add axios # axios 便是项目名称 2. version version是版本号，它是一个字符串，每次发版时都要更新该字段。 版本号的编写遵循语义化版本 2.0.0 规范，即**「主版本号. 次版本号. 修订号」** 3. main 指定加载的入口文件，node端和web端都可以使用，当外部使用require来引入npm包时，main指定的文件将以module.export的形式对外暴露。 所以一般情况下，main文件都会指向commonjs规范的文件，如下所示。 mjs文件代表commonjs规范的js文件。 { \u0026#34;main\u0026#34;: \u0026#34;dist/index.cjs\u0026#34; } 4. module 与main不同的是，module指定的是ESM规范的文件入口，web端和node端都可以使用，如果npm包导出的是ESM规范的包，则需要该字段来指定入口文件。 mjs代表是ESM规范的js文件。 { \u0026#34;module\u0026#34;: \u0026#34;dist/index.mjs\u0026#34; } 5. type type用于指定该node项目遵循ESM规范还是Commonjs规范，默认为commonjs项目，若要设置项目为ESM规范，则需要赋值module。 { \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34; } 同时当项目是ESM规范时，需要指定入口文件，即设置module字段。 6. types 指定声明文件位置，即d.ts文件。 7. files files字段接收一个数组，用来指明在发布npm包时，哪些文件需要上传至npm服务器上。或者说，用来描述当把 npm 包作为依赖包安装时需要说明的文件列表。 需要说明的是，如果有文件不想上传到npm服务器上，可以用.npmignore来说明哪些文件不需要上传（和.gitignore类似） ","permalink":"https://runtus.top/posts/packagejson%E6%95%B0%E6%8D%AE%E9%A1%B9/","summary":"npm发包相关的packagejson配置说明 将自己的项目上传至npm上时，需要正确设置packagejson中的相关字段，否则会导致上传的项目无法正确在其他地方引用，甚至无法上传至npm官网。\n1. name name是整个项目的名称，也是在npm仓库中的唯一索引，当别人下载自己上传的npm包时，其关键字索引便是项目名称。 yarn add axios # axios 便是项目名称 2. version version是版本号，它是一个字符串，每次发版时都要更新该字段。 版本号的编写遵循语义化版本 2.0.0 规范，即**「主版本号. 次版本号. 修订号」** 3. main 指定加载的入口文件，node端和web端都可以使用，当外部使用require来引入npm包时，main指定的文件将以module.export的形式对外暴露。 所以一般情况下，main文件都会指向commonjs规范的文件，如下所示。 mjs文件代表commonjs规范的js文件。 { \u0026#34;main\u0026#34;: \u0026#34;dist/index.cjs\u0026#34; } 4. module 与main不同的是，module指定的是ESM规范的文件入口，web端和node端都可以使用，如果npm包导出的是ESM规范的包，则需要该字段来指定入口文件。 mjs代表是ESM规范的js文件。 { \u0026#34;module\u0026#34;: \u0026#34;dist/index.mjs\u0026#34; } 5. type type用于指定该node项目遵循ESM规范还是Commonjs规范，默认为commonjs项目，若要设置项目为ESM规范，则需要赋值module。 { \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34; } 同时当项目是ESM规范时，需要指定入口文件，即设置module字段。 6. types 指定声明文件位置，即d.ts文件。 7. files files字段接收一个数组，用来指明在发布npm包时，哪些文件需要上传至npm服务器上。或者说，用来描述当把 npm 包作为依赖包安装时需要说明的文件列表。 需要说明的是，如果有文件不想上传到npm服务器上，可以用.npmignore来说明哪些文件不需要上传（和.gitignore类似） ","title":""}]