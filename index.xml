<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Runtus</title>
    <link>https://runtus.top/</link>
    <description>Recent content on Runtus</description>
    <image>
      <url>https://lao-lan-go.oss-cn-beijing.aliyuncs.com/highQua/pixiv34.JPG</url>
      <link>https://lao-lan-go.oss-cn-beijing.aliyuncs.com/highQua/pixiv34.JPG</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 23 Aug 2023 10:12:13 +0800</lastBuildDate><atom:link href="https://runtus.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>迭代器and生成器</title>
      <link>https://runtus.top/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8and%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Wed, 23 Aug 2023 10:12:13 +0800</pubDate>
      
      <guid>https://runtus.top/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8and%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>很多的数据结构都具备迭代的性质，但是不同的数据结构的迭代方法有所不同，往往需要知道具体的数据结构来选择对应的迭代方法，例如数组的迭代可以通过索引来进行迭代。
为了统一迭代接口，使得我们可以不了解具体的数据结构的前提下也能进行迭代，所以有了迭代器这么一个概念，而生成器则是基于迭代器的一种能够控制函数流程的方法，生成器基于迭代器的原理运行，反过来生成器也能够快速构建迭代器。
迭代器 当需要对某个迭代对象进行迭代处理时，由于迭代之前需要事先知道如何使用数据结构，以及遍历顺序并不是数据结构固有的，所以想寻求某种机制去统一迭代过程，对每一种可迭代类型，都用同一种迭代方法，从而增加开发体验。（即无需事先知道如何迭代去实现迭代操作） 于是基于以上原因，诞生了迭代器概念，意在统一化所有迭代对象的处理方式。 可迭代协议 一个对象是可迭代对象，则需要暴露一个属性作为默认迭代器，并且该属性的key为Symbol.iterator，它的value是一个工厂函数，用于返回一个新迭代器。 js提供了一系列可以对可迭代对象进行操作的原生结构，如下图所示。 for-of 数组解构 扩展操作符号（即...) Array.from 创建集合 创建映射 Promise.all()接受由Promise组成的可迭代对象。 Promise.rice()接受由期约组成的可迭代对象。 yield*操作符，在生成器中使用。 上述谈到的原生结构在对可迭代对象进行操作时，会默认调用工厂函数生成一个迭代器，然后对迭代器进行操作。 迭代器协议 1. next和IteratorResult 可迭代协议描述了一个对象具有可迭代性质的要求和前提，而迭代器协议则是用于规范迭代器具有的性质和方法。 迭代器对象具有一个方法next，通过迭代器APInext()能够在可迭代对象中遍历数据，每次调用next都能获取到一个IteratorResult对象，其中包含迭代器返回的下一个值，如下所示。 const array = [1, 2, 4]; // 迭代器对象 const iter = array[Symbol.iterator](); console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) console.log(iter.next()) // output // { value: 1, done: false } // { value: 2, done: false } // { value: 4, done: false } // { value: undefined, done: true } // { value: undefined, done: true } 如上的输出结果所示，IteratorResult包含两个属性value和done，value表示本次迭代获取的值，而done则表示迭代是否结束，这从另一个角度也说明迭代器只能通过next方法来获取迭代器的当前位置。 2.</description>
    </item>
    
    <item>
      <title>Web components</title>
      <link>https://runtus.top/posts/webcomponents/</link>
      <pubDate>Thu, 03 Aug 2023 10:12:13 +0800</pubDate>
      
      <guid>https://runtus.top/posts/webcomponents/</guid>
      <description>Web-Components Web-Components是一项标准，规范，目前它包含了三项主要技术：
Custom Elements自定义元素：（标签）它是一组JavaScript API，能够自定义Element以及其行为。 Shadow DOM影子DOM。 HTML templatesHTML模板：通过&amp;lt;template&amp;gt;和&amp;lt;slot&amp;gt;元素编写不在呈现页面中显示的标记模板。 通过这三个特性的共同作用能够创建封装功能的定制元素，在说明Web-Component的用法之前，先简单说明上述三项特性。
Custom Elements 自定义元素是Web Components中的一个重要特性，它能够让开发者将HTML页面（或者页面中的某个功能）封装为custom elements，从而达到复用的目的。目前支持custom elements的浏览器有FireFox，Chrome，Opera。
Custom Elements的管理是通过CustomElementRegistry接口进行操作的，其用于处理Web文档中的custom elements，同时它还提供注册自定义元素和查询已注册元素的方法，它的实例通过window.customElements属性来获得。
CustomElementRegistry接口有四个方法：
CustomElementRegistry.define()：定义一个新的自定义元素。 CustomElementRegistry.get()：返回指定自定义元素的构造函数，如果未自定义元素，则返回undefined。 CustomElementRegistry.upgrade(): 更新一个自定义元素。 CustomElementRegistry.whenDefined()：执行并返回一个已经定义的自定义元素的promise，即如果定义了这么一个元素，那么返回对应的promise。 CustomElementRegistry.define() 该方法是四个方法中最重要的方法，用于创建自定义元素，它接受三个参数： 自定义元素的名称，且其必须符合元素名称的DOMString标准字符串。 用于定义元素行为的类。 一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。 // 自定义Div class SelfDiv extends HTMLElement { constructor(){ // super方法的调用是必须得 super() // 元素的相关业务代码 } } // 使用customElements实例(CustomElementRegistry接口)来完成注册功能 customElements.define(&amp;#34;word-count&amp;#34;, SelfDiv, { extends: &amp;#34;div&amp;#34; }); 上述代码便是自定义元素注册的简单演示。 shadow DOM shadown DOM也叫影子DOM，它最主要的功能是做封装，将元素的标记结构，样式以及行为隐藏起来，与外界隔离，这样能够保证封装的代码既不会被外界影响，同时也能保证内部的代码不会影响到外部的元素，这样便实现了Web Component的解耦合。 Shadow DOM接口可以将一个隐藏的，独立的DOM附加到一个元素上，目前为止FireFox,Chrome,Opera,Safari默认支持Shadow DOM，Chromium内核的Edge也支持。 Shadow DOM允许将隐藏的DOM树附加到常规的DOM树中 =&amp;gt; 以shadow root节点为起始根节点（Shadow Root的创建后续会说明），在这根节点的下方可以添加任何DOM元素，和普通的DOM元素没有任何区别。 下面有个示意图可以帮助理解。 上图的一些概念下面做一些解释： Shadow host：常规的DOM节点，Shadow DOM将会挂载到此处。 Shadow Tree：Shadow DOM内部的DOM树。 Shadow root: Shadow tree 的根节点。 注：Shadow DOM的操作方式和普通DOM操作方式没有任何区别，包括添加元素，设置属性等等，只不过Shadow DOM内部的任何改变都影响不了外部的DOM元素。 Shadow DOM的创建和挂载通过方法ElementShadow()来实现。 Element.</description>
    </item>
    
    <item>
      <title>Rust Trait</title>
      <link>https://runtus.top/posts/rust-trait/</link>
      <pubDate>Mon, 17 Jul 2023 20:09:43 +0800</pubDate>
      
      <guid>https://runtus.top/posts/rust-trait/</guid>
      <description>Rust中的特征Trait类似于其他语言中的接口，它定义了一组可以被共享的行为，只要实现了特征，就能使用这组行为。
特征 Trait 特征的定义 通过trait关键字对特征进行定义。 pub trait Student { fn GoClass(&amp;amp;self); fn LeaveClass(&amp;amp;self); fn getClassRoom(&amp;amp;self) -&amp;gt; String; } 上述声明了**身为学生应该有的几个特征行为：**即上课，下课和获取教室房间号，那么其他具有学生性质的结构体（或者说为类）需要遵循该特征。 需要注意：特征只是坐函数签名，并不是真正的实现函数，函数的实现在绑定了该特征的类里实现，下面一节会提到。 类型实现特征 使用for关键字来为类实现特征。 pub struct Bob { pub year: String, pub sex: String } impl Student for Bob { // 实现特征 fn GoClass(&amp;amp;self){ // .... } fn LeaveClass(&amp;amp;self) { // ... } fn getClassRoom(&amp;amp;self) { // ... } } 在Bob类型中实现了Student特征声明的三个函数，这是必须的，除非在特征中有默认的实现。 如果特征中有默认的函数实现，那么绑定的类型可以不用再次实现函数，若实现了对应的函数，那么会覆盖默认的特征函数实现。如下所示。 pub trait Student { fn GoClass(&amp;amp;self){ println!(&amp;#34;this is student!&amp;#34;); } fn LeaveClass(&amp;amp;self); fn getClassRoom(&amp;amp;self) -&amp;gt; String; } impl Student for Bob { fn GoClass(&amp;amp;self){ println!</description>
    </item>
    
    <item>
      <title>Rust包管理</title>
      <link>https://runtus.top/posts/rust%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 05 Jul 2023 17:33:19 +0800</pubDate>
      
      <guid>https://runtus.top/posts/rust%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>本文参考了Rust语言圣经中有关Rust包的介绍，攥写本章的目的是为了更好的掌握rust中包和模块的关系以及它们的代码组织方式，方便于未来的项目开发。
Rust中代码组织相关概念 在Rust中，代码的组织大致可以分为四个层次： 项目（Package） 工作空间（Workspace） 包（Crate） 模块（Module） Package 项目 Package其实就是通过命令cargo new创建的项目文件，其显著特征便是包含了cargo.toml文件，该文件标注了该Package的一些基本信息：例如名称，版本号，依赖等等。 一个Package由一个或多个包（Crate）组成，但是它最多只能包含一个库类型的包（即名为lib.rs的文件）。 Package还可以分为二进制Package和库Package。 二进制Package 直接使用命令cargo new package-name的Package-项目即为二进制项目，虽然在cargo.toml中没有显示指出Package的入口文件，但Cargo的惯例是：src/main.rs即为二进制包的根文件，即入口文件，所有的代码的执行都是从src/main.rs中的fn main()中开始执行的。 输入cargo run可以直接编译运行。 库Package 库Package在创建时需要增加--lib命令行参数选项，即cargo new package-lib-name --lib在，这样获得的Package是一个库Package，它只能作为一个第三方库被其他项目引用，而不能单独编译运行。 与 src/main.rs 一样，Cargo 知道，如果一个 Package 包含有 src/lib.rs，意味它包含有一个库类型的同名包 my-lib，该包的根文件是 src/lib.rs。 Package文件结构 需要注意的是，main.rs和lib.rs不是互斥关系，二者是可以共存的。当二者共存时，那就意味着它包含两个包：库包和二进制包，这两个包名也都是 package-name —— 都与 Package 同名。 下面是一个Package的文件结构。 . ├── Cargo.toml ├── Cargo.lock ├── src │ ├── main.rs │ ├── lib.rs │ └── bin │ └── main1.rs │ └── main2.rs ├── tests │ └── some_integration_tests.rs ├── benches │ └── simple_bench.</description>
    </item>
    
    <item>
      <title>Node Typescript打包发布</title>
      <link>https://runtus.top/posts/node-typescript%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/</link>
      <pubDate>Sun, 07 May 2023 11:21:13 +0800</pubDate>
      
      <guid>https://runtus.top/posts/node-typescript%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/</guid>
      <description>使用rollup打包typscript-node项目为第三方库 tsc和rollup对比 tsc是Typescript官方的编译器，本身也具有打包功能，但是其本质只是编译器，它适合于打包直接运行的大型项目文件，并不适合构建独立的第三方库或组件。 rollup则是javascript打包器，它可以将ES6模块打包称单个javascript文件，同时它本身也采用了Tree Shaking优化算法，能使得打包文件大小得到进一步的优化。 另一方面，rollup支持插件功能，通过设置插件能满足大部分时候的打包需求，在下面即将要讲解的打包中，插件提供了很大的帮助。RollUp插件集合网站 rollup打包流程 本地安装 rollup 就我个人而言，不推荐安装全局的rollup包，因为在协同工作时，这样会导致rollup版本得不到统一而产生打包错误，所以推荐在本地安装rollup，本文使用的包管理工具为yarn，安装命令如下: yarn add rollup 安装完毕后，在package.json文件里设置对应的脚本，用于快速启动打包。 // package.json { &amp;#34;scripts&amp;#34;: { &amp;#34;build&amp;#34;: &amp;#34;rollup -c&amp;#34; } } -c的意思是按照配置文件中设置的内容进行打包。 设置rollup.config.js文件 就如同tsconfig.json一样，rollup也是有一个对应的配置文件名为rollup.config.js，虽然其不是必须的，但配置文件强大且方便，所以在配置项目打包时基本都要用到配置文件。 在项目根目录创建对应的配置文件，在文件里根据自己的需求来编写对应的配置代码。 rollup.config.js是一个ES模块，它会根据文件内导出的内容来进行打包上的设置，如下所示。 // rollup.config.js export default { // 这里也可以是一个数组 input: [], output: [], external: [], plugins: [], // .... } 安装插件 需要三个插件： rollup-plugin-typescript2 =&amp;gt; 将typescript转移为javascript的插件 rollup/plugin-commonjs =&amp;gt; 将commonjs语法转换为es6 rollup-plugin-dts =&amp;gt; 生成声明文件d.ts文件 执行以下的命令 yarn add @rollup/plugin-commonjs rollup-plugin-typescript2 typescript tslib rollup-plugin-dts --dev 修改配置文件 关于配置文件的各个变量配置这里不赘述，如有需求，可查阅rollup官网的配置说明。 // rollup.</description>
    </item>
    
    <item>
      <title>Functional_Program_3</title>
      <link>https://runtus.top/posts/functional_program_3/</link>
      <pubDate>Thu, 23 Mar 2023 09:28:58 +0800</pubDate>
      
      <guid>https://runtus.top/posts/functional_program_3/</guid>
      <description> 关于副作用以及外部引用与函数式编程的关系
Pure Happiness with Pure Functions 禁止与外界交互 在第二章中也有说到，保持纯函数的关键在于不能与外界有直接交互，即直接引用。 这样有个好处是能让函数能够自给自足，从而能够只看函数本身就能更加轻松了解到函数本身的功能，而不需要借助外部变量来理解，例如以下的例子。 let minimum = 21 const checkAge = age =&amp;gt; age =&amp;gt; minium checkage依赖与外部变量minium，假如该变量声明的位置很远，当后续维护时会对这段代码返回的结果感到匪夷所思，不知道其值到底从何而来。 副作用 对于函数而言，函数的副作用就是函数执行时对外界环境产生了影响（无论是依赖还是修改）。 上述的与外界交互也算是副作用的一种，副作用在计算机领域并不是贬义的含义，只是对代码执行过程的一种结果的描述，只不过在函数式编程中，副作用被视为不好的程序过程执行。 下面列举了一些副作用的例子。 更改文件fs 数据库访问 发起http请求 DOM控制 获取系统状态 获取用户的输入 so on&amp;hellip;.. 并不是说在函数式编程中，我们要完全拒绝以上操作，而是要能控制这一系列操作。后续会介绍如何去进行这一个控制过程（柯里化），下面先介绍如何将纯函数从一个普通的函数中分离出来。 纯函数的分离 一个对外界依赖的函数要分离成纯函数，就必须要显式告知函数要依赖的对象是谁，即把要依赖的对象作为参数传递，从而将外部依赖改为内部依赖。 // 不纯函数，其没有显示告知函数依赖的对象是谁。 const signUp = (attrs) =&amp;gt; { const user = saveUser(attrs); welcomeUser(user); }; // pure -&amp;gt; 将DB，Email显示告知 const signUp = (Db, Email, attrs) =&amp;gt; () =&amp;gt; { const user = saveUser(Db, attrs); welcomeUser(Email, user); }; 这样做的好处不仅仅是让函数的依赖关系更加明确从而使得函数可读性增强，而且还让函数的复用性增强，一旦Db或Email有变化，只需要重新设置这两参数，再获取一个SignUp即可。 </description>
    </item>
    
    <item>
      <title>Functional_Program</title>
      <link>https://runtus.top/posts/functional_program_2/</link>
      <pubDate>Tue, 21 Mar 2023 21:34:36 +0800</pubDate>
      
      <guid>https://runtus.top/posts/functional_program_2/</guid>
      <description>读 Professor Frisby&amp;rsquo;s Mostly Adequate Guide to Functional Programming 记录
Functional Programming原文链接
本章主要简单介绍函数式编程中的一等公民，以及函数式编程的一些注意事项和好处。
第二章: First Class Functions 在函数式编程中，函数是作为一等公民存在的，应该把函数和其他变量等同，即函数也是变量，变量的类型也可以是函数，函数的参数也可以是函数。 const hi = name =&amp;gt; `Hi, ${name}` const greeting = hi hi(&amp;#34;小明&amp;#34;); 常见的回调函数，其实就是把函数当作参数传递。 const callback = (...args) =&amp;gt; { // balabala } ajax(&amp;#34;/xianbei114514/1919810&amp;#34;, callback) 不要做无所谓的函数返回 在写代码时，有时会做无意义的操作，在一个函数中，将另一个函数返回。其实它们的功能都没有变化，只是换了个变量名而已。 // 不好的操作 const getServerStuff = callback =&amp;gt; ajaxCall(json =&amp;gt; callback(json)); 对于上述代码，getServerStuff本质就是想传递一个回调函数，并在回调函数中获取ajax请求得到的值，但完全没必要写那么多，它等同于下面代码实现。 // 好的操作 const getServerStuff = ajaxCall; 此时getServerStuff的功能也是传递一个回调函数并获取到ajax的值，这和上面有区别吗？没有区别。 减少代码冗余，增强代码可读性以及可维护性 继续拿上述的ajaxCall例子来说，假如我们传递的回调函数如下所示。 ajaxCall((json) =&amp;gt; callback(json)) 这只是一个调用，如果说有多处的ajaxCall都要进行如此的回调函数的传递，那么一旦我们的业务发生改变时，就会去修改每一处代码，并且每次都要写一遍回调函数的形式，显得非常冗余。 所以考虑将函数作为变量来传递。 const cb = (json) =&amp;gt; callback(json) ajaxCall(cb) 此时一旦遇到上述情况，直接去修改cb的内容即可，并且代码量也会减少。 禁止this的出现 在函数式编程中，要保证函数是够**“纯”（1，5！）的，即不能让函数内的任何行为影响到函数外，而this指针便是一个例子，this指向的是执行函数的作用域，一旦使用了this，便会导致函数和外界进行交互，从而不纯**。 但在实际生产过程中，有时的业务情况又不得不这样操作，所以不能完全循规蹈矩，而是要懂随机应变，少量的交互并不会影响整体的代码质量。再说一句，若要调用含有this指针的函数，最好先使用bind函数改变this指针指向，这样不仅能让代码更加易读，还能减少一些未来执行时可能遇见的错误。 // 借用网上的例子 // scary fs.</description>
    </item>
    
    <item>
      <title>Rust-所有权</title>
      <link>https://runtus.top/posts/rust-%E5%80%9F%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%A8/</link>
      <pubDate>Wed, 26 Oct 2022 22:54:43 +0800</pubDate>
      
      <guid>https://runtus.top/posts/rust-%E5%80%9F%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%A8/</guid>
      <description>所有权系统和引用在Rust中是至关重要的，它的设计使得rust的GC机制与众不同，也让rust获得了性能上的回报。
所有权 所有权：一个数值只能被一个变量所拥有，即该变量唯一拥有该数值，若变量离开了其作用域，数值也会被释放掉。 如果将一个变量赋值给另一个变量，则意味着对应的值的所有权会被移交出去，那么原先的变量将不再拥有值的所有权，这也是为什么在rust中，变量的赋值也叫变量的绑定。 // 例子 fn main(){ let s1 = String::from(&amp;#34;Hello&amp;#34;); let s2 = s1; // 所有权移交 -&amp;gt; 即move println!(&amp;#34;{}&amp;#34;, s1); // 报错 } 可以看到，上述例子的s1将所有权移交给s2后，自己便不再拥有对字符串Hello的控制。 从内存的视角观察 还是上述例子，在内存里表示出来，如下图所示。 可以看出，再进行变量绑定时，s2实际上是s1的浅拷贝结果，但唯一不同的是指针的移交操作，即指针不是单纯的拷贝，而是从s1上“移交”给了s2，这也是一个move的过程。
如果不想让s1的所有权移交出去，则可以调用String的clone方法来实现深拷贝 ，在堆内存上再开辟一个空间，这样两个变量都有对应的值，这样就不会发生变量无法使用的情况了。
let s1 = String::from(&amp;#34;hello&amp;#34;); let s2 = s1.clone(); // 直接重新开辟一个空间，尽量少用，会影响rust性能 println!(&amp;#34;s1 = {}, s2 = {}&amp;#34;, s1, s2); 需要注意的是，这并不能说明存储在堆内存中的数据只能有一个引用（即指针），这里只强调了move这个操作，即所有权的移交过程，而没有说明堆数据只能有一个引用。 Copy类型 之所以提到copy类型是因为它与上述的String类型有所不同，具有Copy属性的数据类型的数据都是直接存储于栈内存中的，即具有copy特征的数据在进行赋值时，旧变量依然可以使用。 fn main(){ let a = 1; let b = a; // 将 a 赋值给 b } 当赋值时，进行了浅拷贝操作，由于简单类型直接在栈上进行浅拷贝，开销小，两个1时存储在不同的栈内存空间里，所以两个变量都有与之对应的数值，所以不会像刚才的String类型一样，发生s1不可使用的情况。</description>
    </item>
    
    <item>
      <title>再拾docker</title>
      <link>https://runtus.top/posts/%E5%86%8D%E6%8B%BEdocker/</link>
      <pubDate>Sat, 29 Jan 2022 11:10:01 +0000</pubDate>
      
      <guid>https://runtus.top/posts/%E5%86%8D%E6%8B%BEdocker/</guid>
      <description> 记录docker的基本概念和用法，系统的再认识一次docker
docker是什么 Docker是对Linux容器的一种封装，并提供简单易用的接口，同时它也是目前最流行的Linux容器解决方案。
在docker出现之前，环境移植一直是非常麻烦的事情，当我们需要把项目从一台机器迁移到另一台机器时，不仅仅是迁移源代码，更重要的是要保证环境的一致性，而一次次环境的搭建则显得冗余且效率极低，所以在思考有没有一种方式能够把环境一起进行迁移。
虚拟机的出现在一定程度上解决了这个问题，但接踵而至的问题是：
虚拟机占用资源多，它本质就是一台完整的操作系统， 冗余步骤多，由于是完整的操作系统，一些系统级别的操作步骤不可避免。 启动慢。 所以Linux发展出了另一种虚拟化技术：Linux容器。而docker则是Linux容器的一种解决方案（也是最流行的）
可以简单的将docker理解为一种非常轻量级的虚拟机。
docker镜像（image文件） docker把应用程序及其依赖打包在image文件里，通过image文件，就会生成容器（后续会提到），即镜像文件其实就是容器的模版，而容器则是镜像文件的实例（可以一一对应类与对象） image文件是二进制文件。在实际开发中，我们会在别人写好的image文件上加一些自定义设置从而形成我们需要的image文件，而不是自己从零开发一个image文件（当然，有需求另说）。 # 有关image命令 docker image ls # 列出docker镜像 docker image rm [imageName] # 删除某镜像文件 容器文件 由image生成的容器实例，本身也是一个文件，称为容器文件。同时，当关闭容器时不会删除容器文件，只是让容器停止运行而已。 docker container ls # 本机正在运行的容器 docker container ls --all # 本机所有容器 每个容器都有一个唯一ID，如果需要终结容器的运行，需要使用kill命令docker container kill。 如需要删除容器文件，需要使用rm命令。 docker container rm [containerID] </description>
    </item>
    
    <item>
      <title>go-learning-1</title>
      <link>https://runtus.top/posts/go-learning-1/</link>
      <pubDate>Fri, 28 Jan 2022 09:13:38 +0000</pubDate>
      
      <guid>https://runtus.top/posts/go-learning-1/</guid>
      <description>Golang学习记录
关于swtich Golang中的switch的每个case自带break关键字，即不用手动去设置break关键字。 import ( &amp;#34;fmt&amp;#34; ) func main(){ variables := 12 switch variables { case 24: fmt.Println(&amp;#39;24&amp;#39;) case 12: fmt.Println(&amp;#39;12&amp;#39;) case 36: fmt.Println(&amp;#39;36&amp;#39;) default: fmt.Println(&amp;#39;114514&amp;#39;) } } // 12 如果在其他语言中这样编写switch代码块，36和default代码块中的输出也会执行。 fallthrough关键字 当然，golang也提供了能够无视掉默认break的关键字，即fallthrough，在指定的case最后一行加上fallthrough，则对应的case代码块将会忽视掉默认的break操作。 // 接上 func main(){ variables := 12 switch variables { case 24: fmt.Println(&amp;#39;24&amp;#39;) case 12: fmt.Println(&amp;#39;12&amp;#39;) fallthrough case 36: fmt.Println(&amp;#39;36&amp;#39;) default: fmt.Println(&amp;#39;114514&amp;#39;) } } // 12 // 36 关于数组 在golang中的数组和c一样，一旦定义了大小就不可更改，且声明方式有多种，如下: // var variable_name [SIZE] variable_type func main(){ var balance = [3]float32{100, 2.</description>
    </item>
    
    <item>
      <title>0120-浏览器事件</title>
      <link>https://runtus.top/posts/0120-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 20 Jan 2022 10:30:44 +0000</pubDate>
      
      <guid>https://runtus.top/posts/0120-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6/</guid>
      <description>Javascript和HTML的交互都是通过事件来实现的，而事件的产生与执行则是遵循着传统软件工程领域中的观察者模式，其能够做到页面行为和页面展示的解耦合。
本节内容会从事件流谈起，然后逐一介绍几种注册事件的方式以及他们其中的一些细节，最后还会提到关于**事件委托（代理）**的概念。
事件流 事件流描述了页面接受事件的顺序。因为一个事件的触发可能会影响好几处地方，这很容易理解，比如在页面上嵌套着写了几个div元素，同时在最里层的div元素上进行事件触发，那这不仅仅是最内层的div对事件进行响应，任意一层的嵌套的div都会对事件进行相应处理。（其实通过上述的观察者模式也可以推断出其合理性，因为一个对象可以由多个观察者进行观察） 所以多个监听事件的元素响应顺序需要进行统一，因为一些历史原因，事件的响应顺序有两种模式：冒泡和捕获。 事件冒泡 顾名思义，事件的冒泡就如水底下的气泡一下，从内到外，同理，事件冒泡规定的事件流顺序也是从内而外，事件会从最深层的节点开始触发，然后向外传播到document（文档）。 代码如下所示。 &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;ddd&amp;#34;&amp;gt; click me &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 此时我如果对id=ddd的div元素进行click事件触发，那么该事件会以如下顺序发生: div body html document 现代的浏览器的事件会一直冒泡到window对象。 事件捕获 事件捕获则和事件冒泡相反，事件的响应顺序是从外到内的，还是以上一个例子为例，那么对应click事件讲会以如下顺序发生: document html body div DOM事件流 DOM2 Events规范里规定里事件流为分三个部分：事件捕获，到达目标和事件冒泡。 需要注意的是，div元素（即直接触发元素）是不会响应捕获事件的，因为通常认为直接触发事件是冒泡阶段发生的，所以它也是冒泡阶段第一个发生的事件。 但现在大多数支持DOM事件流的浏览器都实现了一个小小的拓展，即在捕获阶段在事件目标上触发事件。最终结果表现为有两个机会来处理事件。 事件处理程序 事件意味着用户或浏览器执行的某种动作，而为响应事件而调用的函数被称为事件处理程序（事件监听器）。 HTML事件处理程序 HTML事件处理程序是以HTML属性的形式来进行指定的。该属性的值必须是能够执行的javascript代码。 比如下面这个例子，就是按钮在被点击时执行一段代码。 &amp;lt;button onclick=&amp;#34;console.log(&amp;#39;click&amp;#39;)&amp;#34;&amp;gt; click me &amp;lt;/button&amp;gt; 当然也可以以函数的形式来进行响应事件定义。 &amp;lt;script&amp;gt; function click(event){ console.log(&amp;#39;click&amp;#39;) } &amp;lt;/script&amp;gt; &amp;lt;button onclick=&amp;#34;click(event)&amp;#34;&amp;gt; click me &amp;lt;/button&amp;gt; 可以看到，除了把函数单独拎出来以外，还多了一个event对象，这个是一个特殊的局部变量，它定义了事件触发的一些属性以及被触发元素的一些属性。 除此之外，HTML事件处理程序中的this就是DOM元素本身，所以可以直接使用this对象去获取对应元素上的属性。 &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;Click Me&amp;#34; onclick=&amp;#34;console.log(this.value)&amp;#34;&amp;gt; 这里还有个比较有趣的地方，获取元素属性时可以直接省略掉this，直接使用value，即下面写法也能达到同样的效果。 &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;Click Me&amp;#34; onclick=&amp;#34;console.log(value)&amp;#34;&amp;gt; 因为这个包装函数在创建时其作用域链被with操作符给延长了，所以document和元素自身的成员都可以被当成局部变量来使用。 function() { with(document) { with(this) { // 属性值 } } } 但最好不要这样做，因为不仅仅会显得很诡异，而且在后期调试时也会造成误解。 HTML事件处理程序一个比较大的问题是：它把HTML和Javascript在代码上进行了强耦合（在逻辑上依然是分开的），如果我们需要更改响应程序，那么两处都需要进行修改。</description>
    </item>
    
    <item>
      <title>DOM扩展</title>
      <link>https://runtus.top/posts/dom%E6%89%A9%E5%B1%95/</link>
      <pubDate>Sun, 26 Dec 2021 10:22:54 +0000</pubDate>
      
      <guid>https://runtus.top/posts/dom%E6%89%A9%E5%B1%95/</guid>
      <description>虽然原生DOM API已经能做许多事情了，但是仍然不断有标准或专有的扩展出现，以支持更多的功能，由于各个浏览器对DOM扩展的支持是专有的，为了统一这些专有的DOM API，W3C开始着手将这些专有扩展转变为标准规范。
Selectors API Selectors APIs 是浏览器原生支持的CSS查询API，由于是原生支持，解析和遍历DOM树可以通过底层编译语言实现，相比其他Javascript库（比如jQuery），性能有数量级的提升。 Selectors API Level 1 主要是两个API：querySelector() 和 querySelectorAll() querySelector() 该方法接受CSS选择符参数，返回匹配到的第一个后代元素，如果没有匹配元素则返回null。 // 匹配 class 为 list 的第一个DOM元素 document.querySelector(&amp;#39;.list&amp;#39;) // 匹配 id 为 myDiv 的第一个DOM元素 document.querySelector(&amp;#39;#myDiv&amp;#39;) // 匹配 class=header DOM元素子元素中 id为someDiv的元素 const header = querySelector(&amp;#39;.header&amp;#39;); header.querySelector(&amp;#39;#someDiv&amp;#39;) 如果直接在document上使用querySelector方法，会从文档元素开始搜索（前两个例子）；在Element上使用querySelector方法，则只会在该元素的后代中查询（第三个例子）。 querySelectorAll() 该方法和querySelector类似，接受CSS选择符参数，只不过它会返回匹配的所有节点。即返回的是一个NodeList的静态实例。
⚠️注意：无论是querySelector还是querySelectorAll返回的都是DOM元素的静态快照，即和之前提到的getElementById获取的动态实例不同，更改静态快照是不会影响DOM元素在页面上的渲染。
matches() matches方法接受一个css选择符参数，用于判断是否存在对应css选择符的DOM元素，如果存在返回true，否则返回false。 if(document.body.matches(&amp;#34;body.header&amp;#34;)){ // true } CSS类扩展 HTML5增加了一些特性以方便使用CSS类。 getElementsByClassName() 该方法接受一个参数，包含一个或多个类名的字符串，返回类名中包含对应类的元素的NodeList。 // 返回 class 包含 username 和 current 的类 document.getElementsByClassName(&amp;#39;username current&amp;#39;) classList属性 classList属性提供了快速操作DOM元素类名的方法，如果是之前，对一个含有多个class的DOM元素进行类名操作会很麻烦，基本操作都是把其类字符串解析成数组，然后一个一个进行匹配操作，最后再合并为一个新的类字符串重新赋值回去。 // 要删除&amp;#34;user&amp;#34;类 let targetClass = &amp;#34;user&amp;#34;; // 把类名拆成数组 let classNames = div.</description>
    </item>
    
    <item>
      <title>1224-浏览器缓存</title>
      <link>https://runtus.top/posts/1224-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</link>
      <pubDate>Fri, 24 Dec 2021 10:35:37 +0000</pubDate>
      
      <guid>https://runtus.top/posts/1224-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</guid>
      <description>浏览器缓存是性能优化中最直接，高效的优化方式，它可以显著减少因为网络传输而带来的损耗。
对于数据请求来说，大致可以分为 请求 -&amp;gt; 处理 -&amp;gt; 响应这三个步骤，而浏览器缓存则主要在第一步和第三步做手脚，即请求发出时寻找合适的缓存，拿到新的响应数据时做新的缓存。 缓存带给我们最直观的感受就是，每次加载页面，第二次之后加载总是比第一次加载的更快，这就是缓存的功劳，下面讲从缓存位置和缓存策略两个方面介绍浏览器相关缓存。 缓存位置 浏览器的缓存位置大概可以分为四种： Service Worker Memory Cache Disk Cache Push Cache（HTTP 2） 他们有各自的优先级，当发出请求时，浏览器会依次去寻找缓存，如果都没有命中，才会发出请求。 Service Worker Service Worker是浏览器背后的独立线程，可以用来实现缓存功能，但是需要注意，如果要使用Service Worker，传输协议必须是HTTPS。 Service Worker实现缓存大致三个步骤。 注册Service Worker。 监听install事件，并对需要的文件进行缓存。 拦截HTTPS请求，并根据请求内容去命中缓存，如果命中，则直接使用缓存，否则请求数据。 下面是一串实例代码（源代码来自前端面试之道） // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register(&amp;#39;sw.js&amp;#39;) .then(function(registration) { console.log(&amp;#39;service worker 注册成功&amp;#39;) }) .catch(function(err) { console.log(&amp;#39;servcie worker 注册失败&amp;#39;) }) } // sw.js // 监听install事件，缓存文件 self.addEventListener(&amp;#39;install&amp;#39;, e =&amp;gt; { e.waitUntil( caches.open(&amp;#39;my-cache&amp;#39;).then(function(cache) { return cache.addAll([&amp;#39;./index.html&amp;#39;, &amp;#39;./index.js&amp;#39;]) }) ) }) // 拦截请求，并根据请求去命中响应数据 self.</description>
    </item>
    
    <item>
      <title>1222-DOM</title>
      <link>https://runtus.top/posts/1222-dom1/</link>
      <pubDate>Wed, 22 Dec 2021 13:01:26 +0000</pubDate>
      
      <guid>https://runtus.top/posts/1222-dom1/</guid>
      <description>NodeList 和 HTMLCollection区别
NodeList是节点的集合，而HTMLCollection是元素的集合。
节点包括很多类型，文档节点，元素节点，属性节点，文本节点，这一点通过Node类型上的12个数值常量表示就可以看出。
Node.ELEMENT_NODE（1） Node.ATTRIBUTE_NODE（2） Node.TEXT_NODE（3） Node.CDATA_SECTION_NODE（4） Node.ENTITY_REFERENCE_NODE（5） Node.ENTITY_NODE（6） Node.PROCESSING_INSTRUCTION_NODE（7） Node.COMMENT_NODE（8） Node.DOCUMENT_NODE（9） Node.DOCUMENT_TYPE_NODE（10） Node.DOCUMENT_FRAGMENT_NODE（11） Node.NOTATION_NODE（12） // 常用的获取DOM元素的接口及其返回的数据结合类型 Node.childNodes instanceof Nodelist Node.chidren instanceof HTMLCollection document.getElementByxxxx instanceof HTMLCollection 注意：NodeList，HTMLCollection，NamedNodeMap 都是实时的，意味着文档结构的变化会实时地在它们身上反映出来。</description>
    </item>
    
    <item>
      <title>1220-客户端检测</title>
      <link>https://runtus.top/posts/1220-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Mon, 20 Dec 2021 11:22:31 +0000</pubDate>
      
      <guid>https://runtus.top/posts/1220-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/</guid>
      <description>如今的浏览器虽然接口已大致统一，但是每家浏览器难免都有自己的“想法”，于是会出现个别的不统一，这些差异迫使Web开发者自己去设计兼容这些差异，客户端检测就是最常见的检测手段，通过检测结果来进一步克服和避免这些缺陷。
客户端检测可大致分为三种：能力检测，用户代理检测，软件与硬件检测。
能力检测 能力检测也成为特性检测，因为不同浏览器提供的接口不是完全相同，于是可以通过简单的逻辑判断来检测在该浏览器环境下能否调用特定API，同时还能间接判断出浏览器类型。 比如，在IE5之前没有document.getElementById这个DOM方法，但是可以通过document.all来实现相同的功能。于是，可以进行如下的能力检测。 const getElementById = (id) =&amp;gt; { if(document.getElementById){ return document.getElementById(id) } else if (document.all){ return document.all[id] } else { throw new Error(&amp;#39;该浏览不支持任何通过ID获取DOM元素的方法&amp;#39;) } } 需要注意的是，实现能力检测是一定要落实到具体的功能上，即某个能力的存在并不能代表其他能力也存在。 function getWindowWidth() { if (document.all) { // 假设 IE return document.documentElement.clientWidth; // 不正确的用法！ } else { return window.innerWidth; } } 比如上述例子，document.all的存在并不能说明documentElement.clientWidth的存在。其实这段代码的本意是通过document.all来判断当前浏览器是不是IE浏览器，事实document.all的存在并不能一定确认该浏览器就是IE浏览器。 基于能力检测进行浏览器分析 除了上述可以进行基本的功能检测以外，还可以通过能力检测来进行浏览器的特性支持检测，比如是否支持Netscape插件，是否具有DOM Level 1能力等等。 // 红宝书P384 // 检测浏览器是否支持 Netscape 式的插件 let hasNSPlugins = !!(navigator.plugins &amp;amp;&amp;amp; navigator.plugins.length); // 检测浏览器是否具有 DOM Level 1 能力 let hasDOM1 = !</description>
    </item>
    
    <item>
      <title>设计模式 - 观察者模式 - 发布订阅模式</title>
      <link>https://runtus.top/posts/1218-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 18 Dec 2021 16:06:30 +0000</pubDate>
      
      <guid>https://runtus.top/posts/1218-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式和发布订阅模式是平常业务开发中最常见的设计模式，虽然网上大多数文章将二者归为一类，其实不然，它们两者之间还是有细微的差距。
先来个观察者模式的定义 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的某个属性（或状态）发生变化时，会通知所有观察者对象，让它们自动更新。 现实映射 举一个🌰，高中的时候，我会经常去问老师问题，有时候遇到比较难的问题，老师一时半会解不开，老师会说**&amp;ldquo;你先去做其他的事情吧，一会儿我找到解题思路了来叫你&amp;rdquo;**。于是乎我先去做其他事情，等待老师的召唤。过了一会儿，老师叫另一个同学来叫我去办公室找他，于是我马上放下手中的活，冲向的老师的办公室&amp;hellip;&amp;hellip; 在这里例子里，我是一位观察者，而老师则是一位我观察的对象，当老师的状态发生了变化（指想出了题的思路），我就会接受到对应的信息，然后马上更新我自己的状态（指润去找老师）。 来点转换 上述例子如果在发布-订阅模式里，我则摇身一变，变成了订阅者，专门订阅老师发布的通知信息，而老师则作为了发布者。 其实，上述例子还不能完全展示出定义所说的一对多关系，因为订阅者只有我一个人，但其实稍微扩展一下，变成多位同学向老师询问同一道题目，那这就是标准的观察者模式了，多位观察者“观察”老师的状态。 来点代码 通过上述的定义和描述，大概可以知道，在观察者模式中，一共有两个类：发布者类和订阅者类。作为一个发布者，很容易可以想到它有下面几个基本方法：增加订阅者，通知订阅者，移除订阅者。思路有了，下面就直接实现。 // 发布者类 class Publisher { constructor() { this.observers = [] // Observer -&amp;gt; 观察员 } // 添加订阅者 add(observers) { this.observers.push(...observers) } // 移除订阅者 remove(observer) { this.observers.forEach((item, index) =&amp;gt; { if (item === observer) { this.observer.splice(index, 1) } }) } // 通知订阅者 notify() { this.observers.forEach((item) =&amp;gt; { item.update(); // 注意，订阅者的方法应该它们本身定义的 }) } } 发布者基本类设计完毕，下面开始设计下订阅者，其实订阅者很简单，它最核心的就一个方法：收到发布者的信息后，去进行状态更新。如下所示。 // 定义订阅者类 class Observer { constructor() { console.</description>
    </item>
    
    <item>
      <title>vuepress开发遇到的一些问题</title>
      <link>https://runtus.top/posts/vuepress%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 13 Nov 2021 16:31:09 +0000</pubDate>
      
      <guid>https://runtus.top/posts/vuepress%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description> vuepress是SSR渲染，即vue挂载之前是在服务端进行的，所以尽量不要在before Mounted之前的hooks中调用浏览器API，否则打包时会报错。 关于css中的 mix-blender滤镜模式，和 z-index关联比较多，具体体现在我在使用darkmodejs时，如何避免图片被mix-blender渲染，虽然官方给的方法是加入isolation：isolate属性（另启层叠上下文），但是并没有什么用，感觉是哪个地方出问题了，关于层叠上下文还有上述提到的属性需要重新学习下。 另外，层叠上下文z-index和position关联很大，这个也要去做深究，我如果只是给image加z-index，则无法避免被滤镜覆盖的事实，应该是需要把他们纳入统一个层叠上下文才行，所以需要position：relative（注意，position默认是static）。这一块儿的知识也要重点去温习。 const testFn = async () =&amp;gt; { const a = 2; for(let i = 0; i &amp;lt; a; i++){ // xxxxxx } return new Promise((res) =&amp;gt; { res(); }) } A-.-&amp;gt;B </description>
    </item>
    
    <item>
      <title>初入数据可视化</title>
      <link>https://runtus.top/posts/%E5%88%9D%E5%85%A5%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</link>
      <pubDate>Sun, 17 Oct 2021 10:56:45 +0000</pubDate>
      
      <guid>https://runtus.top/posts/%E5%88%9D%E5%85%A5%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</guid>
      <description>视图编码（可视化编码） = 标记 + 视觉通道
可视化设计的三部曲 可展示数据的筛选 -&amp;gt; 可视化编码映射（视图编码） -&amp;gt; 视图与交互设计
数据可视化设计的注意事项 在对数据可视化之前，要选择合适的标记和视觉通道，选择合适的视觉通道编码能够更加清晰，直观地展现出数据的特点，同时能够使用户更加容易地分析数据特征。
不同的视觉通道编码信息会产生不同的效果，这种效果也被称为表现力和有效性。
表现力和有效性决定着数据可视化的最终效果。
在表现力排序中，无论是定量型视觉通道还是定性型视觉通道，空间位置都具有最大表现力。
决定表现力的四个维度： 精准性 可辨认性 可分离性 -&amp;gt; 不同的视觉通道编码之间互相干扰的程度 视觉突出 -&amp;gt; 人依靠本能，在很快的时间内快速感应到图形中的异常点。此维度在发现异常数据的可视化分析中至关重要。 提升表现力的方法： 聚焦：通过恰当的技术手段就将可视化结果中的最重要的部分重点突出。
均衡：空间布局要合理，将重要的元素位于中心区域，其余元素均衡分布。
简单：元素尽量简单，避免画面过于复杂。
隐喻：尽量用人们所熟悉的某样事物去表达信息，从而使得可视化内容更加直观、易懂。
数据按照它们之间的特征，可以大致分为以下的三类：
数值型数据，分类型数据，有序性数据</description>
    </item>
    
    <item>
      <title>保研说明</title>
      <link>https://runtus.top/posts/0907-%E5%BC%80%E7%AF%87%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Fri, 15 Oct 2021 11:30:03 +0000</pubDate>
      
      <guid>https://runtus.top/posts/0907-%E5%BC%80%E7%AF%87%E8%AF%B4%E6%98%8E/</guid>
      <description>保研</description>
    </item>
    
    <item>
      <title>谈谈保研经历</title>
      <link>https://runtus.top/posts/%E8%B0%88%E8%B0%88%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86/</link>
      <pubDate>Mon, 04 Oct 2021 10:05:44 +0000</pubDate>
      
      <guid>https://runtus.top/posts/%E8%B0%88%E8%B0%88%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86/</guid>
      <description>这篇博客主要记录的是保研的大概过程以及作者今年从六月份到九月份的保研经历，希望能够让未来保研的学弟学妹们更清晰地了解保研的整个过程以及其中的一些避坑指南。
本人基本情况📖 本科院校：电子科技大学/信息与软件工程学院
均分：87.5
排名：18/186（10%）
四级：500
六级：492
无科研经历
竞赛获得奖项
中国软件杯国家三等奖 三创杯四川省二等奖 微信小程序开发大赛西南赛区三等奖 最终去向：电子科技大学/计算机科学与工程学院（电子信息）
从上述基本情况可以看出，本人在本科期间不算优秀，没有任何科研经历，竞赛也是一些较小的比赛，不过好在大三时去字节跳动实习过半年，这也算是一个加分项。
保研基本流程 总的来说，保研基本分为三个阶段：
夏令营（六月 - 八月） 预推免（八月末 - 九月） 九推（九月 - 十月系统关闭）（这里的系统是指国家推免招生系统，后续会提到） 其中，需要注意的是前两个阶段，即夏令营和预推免。
夏令营 夏令营是可以等效理解为高考录取的提前一批，各位学生通过学校研究生院官网了解到对应院校的夏令营信息，通过报名，学院筛选后，进入到院校夏令营中。如下的两个链接。 南京大学夏令营信息
电子科技大学夏令营信息
一般来说，每个高校的夏令营流程如下: 了解学院基本情况 -&amp;gt; 了解学院中的各个实验室（即了解导师） -&amp;gt; 学院组织统一面试（筛选优秀营员） -&amp;gt; 夏令营结束 注意，大多数学院的夏令营优秀营员相当于已经被学院拟录取了，所以夏令营的面试一定要提前好好准备一下，毕竟多一个offer不亏。 夏令营注意事项 一定，一定，一定要保证信息的流通！保研其实就是再打一场信息战，谁掌握的信息多，谁的优势就越大，不要有**“好麻烦啊，我不想去找消息”的想法**，要善于利用渠道去获得各个院校的夏令营的开放时间，免得错过（本人就是错过了非常多的夏令营，没有拿到保底offer，最后九推差点没书读）。
一般来说，可以从下面两个渠道来获得各个院校夏令营信息：
全国各地保研学生自发组织的QQ群 -&amp;gt; 每个专业的QQ群不一样，比如计算机保研交流群：605176069。 GitHub仓库：由全国各地用爱发电同学实时更新的夏令营信息集合。如下链接（可能需要梯子） 2021年CS保研夏令营通知公告
关注微信公众号：保研夏令营 最好在夏令营阶段就联系好导师，因为越好的导师越抢手，而好的导师则是决定着你未来三年读研体验，因为在读研期间，大多数时间都是跟着自己的导师做科研/项目。
多报几个学校的夏令营，由于现在疫情影响，基本所有院校的夏令营都是线上进行，于是没有了空间上的成本，多报几个夏令营则是多给自己选择的机会，防止到保研后期手足无措。
预推免 预推免的举行时间一般是每年的八月中旬到九月底（开推免系统之前），和夏令营类似，各个院校会在自己的研究生院上公布对应的预推免报名时间。 预推免的流程只有两步，即初审和复试。初审是报名的研究生院老师根据学生提交的信息而进行简单的评估，而复试则和夏令营类似，由学院专家组对学生进行20分钟左右的面试。一般在面试结束后的一天到两天左右就会出结果。 预推免注意事项 和夏令营类似，要及时了解到各个学校学院的预推免报名时间，以免错过。 有些学校在夏令营时没有给出推免名额，他们把所有名额都放到了预推免上，比如电子科技大学。 同理，预推免也可以多报几个学校，如果说只报了一个学校，并且面试的时候发挥失常了，那可能就要寄了（当然在九推时也可以捡漏，后面会提到）。 九推 何为推免系统？ 在说九推之前，先说一下什么是国家推免生系统。 前面有提到，各个学院会在夏令营和预推免时发放拟录取offer，需要注意，这里只是拟录取，并不是真正的拟录取，因为这只是学院的口头offer，国家是不认的。 真正的录取则是要通过上述提到的推免系统来进行录取，它类似于高考填报志愿的系统，通过该系统进行录取的推免生，才算是真正拟录取（为何说是拟录取，因为后期如果推免生本人做了一些违反规定的事情，那会被取消资格，这里只是保证学校层次不会把你咕了） 如下所示，是推免系统的界面 正文 关于九推，如果说你在夏令营或预推免已经拿到了学校offer了，那直接根据学校要求，在志愿系统上填报对应院校即可。 可如果你之前一个offer都没拿到，或者只是在某个学校的wl（候补名单）中，那可能需要在九推的时候捡漏了。 每年都会出现学院招不满推免学生的情况，特别是近几年疫情期间，没了空间成本，这种鸽的现象越来越严重，甚至有的学校会被鸽穿，比如今年的华中科大和湖南大学。 于是，这个时候就可以捡漏了，可以从以下两种比较常见的办法捡漏： 直接联系学院的研招办，询问具体情况，有些学院你甚至没有去面试，都可以被录取，比如这次我联系的华中科大计算机学院，可惜我们学校先录取的我，于是只能放弃了。 有些学院会开二次预推免招生进行补录，冲就完事了。 有关于推免系统填报的相关流程和细节，可以参照下面的微信公众号文章。 2021推免系统填报指南</description>
    </item>
    
    <item>
      <title>数据结构-杂记</title>
      <link>https://runtus.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9D%82%E8%AE%B0/</link>
      <pubDate>Mon, 20 Sep 2021 10:03:52 +0000</pubDate>
      
      <guid>https://runtus.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9D%82%E8%AE%B0/</guid>
      <description> 这是一篇不成体系的记录，只是为了记录一些零散的容易忘记的概念知识点
线性表 具有相同数据类型的n（n &amp;gt;= 0）个数据元素的有限序列。 顺序表 线性表的顺序存储又称为顺序表， 即用一组连续的存储空间来存储线性表中的元素。 顺序表特点：逻辑顺序和物理顺序相同。 高级语言中，顺序表的代表为数组。 线性表的链式存储 地址没有要求连续，即要求逻辑上相邻的数据在物理存储上没有要求，数据与数据之间通过指针来进行联系。 线性表一般有两种表现方式（根据存储方式的不同）：顺序表和链表
栈 一种特殊的线性表，不过要求只能在一端进行数据的读写（推入push和弹出pop）。 堆 计算机中一种特殊的数据结构，它通常被看作是用一棵树的数组对象。 它有两个特性： 堆一定是一颗完全二叉树（所以才可以用数组来表示） 二叉树里所有的子树的根节点都大于（或小于）它的子节点，即大根堆和小根堆的区别。 </description>
    </item>
    
    <item>
      <title>计算机网络-网络层</title>
      <link>https://runtus.top/posts/0913-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 13 Sep 2021 10:49:53 +0000</pubDate>
      
      <guid>https://runtus.top/posts/0913-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>网络层被设计成“向上提供简单灵活的，无连接的，尽最大努力交付的数据报服务”的特性，即所传输的分组没有保证，可能出错，丢失，重复，失序，或超时。
但这样设置好处是：网络的造价大大降低（比如路由器），运行方式灵活，能够适应多种应用（即在网络层之上的传输层可以基于灵活的网络层作很多拓展工作）
异构网络互联 不同协议的网络子系统通过**中间设备（中继设备）**相互连接起来，形成更大的系统。（P135） 中继设备： 物理层：中继器，集线器（Hub） 数据链路层：网桥或交换机 网络层：路由器 网络层之上：网关 路由与转发 路由器的两功能：路由选择（确定哪一条路径 =&amp;gt; 构建和维护路由表）和分组转发（当一个分组到达时要完成的动作 =&amp;gt; 查询，转发以及队列管理和任务调度等）。 拥塞控制 网络进入拥塞状态的方法：观察网络吞吐量和负载的关系。 如果随着网络负载的增加，网络的吞吐量明显小于正常吞吐量（或者不增反降），则说明可能（一定）进入了拥塞状态。（注意：正常情况下，负载越高，吞吐量越大） 拥塞控制和流量控制（联系到链路层的流量控制）的区别 流量控制是在发送端和接受端点对点通信时的数据传输控制，它数局部性控制，且是接收端来控制发送端 而拥塞控制则是一个全局性的问题，它确保的是一个子网内的数据能够成功传输到彼此。 拥塞控制的方法 开环控制：静态的预防方法，系统启动后，设置的控制调度算法不能改版。 闭环控制：动态方法，采用监测网络系统去监视，及时检测哪里发生了拥塞，然后将拥塞的信息传输到合适的地方，以便调整网络系统的运行。 路由算法 静态路由算法 =&amp;gt; 网络管理员手动配置的路由信息，它不能适应网络状态的变化。 动态路由算法 =&amp;gt; 通过路由器之间相互传递信息并且根据一定的算法，实时更新路由表的信息。 动态路由算法的两个主要算法 距离-向量路由算法 =&amp;gt; 实现协议RIP（路由信息协议） =&amp;gt; 应用层协议，使用了UDP传送数据 所有结点定期地将它们的**整个路由选择表（下面统称为路由表）**传送给其所有的相邻结点。 每个结点从相邻结点拿到路由表信息后，迭代计算到每个结点的最短距离，并实时更新自己的路由表。 链路状态路由算法 =&amp;gt; 实现协议OSPF（开放最短路径优先） =&amp;gt; 网络层协议，使用ip数据包传递数据 每个结点（路由器）向本自治系统的所有节点发送自己和自己相邻路由器之间的链路状态，即先把信 息发送给相邻的路由器，然后通过相邻的路由器再次发送给它的相邻路由器，这样不断迭代传递，最终所有结点都能获得发送结点的相邻链路状态。 =&amp;gt; 泛洪法 最后每个路由器都能获得自治系统内所有节点的相邻链路状态，然后按照一定的算法，更新自己的路由转发表。 所以该算法要求每个参与算法的结点都具有完全的网络拓扑信息。 层次路由 设想一下，如果对网络中众多的路由不分层次，则会使得每次转发的路由表（或链路信息）异常庞大，无论是更新还是查阅都会非常消耗性能，其次灵活性也不高，因为没有分层，导致整个路由系统必须统一协议标准，而不能“因地制宜”。 所以考虑把整个互联网划分为较小的自治系统（每个自治系统有多个局域网），每个较小的自治系统可以设置自己的路由协议，同时也需要自治系统间的协议来屏蔽不同路由协议自治系统的通信。 自治系统内使用的路由选择协议叫做内部网关协议（IGP） =&amp;gt; 例如RIP，OSPF等 自治系统间使用的路由选择协议叫做外部网关协议（EGP） =&amp;gt; 例如BGP等。 ipv4 ipv4分组格式如下所示 注意：有些描述存储大小的字段是有单位的，比如首部长度，总长度等，这些会在下面单独说明
首部长度单位: 32位（4Byte） 总长度：首部加数据段的总长度，单位：Byte 片位移：由于MTU的限制，ip数据报如果过长会被分片，那么该字段则表示该片段在原分组的相对位置，用于之后在目的地拼接。长度单位：8Byte，所以每个分片的长度一定是8B的整数倍（除最后一片） 网络地址转换（NAT） 将专门网络地址转换为公用地址，从而隐藏内部管理的IP地址。这样做的好处是可以增多主机的ip分配，一个局域网的主机可以用多个内网ip标识，而它们的公网地址则只需要用一个ip标识即可，而NAT就做的是这其中的转换工作。
即一台主机可以用 一个公网ip + 一个内网ip 唯一标识。</description>
    </item>
    
    <item>
      <title>计算机网络-链路层</title>
      <link>https://runtus.top/posts/0910-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/</link>
      <pubDate>Fri, 10 Sep 2021 14:37:48 +0000</pubDate>
      
      <guid>https://runtus.top/posts/0910-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/</guid>
      <description>链路层重点：组帧，流量控制与可靠传输机制，介质访问控制
数据链路层是在物理层提供服务的基础上为网络层提供相关服务，它能够加强物理层中比特流的传输，也能将物理层上可能会出错的物理链路改造为逻辑上无差错的数据链路，然后为网络层提供对应服务。 为网络层提供的连接服务 无确认，无连接服务。 有确认，无连接服务。 有确认，有连接服务。 需要注意的是：只要是能够连接，则一定会有确认，即不存在无确认，有连接的服务。 帧定界 数据帧的长度由首部，尾部，以及数据三者决定，而首部和尾部包含了许多控制信息，其中就包含了帧边界的标识，这就是所谓的帧定界。（注意：链路层封装的数据帧也称为组帧，它的作用就是解决帧定界，帧同步，透明传输等问题）
透明传输：接受方能够正确识别帧尾部，而不会因为数据段有和尾部相同的标识而提前结束帧识别。 下面列举几种帧定界的方法。
字符计数法。 字符填充的首位定界符法。 零比特填充的首位标志法。 违规编码法。 MTU（最大传输单元）：帧数据部分长度的上线（IP数据包）
差错控制 比特传输过程中难免会遇到差错，比如1变为0，0变为1，这种差错也称为比特差错，于是需要通过编码方式对传输的比特实现差错控制，减少或避免误差。 检错编码 =&amp;gt; 检验传输的比特是否出错 奇偶校验法 循环冗余码（CRC：Cycle Redundancy Code） 纠错编码 =&amp;gt; 对出错的比特进行纠错 =&amp;gt; 海明校验 流量控制 为了防止发送方的速度过于快而导致接受方来不及接收从而造成的丢帧现象出现，需要对发送方的发送数据速率作一定的限制，而流量控制的常见方法是通过接收方来控制发送方的速率（由接收方感知，如果速率过快，则返回特定的信息）。 常见的两种流量控制方法 停止-等待协议 ： 发送方发送一帧后，必须等待这一帧的回复才能继续发送下一帧。 滑动窗口协议：发送方维持一组能够发送帧的集合，称为发送窗口，同理接收方也维持一组预接收帧的集合，称为接受窗口。发送窗口外的帧不会发送，接收窗口外的帧不会接收。 可靠传输机制 可靠传输同时使用确认和超时传输这两种机制来完成。 确认是指发送方发送帧后，为了确保该帧顺利到达接收方且没有出错，应该要收到对应的帧回复。 超时传输指发送方发送帧后，会启动一个定时器，如果超过一定时间还没有收到回复帧，则认为帧丢失，需要重传。 自动重传请求（ARQ：Auto Repeat reQuest） 接收方通过请求发送方重传出错的帧来恢复出错的帧。它是处理信道所带来差错的办法之一。 ARQ分类 停止-等待ARQ 后退N帧ARQ（Go-Back-N：GBN） 选择性重传（Selective Repeat：SR） =&amp;gt; 接收方需具备缓存器，缓存出错帧之后已经到达接收方的帧。 介质访问控制（Medium Access Control： MAC） 为使用介质的每个设备与使用同一个介质的其它设备的通信隔离开来，简而言之，就是要保证各个通信设备在使用同一介质时互不干扰，这就是介质访问控制的作用。 常见的介质访问控制分为信道划分MAC（静态划分），随机访问MAC（动态分配），轮询访问MAC（动态分配）。 信道划分介质访问控制 顾名思义，按照某种标准，将信道划分为多个部分以供给多个通信设备使用，由于划分是固定的，所以也是静态划分信道的方法。 频分多路复用（FDM） 时分多路复用（TDM） 波分多路复用（WDM） 码分多路复用（CDM） =&amp;gt; 也叫做码分多址（CDMA：Code Division Multiple Access） 随机访问介质访问控制 ALOHA协议 =&amp;gt; 不检测，直接传，如果一段时间没收到确认，则重传。</description>
    </item>
    
    <item>
      <title>操作系统-2</title>
      <link>https://runtus.top/posts/0909-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 09 Sep 2021 15:19:46 +0000</pubDate>
      
      <guid>https://runtus.top/posts/0909-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>本章主要总结操作系统中的内存管理
随着技术的发展，内存的容量再不断增大，但是也不能把所有用户数据和程序一起装入内存，因此操作系统需要对内存空间进行合理的划分和有效的动态分配，从而提高系统的资源利用率。对内存的合理划分以及有效的动态划分就是内存管理的概念。 程序执行过程 每段程序执行前大致需要经过三个过程：编译 -&amp;gt; 链接 -&amp;gt; 装入 编译：将源代码通过编译器编译为一个个目标模块。 链接：将每个目标模块和所需库函数链接起来，形成一个完整的装入模块。 静态链接（装入前链接），即在装入内存之前把所有的模块和对应的库函数进行链接从而形成一个可执行程序，以后不会再拆开。 装入时动态链接，即在装入内存时，一边装入一边链接。 运行时动态链接，即在执行对应模块代码时，实时链接。 装入：将链接后形成的模块装入内存中。 绝对装入 =&amp;gt; 程序相对地址和实际装入的物理地址相同。 可重定位装入 =&amp;gt; 程序相对地址加一个重定位地址形成实际的物理地址。 动态运行时装入 =&amp;gt; 在执行对应的模块时，才开始执行地址转换，地址转换的偏移量则从重定位寄存器中取出。 内存分配管理方式 连续分配方式：用户程序被分配进一个连续的内存空间 单一连续分配方式: 整个内存中只运行一道用户程序。 固定分区分配 内存被划分为若干个固定大小的区域。当有程序需要装入内存时，从分区说明表上寻找合适的内存区域并分配给它。 动态分区分配 =&amp;gt; 不预先对内存进行分区，而是等程序装入内存时动态分区。 首次适应算法 最佳适应算法 最坏适应算法 邻近适应算法（首次适应算法的改进，即下一次分配内存是从上一次分配内存结束位置开始） 区分内部碎片还是外部碎片的关键在于：内存分区是提前分好还是运行时实时分配的。
对于前者，很容易理解每个内存分区就可以称之为“内”，所以就有了内部碎片的说话。
对于后者，由于没有提前分区，所以自然没有“内”的概念，那么所有的内存都是“外”，所以此时产生的碎片也称为外部碎片。
即固定分区会产生内部碎片，动态分区会产生外部碎片。
非连续分配方式 基本分页存储管理方式 =&amp;gt; 一维表示即可，即给定一个地址，便可以算出它的页号以及偏移地址（因为页的大小是确定的） 基本分段存储管理方式 =&amp;gt; 二维表示，因为每段的大小不同，导致一个地址无法算出其它信息，段号和段内位移地址要显式给出 段页式存储管理方式 =&amp;gt; 对代码分段，对内存分页。 分页系统和分段系统的共同之处：
它们都有对应的“表”，分页系统是页表，分段系统是段表。当然对于表来说也有对应的寄存器（页表/段表寄存器） 它们都可以加入**快表（联想存储器 TLB）**来提高地址转移效率。 不同之处：
分页系统的地址可以进行一维表示，而分段系统的地址需要二维表示。 分段系统中的每段是具有一定逻辑意义的代码集合（比如一块函数定义），方便代码共享。 虚拟内存 局部性原理 =&amp;gt; 高速缓存技术依赖的原理 时间局部性：程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问，不久后该数据可能再次被访问。产生时间局部性的原因是程序中往往含有大量的循环操作 空间局部性：一旦程序访问了某个存储单元，不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在某个区域。 虚拟存储器 根据局部性原理，程序装入时，可以只将程序的部分装入，其余部分留在外存。程序执行过程中，若程序不在内存中，则从外存中调入对应部分的程序代码，然后继续执行程序。另一方面，操作系统也把不再执行的代码重新换出到外存（实际情况是如果代码段没有被修改，则直接丢弃）。这样，系统好像就为用户提供了一个比内存大的多的存储器，称其为虚拟存储。
实现方式
请求分页存储管理 请求分段存储管理 请求段页式存储管理 它们都需要的硬件支持：</description>
    </item>
    
    <item>
      <title>操作系统-1</title>
      <link>https://runtus.top/posts/0908-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 08 Sep 2021 11:02:13 +0000</pubDate>
      
      <guid>https://runtus.top/posts/0908-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>在复试时，很少问及计算题，大多数都是的问题都是和概念直接相关，所以要深刻理解操作系统各个组成部分的概念。
本篇主要归纳操作系统的基本概念以及进程相关概念和算法
操作系统基本概念 首先需要知道操作系统在整个计算机系统中的定位：
​	计算机系统大致可以分为四个部分（自底向上）：计算机硬件 -&amp;gt; 操作系统 -&amp;gt; 应用程序软件 -&amp;gt; 用户。
从上述结构可以轻易看到，操作系统管理着计算机的各个硬件，具体表现为对资源的合理调度，分配等，同时也为上层应用程序软件提供抽象出来的硬件功能。
综上所述，操作系统可以定义为控制和管理整个计算机的硬件和软件资源，并合理地组织，分配资源、调度工作，进而为用户和其它软件提供方便接口与环境的程序集合。 提炼一下，操作系统就是一系列程序的集合，不过这些程序有着上述管理功能。
特征（四大特征） 并发 =&amp;gt; 注意并发和并行的区别。 共享 （两种共享方式，也对应着后续会提到的资源共享形式） 互斥共享 同时访问 虚拟 =&amp;gt; 用逻辑的对应物去映射实际的物理设备，让用户在使用时感觉是在真正使用物理设备。 经典例子: 请求分页系统，SPOOLing技术 异步 =&amp;gt; 进程以不可预知的速度向前执行（进程的异步性） 异步也是操作系统中需要进程控制的原因之一，因为要保证怎么个异步法，各个进程的最终结果都一样。 其中，**并发和共享是其它特性的基础，**它们两也相互依存。
管理的计算机资源（包括硬件和软件）分类 处理机管理 =&amp;gt; 进程的调度与分配 存储器管理 =&amp;gt; 内存管理 文件管理 =&amp;gt; 文件的存储形式：逻辑存储和物理存储 I/O设备管理 =&amp;gt; 外存相关概念以及相关管理 运行环境 CPU的状态分为两类：用户态（目态）和核心态（管态） 用户的程序运行在目态，而操作系统的内核运行在管态。有一些特殊的特权指令，只有在CPU处于管态时才能调用。 特权指令 -&amp;gt; 操作系统不允许用户直接调用的指令，比如I/O指令，置中断指令等等。 如果说用户程序必须使用特权指令的功能，则需要通过中断或异常操作来达到目的，即发生中断或异常时，CPU状态会从用户态转向核心态。 中断和异常 操作系统的发展过程大体上就是一个想法设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源释放，而这一行为就需要通过中断来实现。
中断（外中断）：CPU执行指令以外的事情发生而引起的中断，即外中断不是由指令本身引起的（比如访问数组越界等），而是外界因素导致的（比如I/O中断，时间片中断），它和当前处理机正在运行的程序有关。
异常（内中断，陷入trap）：CPU执行指令时发生的错误异常事件。比如地址越界，请求分页系统的缺页以及专门的陷入指令（这个也是上述用户能够主动进入核心态的办法，也称为系统调用）。
​	系统调用的本质是用户把CPU的使用权交给了操作系统内核的程序，然后让内核程序去执行对应的特权指令，等执行完毕后，再把使用权返回。即关键指令的调用实质还是内核调用而不是用户直接调用。
进程管理 基本概念 在多道程序运行的系统中，由于程序直接“暴露在内存里”，所以导致程序没有封闭性，它们能够彼此看见对方内部的结构，甚至调用，这显然是不行的。于是为了方便描述程序和控制程序的并发，体现操作系统的并发性和共享性，所以引入了进程的概念。 进程（动态的）：是程序的一次执行过程（进程实体的运行过程），是CPU资源分配和调度的基本单位（引入线程之前） PCB（Process Control Block） 程序段 相关数据段 状态 创建态 就绪态 运行态 终止态 阻塞态 它们各自的定义这里不再描述。 需要说明的是，当进程从运行态变换到阻塞态时，是一个主动的行为（即自己需要去请求某个外设资源或等待某一事件发生而引起的阻塞），这是一种特殊的，由运行的用户态程序去调用操作系统内核过程的形式。 而从阻塞态转移到就绪态，这是一个被动过程，因为它需要外界信号进行触发。例如请求的外设已经完成了对应的任务，或是请求的某个资源已经空闲出来等。 进程通信 共享存储空间通信 -&amp;gt; 多个进程共享内存中的某块空间，当需要通信时，在内存中进行读写即可。 消息传递 -&amp;gt; 调用操作系统提供的消息传递方法进行进程通信，即通过发送消息和接受消息两个原语进行通信。 直接通信，即发送进程直接把消息发送给接收消息进程。 间接通信，即发送进程把消息发送给某个中间实体，使其成为一个信箱，而接受进程直接从实体中取消息即可，反之亦然。 管道通信 -&amp;gt; 由pipe文件来连接发消息进程和接受消息进程从而达到通信的目的。（消息查看2022王道考研操作系统P35） 线程 由于进程的切换会有较大的时空开销，于是考虑引入线程，从而提高系统的并发性能（因为线程切换所引起的时空开销要远远小于进程）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://runtus.top/friends/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runtus.top/friends/</guid>
      <description>123 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://runtus.top/ncm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runtus.top/ncm/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://runtus.top/posts/packagejson%E6%95%B0%E6%8D%AE%E9%A1%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://runtus.top/posts/packagejson%E6%95%B0%E6%8D%AE%E9%A1%B9/</guid>
      <description>npm发包相关的packagejson配置说明 将自己的项目上传至npm上时，需要正确设置packagejson中的相关字段，否则会导致上传的项目无法正确在其他地方引用，甚至无法上传至npm官网。
1. name name是整个项目的名称，也是在npm仓库中的唯一索引，当别人下载自己上传的npm包时，其关键字索引便是项目名称。 yarn add axios # axios 便是项目名称 2. version version是版本号，它是一个字符串，每次发版时都要更新该字段。 版本号的编写遵循语义化版本 2.0.0 规范，即**「主版本号. 次版本号. 修订号」** 3. main 指定加载的入口文件，node端和web端都可以使用，当外部使用require来引入npm包时，main指定的文件将以module.export的形式对外暴露。 所以一般情况下，main文件都会指向commonjs规范的文件，如下所示。 mjs文件代表commonjs规范的js文件。 { &amp;#34;main&amp;#34;: &amp;#34;dist/index.cjs&amp;#34; } 4. module 与main不同的是，module指定的是ESM规范的文件入口，web端和node端都可以使用，如果npm包导出的是ESM规范的包，则需要该字段来指定入口文件。 mjs代表是ESM规范的js文件。 { &amp;#34;module&amp;#34;: &amp;#34;dist/index.mjs&amp;#34; } 5. type type用于指定该node项目遵循ESM规范还是Commonjs规范，默认为commonjs项目，若要设置项目为ESM规范，则需要赋值module。 { &amp;#34;type&amp;#34;: &amp;#34;module&amp;#34; } 同时当项目是ESM规范时，需要指定入口文件，即设置module字段。 6. types 指定声明文件位置，即d.ts文件。 7. files files字段接收一个数组，用来指明在发布npm包时，哪些文件需要上传至npm服务器上。或者说，用来描述当把 npm 包作为依赖包安装时需要说明的文件列表。 需要说明的是，如果有文件不想上传到npm服务器上，可以用.npmignore来说明哪些文件不需要上传（和.gitignore类似） </description>
    </item>
    
    
    
  </channel>
</rss>
