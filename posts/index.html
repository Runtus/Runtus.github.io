<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Runtus</title><meta name=keywords content><meta name=description content="Posts - Runtus"><meta name=author content="Runtus"><link rel=canonical href=https://runtus.top/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><link rel=icon href=https://runtus.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://runtus.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://runtus.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://runtus.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://runtus.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://runtus.top/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="blog from Runtus"><meta property="og:type" content="website"><meta property="og:url" content="https://runtus.top/posts/"><meta property="og:image" content="https://lao-lan-go.oss-cn-beijing.aliyuncs.com/highQua/pixiv34.JPG"><meta property="og:site_name" content="Runtus"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lao-lan-go.oss-cn-beijing.aliyuncs.com/highQua/pixiv34.JPG"><meta name=twitter:title content="Posts"><meta name=twitter:description content="blog from Runtus"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://runtus.top/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://runtus.top/ accesskey=h title="Home (Alt + H)"><img src=https://runtus.top/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://runtus.top/archives/ title=archives><span>archives</span></a></li><li><a href=https://runtus.top/tags/ title=tags><span>tags</span></a></li><li><a href=https://runtus.top/friends title=friends><span>friends</span></a></li><li><a href=https://github.com/Runtus title=github><span>github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://runtus.top/>Home</a></div><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2>再拾docker</h2></header><div class=entry-content><p>记录docker的基本概念和用法，系统的再认识一次docker
docker是什么 Docker是对Linux容器的一种封装，并提供简单易用的接口，同时它也是目前最流行的Linux容器解决方案。
在docker出现之前，环境移植一直是非常麻烦的事情，当我们需要把项目从一台机器迁移到另一台机器时，不仅仅是迁移源代码，更重要的是要保证环境的一致性，而一次次环境的搭建则显得冗余且效率极低，所以在思考有没有一种方式能够把环境一起进行迁移。
虚拟机的出现在一定程度上解决了这个问题，但接踵而至的问题是：
虚拟机占用资源多，它本质就是一台完整的操作系统， 冗余步骤多，由于是完整的操作系统，一些系统级别的操作步骤不可避免。 启动慢。 所以Linux发展出了另一种虚拟化技术：Linux容器。而docker则是Linux容器的一种解决方案（也是最流行的）
可以简单的将docker理解为一种非常轻量级的虚拟机。
docker镜像（image文件） docker把应用程序及其依赖打包在image文件里，通过image文件，就会生成容器（后续会提到），即镜像文件其实就是容器的模版，而容器则是镜像文件的实例（可以一一对应类与对象） image文件是二进制文件。在实际开发中，我们会在别人写好的image文件上加一些自定义设置从而形成我们需要的image文件，而不是自己从零开发一个image文件（当然，有需求另说）。 # 有关image命令 docker image ls # 列出docker镜像 docker image rm [imageName] # 删除某镜像文件 容器文件 由image生成的容器实例，本身也是一个文件，称为容器文件。同时，当关闭容器时不会删除容器文件，只是让容器停止运行而已。 docker container ls # 本机正在运行的容器 docker container ls --all # 本机所有容器 每个容器都有一个唯一ID，如果需要终结容器的运行，需要使用kill命令docker container kill。 如需要删除容器文件，需要使用rm命令。 docker container rm [containerID]</p></div><footer class=entry-footer><span title='2022-01-29 11:10:01 +0000 UTC'>January 29, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;47 words&nbsp;·&nbsp;Runtus</footer><a class=entry-link aria-label="post link to 再拾docker" href=https://runtus.top/posts/%E5%86%8D%E6%8B%BEdocker/></a></article><article class=post-entry><header class=entry-header><h2>go-learning-1</h2></header><div class=entry-content><p>Golang学习记录
关于swtich Golang中的switch的每个case自带break关键字，即不用手动去设置break关键字。 import ( "fmt" ) func main(){ variables := 12 switch variables { case 24: fmt.Println('24') case 12: fmt.Println('12') case 36: fmt.Println('36') default: fmt.Println('114514') } } // 12 如果在其他语言中这样编写switch代码块，36和default代码块中的输出也会执行。 fallthrough关键字 当然，golang也提供了能够无视掉默认break的关键字，即fallthrough，在指定的case最后一行加上fallthrough，则对应的case代码块将会忽视掉默认的break操作。 // 接上 func main(){ variables := 12 switch variables { case 24: fmt.Println('24') case 12: fmt.Println('12') fallthrough case 36: fmt.Println('36') default: fmt.Println('114514') } } // 12 // 36 关于数组 在golang中的数组和c一样，一旦定义了大小就不可更改，且声明方式有多种，如下: // var variable_name [SIZE] variable_type func main(){ var balance = [3]float32{100, 2....</p></div><footer class=entry-footer><span title='2022-01-28 09:13:38 +0000 UTC'>January 28, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;384 words&nbsp;·&nbsp;Runtus</footer><a class=entry-link aria-label="post link to go-learning-1" href=https://runtus.top/posts/go-learning-1/></a></article><article class=post-entry><header class=entry-header><h2>0120-浏览器事件</h2></header><div class=entry-content><p>Javascript和HTML的交互都是通过事件来实现的，而事件的产生与执行则是遵循着传统软件工程领域中的观察者模式，其能够做到页面行为和页面展示的解耦合。
本节内容会从事件流谈起，然后逐一介绍几种注册事件的方式以及他们其中的一些细节，最后还会提到关于**事件委托（代理）**的概念。
事件流 事件流描述了页面接受事件的顺序。因为一个事件的触发可能会影响好几处地方，这很容易理解，比如在页面上嵌套着写了几个div元素，同时在最里层的div元素上进行事件触发，那这不仅仅是最内层的div对事件进行响应，任意一层的嵌套的div都会对事件进行相应处理。（其实通过上述的观察者模式也可以推断出其合理性，因为一个对象可以由多个观察者进行观察） 所以多个监听事件的元素响应顺序需要进行统一，因为一些历史原因，事件的响应顺序有两种模式：冒泡和捕获。 事件冒泡 顾名思义，事件的冒泡就如水底下的气泡一下，从内到外，同理，事件冒泡规定的事件流顺序也是从内而外，事件会从最深层的节点开始触发，然后向外传播到document（文档）。 代码如下所示。 &lt;html> &lt;body> &lt;div id="ddd"> click me &lt;/div> &lt;/body> &lt;/html> 此时我如果对id=ddd的div元素进行click事件触发，那么该事件会以如下顺序发生: div body html document 现代的浏览器的事件会一直冒泡到window对象。 事件捕获 事件捕获则和事件冒泡相反，事件的响应顺序是从外到内的，还是以上一个例子为例，那么对应click事件讲会以如下顺序发生: document html body div DOM事件流 DOM2 Events规范里规定里事件流为分三个部分：事件捕获，到达目标和事件冒泡。 需要注意的是，div元素（即直接触发元素）是不会响应捕获事件的，因为通常认为直接触发事件是冒泡阶段发生的，所以它也是冒泡阶段第一个发生的事件。 但现在大多数支持DOM事件流的浏览器都实现了一个小小的拓展，即在捕获阶段在事件目标上触发事件。最终结果表现为有两个机会来处理事件。 事件处理程序 事件意味着用户或浏览器执行的某种动作，而为响应事件而调用的函数被称为事件处理程序（事件监听器）。 HTML事件处理程序 HTML事件处理程序是以HTML属性的形式来进行指定的。该属性的值必须是能够执行的javascript代码。 比如下面这个例子，就是按钮在被点击时执行一段代码。 &lt;button onclick="console.log('click')"> click me &lt;/button> 当然也可以以函数的形式来进行响应事件定义。 &lt;script> function click(event){ console.log('click') } &lt;/script> &lt;button onclick="click(event)"> click me &lt;/button> 可以看到，除了把函数单独拎出来以外，还多了一个event对象，这个是一个特殊的局部变量，它定义了事件触发的一些属性以及被触发元素的一些属性。 除此之外，HTML事件处理程序中的this就是DOM元素本身，所以可以直接使用this对象去获取对应元素上的属性。 &lt;input type="button" value="Click Me" onclick="console.log(this.value)"> 这里还有个比较有趣的地方，获取元素属性时可以直接省略掉this，直接使用value，即下面写法也能达到同样的效果。 &lt;input type="button" value="Click Me" onclick="console.log(value)"> 因为这个包装函数在创建时其作用域链被with操作符给延长了，所以document和元素自身的成员都可以被当成局部变量来使用。 function() { with(document) { with(this) { // 属性值 } } } 但最好不要这样做，因为不仅仅会显得很诡异，而且在后期调试时也会造成误解。 HTML事件处理程序一个比较大的问题是：它把HTML和Javascript在代码上进行了强耦合（在逻辑上依然是分开的），如果我们需要更改响应程序，那么两处都需要进行修改。...</p></div><footer class=entry-footer><span title='2022-01-20 10:30:44 +0000 UTC'>January 20, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;260 words&nbsp;·&nbsp;Runtus</footer><a class=entry-link aria-label="post link to 0120-浏览器事件" href=https://runtus.top/posts/0120-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6/></a></article><article class=post-entry><header class=entry-header><h2>DOM扩展</h2></header><div class=entry-content><p>虽然原生DOM API已经能做许多事情了，但是仍然不断有标准或专有的扩展出现，以支持更多的功能，由于各个浏览器对DOM扩展的支持是专有的，为了统一这些专有的DOM API，W3C开始着手将这些专有扩展转变为标准规范。
Selectors API Selectors APIs 是浏览器原生支持的CSS查询API，由于是原生支持，解析和遍历DOM树可以通过底层编译语言实现，相比其他Javascript库（比如jQuery），性能有数量级的提升。 Selectors API Level 1 主要是两个API：querySelector() 和 querySelectorAll() querySelector() 该方法接受CSS选择符参数，返回匹配到的第一个后代元素，如果没有匹配元素则返回null。 // 匹配 class 为 list 的第一个DOM元素 document.querySelector('.list') // 匹配 id 为 myDiv 的第一个DOM元素 document.querySelector('#myDiv') // 匹配 class=header DOM元素子元素中 id为someDiv的元素 const header = querySelector('.header'); header.querySelector('#someDiv') 如果直接在document上使用querySelector方法，会从文档元素开始搜索（前两个例子）；在Element上使用querySelector方法，则只会在该元素的后代中查询（第三个例子）。 querySelectorAll() 该方法和querySelector类似，接受CSS选择符参数，只不过它会返回匹配的所有节点。即返回的是一个NodeList的静态实例。
⚠️注意：无论是querySelector还是querySelectorAll返回的都是DOM元素的静态快照，即和之前提到的getElementById获取的动态实例不同，更改静态快照是不会影响DOM元素在页面上的渲染。
matches() matches方法接受一个css选择符参数，用于判断是否存在对应css选择符的DOM元素，如果存在返回true，否则返回false。 if(document.body.matches("body.header")){ // true } CSS类扩展 HTML5增加了一些特性以方便使用CSS类。 getElementsByClassName() 该方法接受一个参数，包含一个或多个类名的字符串，返回类名中包含对应类的元素的NodeList。 // 返回 class 包含 username 和 current 的类 document.getElementsByClassName('username current') classList属性 classList属性提供了快速操作DOM元素类名的方法，如果是之前，对一个含有多个class的DOM元素进行类名操作会很麻烦，基本操作都是把其类字符串解析成数组，然后一个一个进行匹配操作，最后再合并为一个新的类字符串重新赋值回去。 // 要删除"user"类 let targetClass = "user"; // 把类名拆成数组 let classNames = div....</p></div><footer class=entry-footer><span title='2021-12-26 10:22:54 +0000 UTC'>December 26, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;114 words&nbsp;·&nbsp;Runtus</footer><a class=entry-link aria-label="post link to DOM扩展" href=https://runtus.top/posts/dom%E6%89%A9%E5%B1%95/></a></article><article class=post-entry><header class=entry-header><h2>1224-浏览器缓存</h2></header><div class=entry-content><p>浏览器缓存是性能优化中最直接，高效的优化方式，它可以显著减少因为网络传输而带来的损耗。
对于数据请求来说，大致可以分为 请求 -> 处理 -> 响应这三个步骤，而浏览器缓存则主要在第一步和第三步做手脚，即请求发出时寻找合适的缓存，拿到新的响应数据时做新的缓存。 缓存带给我们最直观的感受就是，每次加载页面，第二次之后加载总是比第一次加载的更快，这就是缓存的功劳，下面讲从缓存位置和缓存策略两个方面介绍浏览器相关缓存。 缓存位置 浏览器的缓存位置大概可以分为四种： Service Worker Memory Cache Disk Cache Push Cache（HTTP 2） 他们有各自的优先级，当发出请求时，浏览器会依次去寻找缓存，如果都没有命中，才会发出请求。 Service Worker Service Worker是浏览器背后的独立线程，可以用来实现缓存功能，但是需要注意，如果要使用Service Worker，传输协议必须是HTTPS。 Service Worker实现缓存大致三个步骤。 注册Service Worker。 监听install事件，并对需要的文件进行缓存。 拦截HTTPS请求，并根据请求内容去命中缓存，如果命中，则直接使用缓存，否则请求数据。 下面是一串实例代码（源代码来自前端面试之道） // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register('sw.js') .then(function(registration) { console.log('service worker 注册成功') }) .catch(function(err) { console.log('servcie worker 注册失败') }) } // sw.js // 监听install事件，缓存文件 self.addEventListener('install', e => { e.waitUntil( caches.open('my-cache').then(function(cache) { return cache.addAll(['./index.html', './index.js']) }) ) }) // 拦截请求，并根据请求去命中响应数据 self....</p></div><footer class=entry-footer><span title='2021-12-24 10:35:37 +0000 UTC'>December 24, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;144 words&nbsp;·&nbsp;Runtus</footer><a class=entry-link aria-label="post link to 1224-浏览器缓存" href=https://runtus.top/posts/1224-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://runtus.top/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://runtus.top/>Runtus</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>