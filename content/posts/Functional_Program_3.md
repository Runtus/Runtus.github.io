---
title: "Functional_Program_3"
date: 2023-03-23T09:28:58+08:00
tags: ["FP"]
---

> 关于副作用以及外部引用与函数式编程的关系

## Pure Happiness with Pure Functions

### 禁止与外界交互

* 在第二章中也有说到，保持纯函数的关键在于不能与外界有直接交互，即直接引用。
* 这样有个好处是能让函数能够自给自足，从而能够只看函数本身就能更加轻松了解到函数本身的功能，而不需要借助外部变量来理解，例如以下的例子。

```js
let minimum = 21
const checkAge = age => age => minium
```

* `checkage`依赖与外部变量minium，假如该变量声明的位置很远，当后续维护时会对这段代码返回的结果感到匪夷所思，不知道其值到底从何而来。



### 副作用

* 对于函数而言，函数的副作用就是函数执行时对外界环境产生了影响（无论是依赖还是修改）。
* 上述的与外界交互也算是副作用的一种，副作用在计算机领域并不是贬义的含义，只是对代码执行过程的一种结果的描述，只不过**在函数式编程中，副作用被视为不好的程序过程执行。**
* 下面列举了一些副作用的例子。

1. 更改文件`fs`
2. 数据库访问
3. 发起http请求
4. DOM控制
5. 获取系统状态
6. 获取用户的输入
7. so on.....

* 并不是说在函数式编程中，我们要**完全**拒绝以上操作，而是要**能控制这一系列**操作。后续会介绍如何去进行这一个控制过程（柯里化），下面先介绍如何将纯函数从一个普通的函数中分离出来。



### 纯函数的分离

* 一个对外界依赖的函数要分离成纯函数，就必须要显式告知函数要依赖的对象是谁，即把要依赖的对象作为参数传递，从而将**外部依赖**改为**内部依赖**。

```js
// 不纯函数，其没有显示告知函数依赖的对象是谁。
const signUp = (attrs) => {
  const user = saveUser(attrs);
  welcomeUser(user);
};

// pure -> 将DB，Email显示告知
const signUp = (Db, Email, attrs) => () => {
  const user = saveUser(Db, attrs);
  welcomeUser(Email, user);
};
```

* 这样做的好处不仅仅是让函数的依赖关系更加明确从而使得函数可读性增强，而且还让函数的复用性增强，一旦`Db`或`Email`有变化，只需要重新设置这两参数，再获取一个SignUp即可。



