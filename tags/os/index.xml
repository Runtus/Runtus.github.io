<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>OS on Runtus</title>
    <link>https://runtus.top/tags/os/</link>
    <description>Recent content in OS on Runtus</description>
    <image>
      <title>Runtus</title>
      <url>https://lao-lan-go.oss-cn-beijing.aliyuncs.com/highQua/pixiv34.JPG</url>
      <link>https://lao-lan-go.oss-cn-beijing.aliyuncs.com/highQua/pixiv34.JPG</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 09 Sep 2021 15:19:46 +0000</lastBuildDate><atom:link href="https://runtus.top/tags/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>操作系统-2</title>
      <link>https://runtus.top/posts/0909-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 09 Sep 2021 15:19:46 +0000</pubDate>
      
      <guid>https://runtus.top/posts/0909-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本章主要总结操作系统中的内存管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;随着技术的发展，内存的容量再不断增大，但是也不能把所有用户数据和程序一起装入内存，因此&lt;strong&gt;操作系统&lt;/strong&gt;需要对内存空间进行合理的划分和有效的动态分配，从而提高系统的资源利用率。&lt;strong&gt;对内存的合理划分以及有效的动态划分&lt;/strong&gt;就是内存管理的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;程序执行过程&#34;&gt;程序执行过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每段程序执行前大致需要经过三个过程：编译 -&amp;gt; 链接 -&amp;gt; 装入
&lt;ol&gt;
&lt;li&gt;编译：将源代码通过编译器编译为一个个目标模块。&lt;/li&gt;
&lt;li&gt;链接：将每个目标模块和&lt;strong&gt;所需库函数&lt;/strong&gt;链接起来，形成一个完整的装入模块。
&lt;ol&gt;
&lt;li&gt;静态链接（装入前链接），即在装入内存之前把所有的模块和对应的库函数进行链接从而形成一个可执行程序，以后不会再拆开。&lt;/li&gt;
&lt;li&gt;装入时动态链接，即在装入内存时，一边装入一边链接。&lt;/li&gt;
&lt;li&gt;运行时动态链接，即在执行对应模块代码时，实时链接。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;装入：将链接后形成的模块装入内存中。
&lt;ol&gt;
&lt;li&gt;绝对装入 =&amp;gt; 程序相对地址和实际装入的物理地址相同。&lt;/li&gt;
&lt;li&gt;可重定位装入 =&amp;gt; 程序相对地址加一个&lt;strong&gt;重定位地址&lt;/strong&gt;形成实际的物理地址。&lt;/li&gt;
&lt;li&gt;动态运行时装入 =&amp;gt; 在执行对应的模块时，才开始执行&lt;strong&gt;地址转换&lt;/strong&gt;，地址转换的偏移量则从&lt;strong&gt;重定位寄存器&lt;/strong&gt;中取出。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存分配管理方式&#34;&gt;内存分配管理方式&lt;/h3&gt;
&lt;h4 id=&#34;连续分配方式用户程序被分配进一个连续的内存空间&#34;&gt;连续分配方式：用户程序被分配进一个连续的内存空间&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;单一连续分配方式:  整个内存中只运行一道用户程序。&lt;/li&gt;
&lt;li&gt;固定分区分配
&lt;ul&gt;
&lt;li&gt;内存被划分为若干个固定大小的区域。当有程序需要装入内存时，从&lt;strong&gt;分区说明表&lt;/strong&gt;上寻找合适的内存区域并分配给它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态分区分配 =&amp;gt; 不预先对内存进行分区，而是等程序装入内存时动态分区。
&lt;ol&gt;
&lt;li&gt;首次适应算法&lt;/li&gt;
&lt;li&gt;最佳适应算法&lt;/li&gt;
&lt;li&gt;最坏适应算法&lt;/li&gt;
&lt;li&gt;邻近适应算法（首次适应算法的改进，即下一次分配内存是从上一次分配内存结束位置开始）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;区分内部碎片还是外部碎片的关键在于：内存分区是提前分好还是运行时实时分配的。&lt;/p&gt;
&lt;p&gt;对于前者，很容易理解每个内存分区就可以称之为“内”，所以就有了内部碎片的说话。&lt;/p&gt;
&lt;p&gt;对于后者，由于没有提前分区，所以自然没有“内”的概念，那么所有的内存都是“外”，所以此时产生的碎片也称为外部碎片。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>操作系统-1</title>
      <link>https://runtus.top/posts/0908-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 08 Sep 2021 11:02:13 +0000</pubDate>
      
      <guid>https://runtus.top/posts/0908-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在复试时，很少问及计算题，大多数都是的问题都是和概念直接相关，所以要深刻理解操作系统各个组成部分的概念。&lt;/p&gt;
&lt;p&gt;本篇主要归纳操作系统的基本概念以及进程相关概念和算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;操作系统基本概念&#34;&gt;操作系统基本概念&lt;/h2&gt;
&lt;p&gt;首先需要知道操作系统在整个计算机系统中的定位：&lt;/p&gt;
&lt;p&gt;​	计算机系统大致可以分为四个部分（自底向上）：计算机硬件 -&amp;gt; 操作系统 -&amp;gt; 应用程序软件 -&amp;gt; 用户。&lt;/p&gt;
&lt;p&gt;从上述结构可以轻易看到，操作系统管理着计算机的各个硬件，具体表现为对资源的合理调度，分配等，同时也为上层应用程序软件提供&lt;strong&gt;抽象出来&lt;/strong&gt;的硬件功能。&lt;/p&gt;
&lt;p&gt;综上所述，操作系统可以定义为&lt;strong&gt;控制和管理整个计算机的硬件和软件资源，并合理地组织，分配资源、调度工作，进而为用户和其它软件提供方便接口与环境的程序集合。&lt;/strong&gt; 提炼一下，操作系统就是一系列程序的集合，不过这些程序有着上述管理功能。&lt;/p&gt;
&lt;h3 id=&#34;特征四大特征&#34;&gt;特征（四大特征）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;并发 =&amp;gt; 注意并发和并行的区别。&lt;/li&gt;
&lt;li&gt;共享 （两种共享方式，也对应着后续会提到的资源共享形式）
&lt;ol&gt;
&lt;li&gt;互斥共享&lt;/li&gt;
&lt;li&gt;同时访问&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;虚拟 =&amp;gt; 用逻辑的对应物去映射实际的物理设备，让用户在使用时感觉是在真正使用物理设备。
&lt;ul&gt;
&lt;li&gt;经典例子: 请求分页系统，SPOOLing技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异步 =&amp;gt; 进程以不可预知的速度向前执行（进程的异步性）
&lt;ul&gt;
&lt;li&gt;异步也是操作系统中需要进程控制的原因之一，因为要保证&lt;strong&gt;怎么个异步法，各个进程的最终结果都一样。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，**并发和共享是其它特性的基础，**它们两也相互依存。&lt;/p&gt;
&lt;h3 id=&#34;管理的计算机资源包括硬件和软件分类&#34;&gt;管理的计算机资源（包括硬件和软件）分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;处理机管理 =&amp;gt; 进程的调度与分配&lt;/li&gt;
&lt;li&gt;存储器管理 =&amp;gt; 内存管理&lt;/li&gt;
&lt;li&gt;文件管理 =&amp;gt; 文件的存储形式：逻辑存储和物理存储&lt;/li&gt;
&lt;li&gt;I/O设备管理 =&amp;gt; 外存相关概念以及相关管理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;运行环境&#34;&gt;运行环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CPU的状态分为两类：&lt;strong&gt;用户态（目态）&lt;strong&gt;和&lt;/strong&gt;核心态（管态）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用户的程序运行在目态，而操作系统的内核运行在管态。有一些特殊的&lt;strong&gt;特权指令&lt;/strong&gt;，只有在CPU处于管态时才能调用。
&lt;ul&gt;
&lt;li&gt;特权指令 -&amp;gt; 操作系统不允许用户直接调用的指令，比如I/O指令，置中断指令等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果说用户程序必须使用&lt;strong&gt;特权指令的功能&lt;/strong&gt;，则需要通过&lt;strong&gt;中断或异常&lt;/strong&gt;操作来达到目的，即发生中断或异常时，CPU状态会从用户态转向核心态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断和异常&#34;&gt;中断和异常&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统的发展过程大体上就是一个想法设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源释放，而这一行为就需要通过中断来实现。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
